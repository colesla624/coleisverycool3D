<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lava Monkey Jungle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; touch-action:none; font-family:system-ui, sans-serif; }
    canvas { display:block; }
    #overlay { position:absolute; top:10px; left:10px; z-index:5; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; }
    #overlay .small { font-size:12px; opacity:0.85; font-weight:500; }
    #controls { position:absolute; bottom:16px; left:16px; right:16px; z-index:5; display:flex; justify-content:space-between; align-items:flex-end; pointer-events:none; }
    .stick { width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); position:relative; pointer-events:auto; touch-action:none; }
    .knob { position:absolute; width:64px; height:64px; border-radius:50%; background:rgba(255,255,255,0.25); left:calc(50% - 32px); top:calc(50% - 32px); }
    #rightPanel { display:flex; flex-direction:column; align-items:center; gap:12px; pointer-events:auto; }
    .button { pointer-events:auto; touch-action:none; width:84px; height:84px; border-radius:16px; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); color:#fff; display:grid; place-items:center; font-weight:800; }
    #viewBtn { position:absolute; top:16px; right:16px; z-index:6; padding:10px 14px; border-radius:12px; }
    #message { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#fff; z-index:6; text-align:center; font-weight:800; font-size:24px; display:none; }
    #message button { margin-top:12px; background:#ff6a00; border:none; color:#fff; font-weight:800; padding:10px 16px; border-radius:10px; cursor:pointer; }
  </style>
</head>
<body>
  <div id="overlay">
    <div>Survive: <span id="timer">0.0</span>s &nbsp; | &nbsp; Health: <span id="hp">100</span></div>
    <div class="small">Desktop: WASD/arrows + Space, drag to look, F to attack. Mobile: Left stick = move (forward/back flipped), Right stick = look, Jump.</div>
  </div>

  <div id="controls">
    <div id="leftStick" class="stick"><div class="knob" id="leftKnob"></div></div>
    <div id="rightPanel">
      <div id="rightStick" class="stick"><div class="knob" id="rightKnob"></div></div>
      <div id="jumpBtn" class="button">JUMP</div>
    </div>
  </div>

  <div id="viewBtn" class="button">VIEW: FIRST</div>

  <div id="message">
    <div id="msgText">Game Over — the lava monkeys got you!</div>
    <button id="restart">Restart</button>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Scene and camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // daytime sky blue
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);

    // Daytime lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x228822, 1.0));
    const sun = new THREE.DirectionalLight(0xffffff, 1.5);
    sun.position.set(20, 40, 10);
    scene.add(sun);

    // Jungle ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(140, 140),
      new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Jungle trees
    function addTree(x, z) {
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.25, 2.2, 10),
        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
      );
      trunk.position.set(x, 1.1, z);
      const foliage = new THREE.Mesh(
        new THREE.SphereGeometry(1.3, 18, 18),
        new THREE.MeshStandardMaterial({ color: 0x006400 })
      );
      foliage.position.set(x, 2.6, z);
      scene.add(trunk, foliage);
    }
    for (let i = 0; i < 28; i++) {
      const a = Math.random() * Math.PI * 2, d = 12 + Math.random() * 55;
      addTree(Math.cos(a) * d, Math.sin(a) * d);
    }

    // Player (visible capsule) and weapon
    const playerRadius = 0.5;
    const player = new THREE.Mesh(
      new THREE.CapsuleGeometry(playerRadius, 0.6, 8, 16),
      new THREE.MeshStandardMaterial({ color: 0x66aaff })
    );
    player.position.set(0, playerRadius + 0.3, 0);
    scene.add(player);

    const weapon = new THREE.Mesh(
      new THREE.BoxGeometry(0.12, 0.7, 0.12),
      new THREE.MeshStandardMaterial({ color: 0x885000 })
    );
    weapon.position.set(0.45, 0.35, 0.0);
    player.add(weapon);

    // Attack state
    let attacking = false;
    let attackStart = 0;
    const attackDuration = 200; // ms
    const attackRange = 1.4;
    const attackArcCos = Math.cos(Math.PI / 3); // 60° front arc

    // Monkeys
    const enemies = [];
    function createMonkey() {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color: 0x7a4b2a });
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), mat);
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), mat);
      head.position.set(0, 0.52, 0.02);
      const earL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mat);
      earL.position.set(-0.22, 0.58, 0.02);
      const earR = earL.clone(); earR.position.x = 0.22;
      group.add(body, head, earL, earR);
      return group;
    }
    function spawnEnemy() {
      const e = createMonkey();
      const a = Math.random() * Math.PI * 2, d = 16 + Math.random() * 14;
      e.position.set(Math.cos(a) * d, 0.45, Math.sin(a) * d);
      e.userData.speed = 2.4 + Math.random() * 0.9;
      enemies.push(e);
      scene.add(e);
    }
    let spawnTimer = setInterval(() => { if (running) spawnEnemy(); }, 1000);

    // Lava
    const lava = new THREE.Mesh(
      new THREE.CylinderGeometry(80, 80, 0.3, 48, 1, true),
      new THREE.MeshStandardMaterial({ color: 0xff3c00, emissive: 0xff2200, emissiveIntensity: 0.95 })
    );
    lava.position.y = -2.5;
    scene.add(lava);

    // Game state
    let running = true, health = 100, startTime = performance.now();
    const keys = {};
    const velocity = new THREE.Vector3();
    const accelGround = 16, accelAir = 6, friction = 12, maxSpeed = 7.2, gravity = 18, jumpStrength = 7.8;
    let onGround = true, yaw = 0, pitch = 0;
    let cameraMode = 'first';

    // UI
    const timerEl = document.getElementById('timer');
    const hpEl = document.getElementById('hp');
    const msg = document.getElementById('message');
    const msgText = document.getElementById('msgText');
    const restartBtn = document.getElementById('restart');
    const viewBtn = document.getElementById('viewBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    // Keyboard
    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.code] = false; });
    window.addEventListener('keydown', e => { if (e.code === 'Space' && onGround && running) velocity.y = jumpStrength; });
    window.addEventListener('keydown', e => { if (e.code === 'KeyF' && running) startAttack(); });

    // Mouse look (yaw/pitch only — no roll)
    let draggingLook = false, lastPointer = null;
    renderer.domElement.addEventListener('pointerdown', e => {
      draggingLook = true; lastPointer = { x: e.clientX, y: e.clientY };
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener('pointerup', e => {
      draggingLook = false; lastPointer = null;
      renderer.domElement.releasePointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener('pointermove', e => {
      if (!draggingLook || !running) return;
      const dx = e.clientX - lastPointer.x, dy = e.clientY - lastPointer.y;
      lastPointer = { x: e.clientX, y: e.clientY };
      yaw += dx * 0.0025;
      pitch = THREE.MathUtils.clamp(pitch + dy * 0.0024, -1.2, 1.2);
    });

    // Joysticks
    function setupStick(stickId, knobId) {
      const stick = document.getElementById(stickId), knob = document.getElementById(knobId);
      let vec = { x: 0, y: 0 }, active = false;
      function setKnob(x, y) {
        const r = stick.getBoundingClientRect();
        knob.style.left = `${x - r.left - 32}px`;
        knob.style.top = `${y - r.top - 32}px`;
      }
      function handle(e, a) {
        const r = stick.getBoundingClientRect(), cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let x = e.clientX, y = e.clientY; if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
        const dx = x - cx, dy = y - cy, len = Math.min(Math.hypot(dx, dy), r.width * 0.45);
        const nx = len ? dx / len : 0, ny = len ? dy / len : 0;
        active = a;
        if (a) { setKnob(cx + nx * len, cy + ny * len); vec = { x: nx * (len / (r.width * 0.45)), y: ny * (len / (r.width * 0.45)) }; }
        else { setKnob(cx, cy); vec = { x: 0, y: 0 }; }
      }
      stick.addEventListener('pointerdown', e => { stick.setPointerCapture(e.pointerId); handle(e, true); });
      stick.addEventListener('pointermove', e => { if (active) handle(e, true); });
      stick.addEventListener('pointerup', e => { stick.releasePointerCapture(e.pointerId); handle(e, false); });
      stick.addEventListener('touchstart', e => handle(e, true), { passive: false });
      stick.addEventListener('touchmove', e => handle(e, true), { passive: false });
      stick.addEventListener('touchend', e => handle(e, false), { passive: false });
      return { get: () => vec };
    }
    const moveStick = setupStick('leftStick', 'leftKnob');   // movement — flip forward/back only
    const lookStick = setupStick('rightStick', 'rightKnob'); // camera look

    // Jump button
    jumpBtn.addEventListener('pointerdown', () => { if (onGround && running) velocity.y = jumpStrength; });
    jumpBtn.addEventListener('touchstart', () => { if (onGround && running) velocity.y = jumpStrength; }, { passive: true });

    // View toggle
    viewBtn.addEventListener('click', () => {
      cameraMode = (cameraMode === 'first') ? 'third' : 'first';
      viewBtn.textContent = `VIEW: ${cameraMode.toUpperCase()}`;
    });

    // Restart
    restartBtn.addEventListener('click', () => {
      health = 100; running = true; startTime = performance.now();
      velocity.set(0, 0, 0); player.position.set(0, playerRadius + 0.3, 0);
      yaw = 0; pitch = 0; lava.position.y = -2.5;
      enemies.forEach(e => scene.remove(e)); enemies.length = 0;
      clearInterval(spawnTimer); spawnTimer = setInterval(() => { if (running) spawnEnemy(); }, 1000);
      msg.style.display = 'none';
    });

    // Attack
    function startAttack() {
      if (attacking) return;
      attacking = true; attackStart = performance.now();
      weapon.rotation.z = -Math.PI * 0.35; // wind-up
      performAttackHit();
      setTimeout(() => { attacking = false; weapon.rotation.z = 0; }, attackDuration);
    }
    // Simple mobile attack (tap anywhere triggers — adjust if you want a specific area)
    renderer.domElement.addEventListener('touchstart', () => { if (running) startAttack(); }, { passive: true });

    function performAttackHit() {
      const forward = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
      const playerPos = player.position.clone();
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const toEnemy = new THREE.Vector3().subVectors(e.position, playerPos);
        const dist = toEnemy.length();
        if (dist > attackRange) continue;
        toEnemy.normalize();
        const dot = toEnemy.dot(forward);
        if (dot >= attackArcCos) { scene.remove(e); enemies.splice(i, 1); }
      }
    }

    // Loop
    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 1000, 1 / 30); last = now;
      if (running) update(dt, now);
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt, now) {
      // Look via right stick (yaw/pitch; no roll)
      const ls = lookStick.get(), lookSensitivity = 1.8;
      yaw += ls.x * lookSensitivity * dt;
      pitch = THREE.MathUtils.clamp(pitch + ls.y * lookSensitivity * dt, -1.2, 1.2);

      // Keyboard + movement stick
      const kForward = (keys.KeyW || keys.ArrowUp) ? 1 : 0;
      const kBack    = (keys.KeyS || keys.ArrowDown) ? 1 : 0;
      const kLeft    = (keys.KeyA || keys.ArrowLeft) ? 1 : 0;
      const kRight   = (keys.KeyD || keys.ArrowRight) ? 1 : 0;

      const mv = moveStick.get();
      // Flip forward/back only: up (ny<0) becomes backward; down (ny>0) becomes forward
      let inputX = (kRight - kLeft) + mv.x;   // horizontal normal
      let inputY = (kForward - kBack) - mv.y; // vertical flipped

      // Normalize combined input
      const mag = Math.hypot(inputX, inputY);
      if (mag > 1) { inputX /= mag; inputY /= mag; }

      // Direction from yaw
      const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
      const forward = new THREE.Vector3(sinY, 0, -cosY);
      const right = new THREE.Vector3(cosY, 0, sinY);
      const wishdir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
      if (wishdir.lengthSq() > 0) wishdir.normalize();

      // Acceleration and friction
      const accel = onGround ? accelGround : accelAir;
      velocity.addScaledVector(wishdir, accel * dt);

      if (onGround && mag < 0.05) {
        const horiz = new THREE.Vector2(velocity.x, velocity.z);
        const speed = horiz.length();
        const drop = friction * dt;
        const newSpeed = Math.max(speed - drop, 0);
        if (speed > 0) {
          horiz.multiplyScalar(newSpeed / speed);
          velocity.x = horiz.x; velocity.z = horiz.y;
        }
      }

      // Speed cap
      {
        const horiz = new THREE.Vector2(velocity.x, velocity.z);
        const speed = horiz.length();
        if (speed > maxSpeed) {
          horiz.multiplyScalar(maxSpeed / speed);
          velocity.x = horiz.x; velocity.z = horiz.y;
        }
      }

      // Gravity/integration
      velocity.y -= gravity * dt;
      player.position.addScaledVector(velocity, dt);

      // Ground collision
      const groundY = playerRadius + 0.3;
      if (player.position.y < groundY) { player.position.y = groundY; velocity.y = 0; onGround = true; }
      else onGround = false;

      // Camera modes (no roll)
      if (cameraMode === 'first') {
        camera.position.set(player.position.x, player.position.y + 1.1, player.position.z);
        camera.rotation.set(0, 0, 0);
        camera.rotateX(pitch);
        camera.rotateY(yaw);
      } else {
        const camDist = 6.0, camHeight = 2.5;
        const offset = new THREE.Vector3(Math.sin(yaw) * camDist, camHeight, -Math.cos(yaw) * camDist);
        camera.position.copy(player.position).add(offset);
        camera.lookAt(player.position.x, player.position.y + 1.0, player.position.z);
      }

      // Weapon sway / attack anim
      if (!attacking) {
        weapon.rotation.x = Math.sin(now * 0.004) * 0.08;
        weapon.rotation.z = 0;
      } else {
        const t = Math.min((performance.now() - attackStart) / attackDuration, 1);
        weapon.rotation.x = -0.2;
        weapon.rotation.z = -Math.PI * 0.35 + Math.sin(t * Math.PI) * 0.5;
      }

      // Lava rise
      lava.position.y += 0.018 * dt;

      // Enemy AI, separation, damage
      const bob = Math.sin(now * 0.004) * 0.02;
      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        e.position.y = 0.45 + bob;
        const toP = new THREE.Vector3().subVectors(player.position, e.position);
        const d = toP.length();
        if (d > 0.0001) toP.normalize();
        e.position.addScaledVector(toP, e.userData.speed * dt);

        // Separation
        for (let j = i + 1; j < enemies.length; j++) {
          const f = enemies[j];
          const sep = new THREE.Vector3().subVectors(e.position, f.position);
          const sl = sep.length();
          if (sl > 0 && sl < 0.9) {
            sep.normalize();
            e.position.addScaledVector(sep, (0.9 - sl) * 0.15);
            f.position.addScaledVector(sep.multiplyScalar(-1), (0.9 - sl) * 0.15);
          }
        }

        // Damage to player if close
        if (d < 0.85) { health -= 18 * dt; if (health < 0) health = 0; }
      }

      // Lose conditions
      const feet = player.position.y - groundY;
      const lavaTop = lava.position.y + 0.15;
      if (feet <= lavaTop || health <= 0) {
        running = false;
        msgText.textContent = 'Game Over — the lava monkeys got you!';
        msg.style.display = 'block';
      }

      // HUD
      timerEl.textContent = ((performance.now() - startTime) / 1000).toFixed(1);
      hpEl.textContent = Math.round(health);
    }

    // Resize and gestures
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());
  </script>
</body>
</html>
