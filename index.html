<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D PvE Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #0b0e12; overflow: hidden; font-family: system-ui, Arial, sans-serif; }
    #hud {
      position: fixed; top: 0; left: 0; right: 0; padding: 10px 16px;
      color: #e6edf3; font-weight: 600; font-size: 14px; display: flex; justify-content: space-between;
      mix-blend-mode: difference; pointer-events: none;
    }
    #centerMsg {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #e6edf3;
      text-align: center; font-size: 20px; font-weight: 700; letter-spacing: 0.5px;
    }
    #crosshair {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
      width: 16px; height: 16px; pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
      content: ""; position: absolute; background: #e6edf3;
    }
    #crosshair::before { left: 7px; top: 0; width: 2px; height: 16px; }
    #crosshair::after { top: 7px; left: 0; height: 2px; width: 16px; }
    #overlay {
      position: fixed; inset: 0; display: grid; place-items: center; background: rgba(5,7,10,0.6);
      color: #e6edf3; text-align: center;
    }
    #overlay button {
      background: #1f6feb; border: none; color: white; padding: 12px 16px; border-radius: 8px;
      font-weight: 700; cursor: pointer;
    }
    #log {
      position: fixed; bottom: 12px; left: 12px; width: 360px; max-width: calc(100% - 24px);
      color: #9fb5d1; font-size: 12px; white-space: pre-wrap; pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="statsLeft">HP: 100 | Shield: 0</div>
    <div id="statsRight">Ammo: 30/90 | Wave: 1 | Enemies: 0</div>
  </div>
  <div id="centerMsg"></div>
  <div id="crosshair"></div>

  <div id="overlay">
    <div>
      <h1>3D PvE Shooter</h1>
      <p>WASD to move, Mouse to aim, Left click to shoot, R to reload, Shift to sprint, Space to jump.</p>
      <button id="startBtn">Click to play</button>
    </div>
  </div>
  <div id="log"></div>

  <!-- Three.js and controls -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // Basic game state
    const state = {
      hp: 100,
      shield: 0,
      ammoInMag: 30,
      magSize: 30,
      reserveAmmo: 90,
      wave: 1,
      enemiesAlive: 0,
      maxWaves: 10,
      playing: false,
      sprinting: false,
      reloading: false,
      time: 0,
      score: 0,
    };

    // DOM refs
    const hudLeft = document.getElementById('statsLeft');
    const hudRight = document.getElementById('statsRight');
    const centerMsg = document.getElementById('centerMsg');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const logEl = document.getElementById('log');

    // Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e12);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);
    camera.position.set(0, 1.7, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Audio
    const audioListener = new THREE.AudioListener();
    camera.add(audioListener);
    const sfx = {
      shoot: new THREE.Audio(audioListener),
      hit: new THREE.Audio(audioListener),
      hurt: new THREE.Audio(audioListener),
      pickup: new THREE.Audio(audioListener),
      reload: new THREE.Audio(audioListener),
      wave: new THREE.Audio(audioListener),
    };
    function makeBeep(audio, freq = 440, duration = 0.08, type = 'square', volume = 0.2){
      const ctx = audioListener.context;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;
      osc.connect(gain).connect(audioListener.getInput());
      osc.start();
      osc.stop(ctx.currentTime + duration);
    }
    function sfxShoot(){ makeBeep(sfx.shoot, 880, 0.06, 'square', 0.15); }
    function sfxHit(){ makeBeep(sfx.hit, 220, 0.04, 'sawtooth', 0.15); }
    function sfxHurt(){ makeBeep(sfx.hurt, 160, 0.15, 'sine', 0.3); }
    function sfxPickup(){ makeBeep(sfx.pickup, 1200, 0.08, 'triangle', 0.2); }
    function sfxReload(){ makeBeep(sfx.reload, 600, 0.2, 'square', 0.15); }
    function sfxWave(){ makeBeep(sfx.wave, 300, 0.4, 'triangle', 0.25); }

    // Lighting
    const hemi = new THREE.HemisphereLight(0xddeeff, 0x0a0a0a, 0.4);
    scene.add(hemi);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(20, 30, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Arena
    const arena = new THREE.Group();
    scene.add(arena);

    const floorGeo = new THREE.PlaneGeometry(200, 200);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a2433, roughness: 1, metalness: 0 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    arena.add(floor);

    // Walls (simple boundaries)
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x0f1722, roughness: 0.9 });
    function makeWall(x, z, w, h) {
      const geo = new THREE.BoxGeometry(w, h, 2);
      const m = new THREE.Mesh(geo, wallMat);
      m.position.set(x, h/2, z);
      m.castShadow = true;
      m.receiveShadow = true;
      arena.add(m);
    }
    makeWall(0, -100, 200, 8);
    makeWall(0, 100, 200, 8);
    makeWall(-100, 0, 2, 8);
    makeWall(100, 0, 2, 8);

    // Some cover blocks
    const coverMat = new THREE.MeshStandardMaterial({ color: 0x233040, roughness: 0.7 });
    for (let i = 0; i < 24; i++) {
      const geo = new THREE.BoxGeometry(6 + Math.random()*6, 3 + Math.random()*4, 6 + Math.random()*6);
      const m = new THREE.Mesh(geo, coverMat);
      m.position.set((Math.random() - 0.5) * 160, geo.parameters.height / 2, (Math.random() - 0.5) * 160);
      m.castShadow = true;
      m.receiveShadow = true;
      arena.add(m);
    }

    // Pointer lock controls
    const controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    // Movement
    const keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') state.sprinting = true;
      if (e.code === 'KeyR') tryReload();
      if (!state.playing && (e.code === 'Enter' || e.code === 'Space')) startFromOverlay();
    });
    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') state.sprinting = false;
    });

    // Physics-lite
    let velocity = new THREE.Vector3();
    let onGround = false;

    function movePlayer(delta) {
      const speed = state.sprinting ? 9 : 6;
      const friction = onGround ? 8 : 1;
      const accel = onGround ? 55 : 15;

      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();

      const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

      let wishdir = new THREE.Vector3();
      if (keys['KeyW']) wishdir.add(forward);
      if (keys['KeyS']) wishdir.add(forward.clone().multiplyScalar(-1));
      if (keys['KeyA']) wishdir.add(right.clone().multiplyScalar(-1));
      if (keys['KeyD']) wishdir.add(right);

      wishdir.normalize();

      const wishspeed = speed;
      const addSpeed = wishspeed - velocity.dot(wishdir);
      const accelspeed = Math.min(accel * delta * wishspeed, addSpeed);
      velocity.add(wishdir.multiplyScalar(accelspeed));

      // Gravity
      velocity.y -= 24 * delta;

      // Jump
      if (keys['Space'] && onGround) {
        velocity.y = 9;
        onGround = false;
      }

      // Apply
      const obj = controls.getObject();
      obj.position.addScaledVector(velocity, delta);

      // Ground check (simple ray)
      const ray = new THREE.Raycaster(obj.position, new THREE.Vector3(0,-1,0), 0, 1.8);
      const hits = ray.intersectObject(floor, true);
      if (hits.length > 0) {
        onGround = true;
        obj.position.y = Math.max(obj.position.y, hits[0].point.y + 1.7);
        velocity.y = Math.max(velocity.y, -2);
      } else {
        onGround = false;
      }

      // Friction
      const horizVel = new THREE.Vector3(velocity.x, 0, velocity.z);
      const drop = friction * delta;
      const newSpeed = Math.max(0, horizVel.length() - drop);
      if (horizVel.length() > 0) {
        horizVel.normalize().multiplyScalar(newSpeed);
        velocity.x = horizVel.x; velocity.z = horizVel.z;
      }

      // Boundary clamp
      obj.position.x = THREE.MathUtils.clamp(obj.position.x, -95, 95);
      obj.position.z = THREE.MathUtils.clamp(obj.position.z, -95, 95);
    }

    // Shooting and pointer lock
    window.addEventListener('mousedown', (e) => {
      if (!controls.isLocked && state.playing) {
        controls.lock();   // lock pointer after a user click
        centerMsg.textContent = '';
        return;
      }
      if (e.button === 0) shoot();
    });

    const impactMat = new THREE.MeshBasicMaterial({ color: 0xff3355 });
    function makeImpactPoint(pos){
      const g = new THREE.SphereGeometry(0.08, 8, 8);
      const m = new THREE.Mesh(g, impactMat);
      m.position.copy(pos);
      scene.add(m);
      setTimeout(() => { scene.remove(m); }, 300);
    }

    function shoot(){
      if (!state.playing || state.reloading) return;
      if (state.ammoInMag <= 0) { tryReload(); return; }
      state.ammoInMag--;
      sfxShoot();

      // Hitscan ray
      const origin = controls.getObject().position.clone();
      origin.y += 0.1;
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      const ray = new THREE.Ray(origin, dir);
      const maxDist = 120;

      // Check enemies
      let closestHit = null;
      let closestEnemy = null;
      enemies.forEach(e => {
        if (!e.alive) return;
        const box = new THREE.Box3().setFromObject(e.mesh);
        const hit = ray.intersectBox(box, new THREE.Vector3());
        if (hit) {
          const dist = hit.distanceTo(origin);
          if (dist <= maxDist && (!closestHit || dist < closestHit.distanceTo(origin))) {
            closestHit = hit.clone();
            closestEnemy = e;
          }
        }
      });

      if (closestHit && closestEnemy) {
        makeImpactPoint(closestHit);
        damageEnemy(closestEnemy, 25);
        sfxHit();
      } else {
        // If no enemy hit, mark impact vs arena
        const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
        const impact = new THREE.Vector3();
        ray.intersectPlane(plane, impact);
        const dist = impact.distanceTo(origin);
        if (dist > 0 && dist < maxDist) makeImpactPoint(impact);
      }

      updateHUD();
    }

    function tryReload(){
      if (state.reloading) return;
      if (state.ammoInMag >= state.magSize) return;
      if (state.reserveAmmo <= 0) return;

      state.reloading = true;
      sfxReload();
      setTimeout(() => {
        const needed = state.magSize - state.ammoInMag;
        const take = Math.min(needed, state.reserveAmmo);
        state.ammoInMag += take;
        state.reserveAmmo -= take;
        state.reloading = false;
        updateHUD();
      }, 900);
    }

    // Enemies
    const enemies = [];
    const enemyMat = new THREE.MeshStandardMaterial({ color: 0xb71c1c, roughness: 0.6, metalness: 0.1 });

    function spawnEnemy(){
      const geo = new THREE.CapsuleGeometry(0.5, 1.0, 8, 16);
      const mesh = new THREE.Mesh(geo, enemyMat);
      mesh.castShadow = true; mesh.receiveShadow = true;

      // Spawn at ring boundary away from player
      const angle = Math.random() * Math.PI * 2;
      const radius = 80 + Math.random() * 20;
      const px = Math.cos(angle) * radius;
      const pz = Math.sin(angle) * radius;

      mesh.position.set(px, 1.5, pz);
      scene.add(mesh);

      const enemy = {
        mesh,
        speed: 2.2 + Math.random() * 1.0,
        hp: 50 + Math.floor(Math.random() * 20) + Math.floor(state.wave * 3),
        alive: true,
        damage: 8 + Math.floor(state.wave * 1.2),
        attackCooldown: 0,
        knockback: new THREE.Vector3(),
      };
      enemies.push(enemy);
      state.enemiesAlive++;
      updateHUD();
    }

    function damageEnemy(e, dmg){
      if (!e.alive) return;
      e.hp -= dmg;
      e.knockback.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.6));
      if (e.hp <= 0) {
        e.alive = false;
        scene.remove(e.mesh);
        state.enemiesAlive--;
        state.score += 5;
        dropPickup(e.mesh.position);
        updateHUD();
      }
    }

    function updateEnemies(delta){
      const playerPos = controls.getObject().position;

      enemies.forEach(e => {
        if (!e.alive) return;

        // Simple seek behavior
        const dir = playerPos.clone().sub(e.mesh.position);
        dir.y = 0;
        const dist = dir.length();

        // knockback decay
        e.knockback.multiplyScalar(0.9);

        if (dist > 1.2) {
          dir.normalize();
          e.mesh.position.addScaledVector(dir, e.speed * delta);
          e.mesh.position.addScaledVector(e.knockback, delta);
        } else {
          // Attack with cooldown
          e.attackCooldown -= delta;
          if (e.attackCooldown <= 0) {
            applyDamageToPlayer(e.damage);
            e.attackCooldown = 1.0;
          }
        }

        // Slight bobbing
        e.mesh.position.y = 1.5 + Math.sin(state.time * 2 + e.mesh.position.x * 0.1) * 0.05;
      });
    }

    function applyDamageToPlayer(dmg){
      if (state.shield > 0) {
        const absorbed = Math.min(dmg, state.shield);
        state.shield -= absorbed;
        dmg -= absorbed;
      }
      if (dmg > 0) {
        state.hp -= dmg;
        sfxHurt();
      }
      if (state.hp <= 0) gameOver();
      updateHUD();
      flashCenter(`-${dmg}`);
    }

    // Pickups (ammo / health / shield)
    const pickupMatAmmo = new THREE.MeshStandardMaterial({ color: 0x1f6feb, emissive: 0x0c2a6e, metalness: 0.2 });
    const pickupMatHeal = new THREE.MeshStandardMaterial({ color: 0x2ea043, emissive: 0x145522, metalness: 0.2 });
    const pickupMatShield = new THREE.MeshStandardMaterial({ color: 0x9c27b0, emissive: 0x4a148c, metalness: 0.2 });

    function dropPickup(pos){
      const typeRoll = Math.random();
      let mat = pickupMatAmmo, kind = 'ammo';
      if (typeRoll < 0.33) { mat = pickupMatAmmo; kind = 'ammo'; }
      else if (typeRoll < 0.66) { mat = pickupMatHeal; kind = 'heal'; }
      else { mat = pickupMatShield; kind = 'shield'; }

      const geo = new THREE.IcosahedronGeometry(0.6, 0);
      const m = new THREE.Mesh(geo, mat);
      m.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*2, 0.5, (Math.random()-0.5)*2));
      m.castShadow = true; m.receiveShadow = true;
      m.userData.kind = kind;
      scene.add(m);

      // auto-despawn
      setTimeout(() => scene.remove(m), 15000);
      pickups.push(m);
    }

    const pickups = [];
    function updatePickups(delta){
      const playerPos = controls.getObject().position;
      pickups.forEach((p) => {
        if (!p.parent) return;
        p.rotation.y += delta;
        const dist = p.position.distanceTo(playerPos);
        if (dist < 2.0) {
          if (p.userData.kind === 'ammo') {
            state.reserveAmmo = Math.min(240, state.reserveAmmo + 30);
          } else if (p.userData.kind === 'heal') {
            state.hp = Math.min(100, state.hp + 20);
          } else if (p.userData.kind === 'shield') {
            state.shield = Math.min(100, state.shield + 25);
          }
          sfxPickup();
          scene.remove(p);
          updateHUD();
        }
      });
    }

    // Waves
    let nextSpawnTimer = 0;
    let inIntermission = true;
    let intermissionTimer = 0;

    function startWave(){
      sfxWave();
      inIntermission = false;
      nextSpawnTimer = 0;
      centerMsg.textContent = `Wave ${state.wave}`;
      setTimeout(()=> centerMsg.textContent = '', 1500);
    }

    function updateWave(delta){
      if (inIntermission) {
        intermissionTimer -= delta;
        if (intermissionTimer <= 0) startWave();
        return;
      }

      // spawn logic
      nextSpawnTimer -= delta;
      if (nextSpawnTimer <= 0) {
        const batch = Math.min(3 + Math.floor(state.wave * 0.8), 8);
        for (let i = 0; i < batch; i++) spawnEnemy();
        nextSpawnTimer = 3.5;
      }

      // end when all enemies gone
      if (state.enemiesAlive <= 0 && enemies.filter(e => e.alive).length === 0) {
        inIntermission = true;
        state.wave++;
        if (state.wave > state.maxWaves) return gameWin();
        intermissionTimer = 4.0;
        centerMsg.textContent = `Intermission: Wave ${state.wave} in ${intermissionTimer.toFixed(0)}s`;
      }
    }

    // HUD
    function updateHUD(){
      hudLeft.textContent = `HP: ${Math.max(0, state.hp)} | Shield: ${state.shield}`;
      hudRight.textContent = `Ammo: ${state.ammoInMag}/${state.reserveAmmo} | Wave: ${state.wave} | Enemies: ${state.enemiesAlive}`;
    }

    function flashCenter(text){
      centerMsg.textContent = text;
      setTimeout(() => { if (centerMsg.textContent === text) centerMsg.textContent = ''; }, 600);
    }

    function log(msg){
      logEl.textContent = msg;
      setTimeout(() => { if (logEl.textContent === msg) logEl.textContent = ''; }, 2000);
    }

    // Start logic (fixed)
    function startFromOverlay(){
      overlay.style.display = 'none';
      startGame();
      centerMsg.textContent = 'Click to lock mouse';
    }

    startBtn.addEventListener('click', () => {
      startFromOverlay();
    });

    function startGame(){
      state.playing = true;
      state.hp = 100;
      state.shield = 0;
      state.ammoInMag = 30;
      state.reserveAmmo = 90;
      state.wave = 1;
      state.score = 0;
      enemies.splice(0, enemies.length);
      pickups.splice(0, pickups.length);
      nextSpawnTimer = 0;
      inIntermission = true;
      intermissionTimer = 2.0;
      updateHUD();
    }

    function gameOver(){
      state.playing = false;
      overlay.style.display = 'grid';
      overlay.querySelector('h1').textContent = 'You died';
      overlay.querySelector('p').textContent = `Score: ${state.score} | Wave reached: ${state.wave}`;
      startBtn.textContent = 'Play again';
    }

    function gameWin(){
      state.playing = false;
      overlay.style.display = 'grid';
      overlay.querySelector('h1').textContent = 'Victory!';
      overlay.querySelector('p').textContent = `Score: ${state.score} | Waves cleared: ${state.maxWaves}`;
      startBtn.textContent = 'Play again';
    }

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Main loop
    let lastTime = performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      const delta = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      state.time += delta;

      if (state.playing) {
        movePlayer(delta);
        updateEnemies(delta);
        updatePickups(delta);
        updateWave(delta);
      }

      renderer.render(scene, camera);
    }
    animate(performance.now());

    // Help text
    log('Tip: If clicking doesnâ€™t lock the mouse, run on a local server (e.g., VS Code Live Server).');
  </script>
</body>
</html>
