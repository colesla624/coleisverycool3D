<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>3D Mobile Platformer — Optimized</title>
<style>
  html, body { margin:0; height:100%; background:#0c1326; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #game { position:fixed; inset:0; }

  #hud { position: fixed; left: 0; right: 0; top: 0; display: flex; gap: 8px; justify-content: space-between; padding: 10px; pointer-events: none; color:#e6e6e6; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
  .panel { background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 12px; }
  #msg { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; color:#fff; background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.15); border-radius: 10px; padding:8px 12px; pointer-events:none; }

  #controls { position: fixed; inset: 0; pointer-events: none; }
  .stick-wrap { position: absolute; width: 160px; height: 160px; pointer-events: auto; touch-action: none; }
  .stick-base, .stick-thumb { position: absolute; border-radius: 50%; }
  .stick-base { width: 160px; height: 160px; background: rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.18); backdrop-filter: blur(4px); }
  .stick-thumb { width: 80px; height: 80px; left: 40px; top: 40px; background: rgba(255,255,255,0.22); border:2px solid rgba(255,255,255,0.3); }
  .btn { position: absolute; right: 24px; bottom: 120px; width: 100px; height: 100px; border-radius: 50%; pointer-events: auto; touch-action: manipulation;
    background: radial-gradient(circle at 30% 30%, #fff 0%, #f6b73c 35%, #e36c1b 60%, #ad3a0a 100%);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 10px rgba(255,255,255,0.4); border: 2px solid rgba(255,255,255,0.5); }
  .btn:active { transform: scale(0.96); }

  #menu { position: fixed; left: 50%; transform: translateX(-50%); bottom: 70px; display: flex; flex-wrap: wrap; gap: 8px; pointer-events: auto; }
  #menu select, #menu button, #menu input {
    padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.35); color:#e6e6e6; backdrop-filter: blur(3px);
  }

  #pauseOverlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); color:#fff; font-size: 20px; font-weight:700; text-align:center; }
  #pauseOverlay .inner { background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.2); padding: 14px 18px; border-radius: 10px; }

  #mainMenu { position: fixed; inset: 0; display: none; background: rgba(0,0,0,0.7); color: #e6e6e6; }
  #mainMenu .wrap { position: absolute; left:50%; top:50%; transform: translate(-50%,-50%); width: min(820px, 92vw); max-height: 80vh; overflow:auto;
    background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 16px; }
  #mainMenu h2 { margin: 0 0 10px; font-weight: 700; }
  .tabs { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
  .tab { padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); cursor: pointer; }
  .tab.active { background: rgba(255,255,255,0.18); }
  .tabpane { display: none; }
  .tabpane.active { display: block; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; }
  .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 10px; }
  .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
  .swatch { width: 26px; height: 26px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.4); cursor: pointer; }
  .closeMenu { position: absolute; right: 12px; top: 12px; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="panel" id="score">Coins: 0 / 0</div>
  <div class="panel" id="level">Level</div>
  <div class="panel" id="mode">Mode: Classic</div>
  <div class="panel" id="timer" style="display:none;">Time: 60.0s</div>
  <div class="panel" id="lives" style="display:none;">Lives: 3</div>
</div>
<div id="msg">Explore and reach the glowing goal!</div>

<div id="controls">
  <div class="stick-wrap" id="moveStick" style="left:24px; bottom:24px;">
    <div class="stick-base"></div>
    <div class="stick-thumb" id="moveThumb"></div>
  </div>
  <button class="btn" id="jumpBtn" aria-label="Jump"></button>
</div>

<div id="menu">
  <select id="sceneSelect"></select>
  <select id="levelSelect"></select>
  <select id="modeSelect">
    <option value="classic">Classic</option>
    <option value="time">Time Attack</option>
    <option value="survival">Survival</option>
    <option value="lavaTower">Lava Rising Tower</option>
    <option value="monkeyChase">Monkey Chase</option>
    <option value="coinCollector">Coin Collector</option>
    <option value="vanishPlatforms">Vanish Platforms</option>
    <option value="fogMaze">Fog Maze</option>
    <option value="speedRun">Speed Run</option>
    <option value="lowGravity">Low Gravity</option>
  </select>
  <button id="restartBtn">Restart</button>
  <button id="pauseBtn">Pause</button>
  <button id="toggleViewBtn">Toggle View</button>
  <button id="openMenuBtn">Main Menu</button>
  <input id="codeInput" placeholder="Enter code" />
  <button id="codeApplyBtn">Apply</button>
</div>

<div id="pauseOverlay"><div class="inner">Paused<br/><small>(Tap or press P to resume)</small></div></div>

<div id="mainMenu">
  <div class="wrap">
    <button class="closeMenu" id="closeMenuBtn">Close</button>
    <h2>Main menu</h2>
    <div class="tabs">
      <div class="tab active" data-tab="levelsTab">Levels</div>
      <div class="tab" data-tab="customTab">Customize</div>
      <div class="tab" data-tab="optionsTab">Options</div>
    </div>
    <div id="levelsTab" class="tabpane active">
      <div class="grid" id="levelsGrid"></div>
    </div>
    <div id="customTab" class="tabpane">
      <div class="card">
        <h3>Character customization</h3>
        <div class="row">
          <div>Color:</div>
          <div class="swatch" data-color="#f0f3f8" style="background:#f0f3f8"></div>
          <div class="swatch" data-color="#ff9aa2" style="background:#ff9aa2"></div>
          <div class="swatch" data-color="#9ad1ff" style="background:#9ad1ff"></div>
          <div class="swatch" data-color="#a3ffb0" style="background:#a3ffb0"></div>
          <div class="swatch" data-color="#ffd54f" style="background:#ffd54f"></div>
        </div>
        <div class="row">
          <label><input type="checkbox" id="hatToggle"/> Hat accessory</label>
          <label><input type="checkbox" id="trailToggle"/> Sparkle trail</label>
        </div>
      </div>
    </div>
    <div id="optionsTab" class="tabpane">
      <div class="card">
        <h3>Gameplay</h3>
        <div class="row">
          <label><input type="checkbox" id="doubleJumpToggle" checked/> Enable double jump</label>
        </div>
        <div class="row">
          <label>Camera sensitivity
            <input type="range" id="camSens" min="1.0" max="6.0" step="0.1" value="3.5"/>
          </label>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
<script>
(() => {
  const canvas = document.getElementById('game');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0c1326);
  scene.fog = new THREE.Fog(0x0c1326, 50, 140);

  const camera = new THREE.PerspectiveCamera(62, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 10);

  const hemi = new THREE.HemisphereLight(0x9bd4ff, 0x12131a, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xfff1e4, 1.0);
  sun.position.set(12, 16, 10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024, 1024); // reduced for performance
  scene.add(sun);

  const groundMat = new THREE.MeshStandardMaterial({ color: 0x182235, roughness: 0.95 });
  const ground = new THREE.Mesh(new THREE.CircleGeometry(80, 32), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Ambient pillars simplified
  const pillarMat = new THREE.MeshStandardMaterial({ color: 0x283b5e, roughness: 0.8 });
  for (let i=0;i<8;i++){
    const h = 2 + Math.random()*4;
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,h,16), pillarMat);
    const r = 45 + Math.random()*20, a = Math.random()*Math.PI*2;
    p.position.set(Math.cos(a)*r, h/2, Math.sin(a)*r);
    p.castShadow = true; p.receiveShadow = true;
    scene.add(p);
  }

  const THEMES = {
    forest: { platform: mat(0x2b5c4b), platformAlt: mat(0x3a2b5c), sky:0x0c1326, fog:[50,140], sun:0xfff1e4, hemiTop:0x9bd4ff, hemiBottom:0x12131a, lamp:0xfff2b0 },
    crystal: { platform: mat(0x3dc8ff,0.4,0.6), platformAlt: mat(0x7bd8ff,0.45,0.6), sky:0x0a0f1f, fog:[40,120], sun:0xcfe7ff, hemiTop:0xbadfff, hemiBottom:0x0b1020, lamp:0xb0e1ff },
    skyisles: { platform: mat(0xe3d5a4,0.7,0.2), platformAlt: mat(0xc8b68f,0.75,0.2), sky:0x10172b, fog:[60,160], sun:0xfff9d6, hemiTop:0xfff4c7, hemiBottom:0x0f1220, lamp:0xffddaa },
    desert: { platform: mat(0xd2a679,0.85,0.1), platformAlt: mat(0xc19a6b,0.9,0.08), sky:0xffe0b3, fog:[40,120], sun:0xffd27f, hemiTop:0xfff0c2, hemiBottom:0x705030, lamp:0xffe8bb },
    lava: { platform: emissiveMat(0x802020,0x300000,0.25,0.65), platformAlt: emissiveMat(0x993333,0x400000,0.25,0.6), sky:0x1a0000, fog:[25,95], sun:0xff3300, hemiTop:0x661111, hemiBottom:0x0a0000, lamp:0xff4500 },
    ice: { platform: mat(0xa3d5ff,0.25,0.5), platformAlt: mat(0x7bbcff,0.3,0.5), sky:0xe6f7ff, fog:[50,140], sun:0xb3e5ff, hemiTop:0xdff2ff, hemiBottom:0xaad4ff, lamp:0xcfe9ff },
    neon: { platform: emissiveMat(0x2b2b2b,0x00e5ff,0.35,0.3), platformAlt: emissiveMat(0x2b2b2b,0xff00aa,0.35,0.3), sky:0x0a0a12, fog:[40,130], sun:0x99f0ff, hemiTop:0x44ffee, hemiBottom:0x00141a, lamp:0x88ffee },
    ocean: { platform: mat(0x2e6f8e,0.8,0.0), platformAlt: mat(0x1b4e66,0.85,0.0), sky:0x0c1f2b, fog:[45,135], sun:0xb0e4ff, hemiTop:0x78c7ff, hemiBottom:0x072231, lamp:0x9ad8ff },
    garden: { platform: mat(0x5aa35a,0.8,0.0), platformAlt: mat(0x3f803f,0.85,0.0), sky:0x122012, fog:[50,150], sun:0xfff7cf, hemiTop:0xcde8a7, hemiBottom:0x0a170a, lamp:0xeaffc7 }
  };
  function mat(colorHex, rough=0.78, metal=0.12){ return new THREE.MeshStandardMaterial({ color: colorHex, roughness: rough, metalness: metal }); }
  function emissiveMat(colorHex, emHex, emInt=0.3, rough=0.6){ return new THREE.MeshStandardMaterial({ color: colorHex, emissive: emHex, emissiveIntensity: emInt, roughness: rough }); }

  const matGoal = new THREE.MeshStandardMaterial({ color: 0x5ce1e6, emissive: 0x29d5da, emissiveIntensity: 0.8, roughness: 0.5, metalness: 0.4 });

  const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.85, roughness: 0.25, emissive: 0xffa500, emissiveIntensity: 0.2 });

  // Player + cosmetics
  const playerRadius = 0.5;
  const playerHeight = 1.2;
  let playerColor = 0xf0f3f8;
  const matPlayer = new THREE.MeshStandardMaterial({ color: playerColor, roughness: 0.35, metalness: 0.22, emissive: 0x141414, emissiveIntensity: 0.25 });
  const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, playerHeight, 8, 16), matPlayer);
  player.castShadow = true;
  scene.add(player);

  let ownerSprite = null;
  let ownerUnlocked = false;
  const hat = new THREE.Mesh(new THREE.ConeGeometry(0.45, 0.6, 12), new THREE.MeshStandardMaterial({ color: 0xff6f61, roughness: 0.5 }));
  hat.rotation.x = Math.PI; hat.visible = false; scene.add(hat);
  const trail = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.05, 8, 20), new THREE.MeshStandardMaterial({ color: 0x88aaff, emissive: 0x88aaff, emissiveIntensity: 0.6 }));
  trail.visible = false; scene.add(trail);

  function makeOwnerSprite() {
    const c = document.createElement('canvas');
    c.width = 256; c.height = 128;
    const ctx = c.getContext('2d');
    ctx.font = 'bold 64px system-ui';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff2b2b'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 6;
    ctx.strokeText('OWNER', c.width/2, c.height/2); ctx.fillText('OWNER', c.width/2, c.height/2);
    const tex = new THREE.CanvasTexture(c);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
    sprite.scale.set(2.8, 1.4, 1);
    scene.add(sprite);
    return sprite;
  }

  // Camera (snap)
  let cameraMode = 'third';
  let camYaw = 0;
  let camPitch = 0.25;
  const pitchMin = -0.3, pitchMax = 0.85;
  let camSensitivity = 3.5;
  const orbitRadius = 8.5;

  // Procedural scenes with difficulty ramp
  function createSceneLevels(count, themeKey) {
    const levels = [];
    for (let i=1; i<=count; i++) {
      const difficulty = i - 1;
      const baseW = 20 - Math.min(8, Math.floor(difficulty/2));
      const baseD = 20 - Math.min(6, Math.floor(difficulty/3));
      const steps = 5 + Math.floor(difficulty/3);
      const gapBase = 6 + Math.floor(difficulty/2);

      const platforms = [{ x:0, y:0, z:0, w:baseW, d:baseD, alt:false }];
      for (let s=1; s<=steps; s++) {
        const alt = s % 2 === 0;
        const x = ((difficulty + s) % 2 === 0 ? s*(3 + Math.floor(difficulty/4)) : -s*(3 + Math.floor(difficulty/4)));
        const y = s * (1.8 + Math.min(1.5, difficulty * 0.08));
        const z = -s * (gapBase + (s % 3));
        const w = Math.max(3, 4 - Math.floor(difficulty/5)) + (s % 2 ? 0 : -1);
        const d = Math.max(3, 4 - Math.floor(difficulty/6));
        platforms.push({ x, y, z, w, d, alt });
      }

      const coinSpots = platforms.slice(1, Math.min(platforms.length, 10)).map(p => [p.x + ((Math.random()-0.5)*1.2), p.y + 1.3, p.z + ((Math.random()-0.5)*1.2)]);
      const goalP = platforms[platforms.length - 1];
      const goal = [goalP.x, goalP.y + 1.5, goalP.z];
      const spawn = [0, 2.5, 6];
      levels.push({ name: `Level ${i}`, platforms, coins: coinSpots, goal, spawn, theme: themeKey });
    }
    return levels;
  }

  const SCENES = [
    { name: "Forest Realm", theme: 'forest', levels: createSceneLevels(20, 'forest') },
    { name: "Crystal Caverns", theme: 'crystal', levels: createSceneLevels(20, 'crystal') },
    { name: "Sky Isles", theme: 'skyisles', levels: createSceneLevels(20, 'skyisles') },
    { name: "Desert Dunes", theme: 'desert', levels: createSceneLevels(20, 'desert') },
    { name: "Molten Core", theme: 'lava', levels: createSceneLevels(20, 'lava') },
    { name: "Frozen Wastes", theme: 'ice', levels: createSceneLevels(20, 'ice') },
    { name: "Neon City", theme: 'neon', levels: createSceneLevels(20, 'neon') },
    { name: "Ocean Ruins", theme: 'ocean', levels: createSceneLevels(20, 'ocean') },
    { name: "Midnight Garden", theme: 'garden', levels: createSceneLevels(20, 'garden') }
  ];

  // Containers
  let platforms = [];
  let coins = [];
  let lights = [];
  let goal = null;
  let lava = null;
  let monkeys = [];

  // HUD and menu
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const modeEl = document.getElementById('mode');
  const timerEl = document.getElementById('timer');
  const livesEl = document.getElementById('lives');
  const msgEl = document.getElementById('msg');

  const sceneSelect = document.getElementById('sceneSelect');
  const levelSelect = document.getElementById('levelSelect');
  const modeSelect = document.getElementById('modeSelect');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const toggleViewBtn = document.getElementById('toggleViewBtn');
  const openMenuBtn = document.getElementById('openMenuBtn');
  const codeInput = document.getElementById('codeInput');
  const codeApplyBtn = document.getElementById('codeApplyBtn');

  const mainMenu = document.getElementById('mainMenu');
  const closeMenuBtn = document.getElementById('closeMenuBtn');
  const tabs = Array.from(document.querySelectorAll('.tab'));
  const panes = {
    levelsTab: document.getElementById('levelsTab'),
    customTab: document.getElementById('customTab'),
    optionsTab: document.getElementById('optionsTab')
  };
  const levelsGrid = document.getElementById('levelsGrid');
  const hatToggle = document.getElementById('hatToggle');
  const trailToggle = document.getElementById('trailToggle');
  const doubleJumpToggle = document.getElementById('doubleJumpToggle');
  const camSensInput = document.getElementById('camSens');

  // Populate scene + levels UI
  SCENES.forEach((s, si) => {
    const opt = document.createElement('option');
    opt.value = si; opt.textContent = `${si+1}. ${s.name}`;
    sceneSelect.appendChild(opt);
  });
  function populateLevelsDropdown(sceneIndex) {
    levelSelect.innerHTML = '';
    const lvls = SCENES[sceneIndex].levels;
    lvls.forEach((l, li) => {
      const opt = document.createElement('option');
      opt.value = li; opt.textContent = l.name;
      levelSelect.appendChild(opt);
    });
    levelsGrid.innerHTML = '';
    lvls.forEach((l, li) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<strong>${SCENES[sceneIndex].name}</strong><br/>${l.name}<br/><button data-scene="${sceneIndex}" data-level="${li}">Play</button>`;
      levelsGrid.appendChild(card);
    });
  }
  sceneSelect.value = '0';
  populateLevelsDropdown(0);
  levelsGrid.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-level]');
    if (!btn) return;
    const si = parseInt(btn.getAttribute('data-scene'), 10);
    const li = parseInt(btn.getAttribute('data-level'), 10);
    loadLevel(si, li);
    mainMenu.style.display = 'none';
  });

  sceneSelect.addEventListener('change', (e) => {
    const si = parseInt(e.target.value, 10);
    populateLevelsDropdown(si);
    loadLevel(si, 0);
  });
  levelSelect.addEventListener('change', (e) => {
    loadLevel(parseInt(sceneSelect.value, 10), parseInt(e.target.value, 10));
  });

  tabs.forEach(t => t.addEventListener('click', () => {
    tabs.forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    Object.values(panes).forEach(p => p.classList.remove('active'));
    panes[t.getAttribute('data-tab')].classList.add('active');
  }));

  Array.from(document.querySelectorAll('.swatch')).forEach(sw => {
    sw.addEventListener('click', () => {
      const hex = sw.getAttribute('data-color');
      playerColor = parseInt(hex.replace('#', ''), 16);
      matPlayer.color.setHex(playerColor);
    });
  });
  hatToggle.addEventListener('change', () => { hat.visible = hatToggle.checked; });
  trailToggle.addEventListener('change', () => { trail.visible = trailToggle.checked; });
  camSensInput.addEventListener('input', () => { camSensitivity = parseFloat(camSensInput.value); });
  doubleJumpToggle.addEventListener('change', (e) => { doubleJumpEnabled = e.target.checked; });

  codeApplyBtn.addEventListener('click', () => {
    if (codeInput.value.trim().toLowerCase() === 'owner222') {
      ownerUnlocked = true;
      if (!ownerSprite) ownerSprite = makeOwnerSprite();
      msgEl.textContent = 'Owner cosmetic unlocked!';
    } else {
      msgEl.textContent = 'Invalid code.';
    }
    codeInput.value = '';
  });
  codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') codeApplyBtn.click(); });

  // Game mode state
  let gameMode = 'classic';
  let timeLeft = 60.0;
  let lives = 3;

  function updateHUD() {
    scoreEl.textContent = `Coins: ${coinsCollected} / ${coins.length}`;
    levelEl.textContent = `${SCENES[currentScene].name} — ${SCENES[currentScene].levels[currentLevel].name}`;
    modeEl.textContent = `Mode: ${
      gameMode === 'classic' ? 'Classic' :
      gameMode === 'time' ? 'Time Attack' :
      gameMode === 'survival' ? 'Survival' :
      gameMode === 'lavaTower' ? 'Lava Rising Tower' :
      gameMode === 'monkeyChase' ? 'Monkey Chase' :
      gameMode === 'coinCollector' ? 'Coin Collector' :
      gameMode === 'vanishPlatforms' ? 'Vanish Platforms' :
      gameMode === 'fogMaze' ? 'Fog Maze' :
      gameMode === 'speedRun' ? 'Speed Run' : 'Low Gravity'
    }`;
    timerEl.style.display = gameMode === 'time' ? 'block' : 'none';
    livesEl.style.display = gameMode === 'survival' ? 'block' : 'none';
    if (gameMode === 'time') timerEl.textContent = `Time: ${timeLeft.toFixed(1)}s`;
    if (gameMode === 'survival') livesEl.textContent = `Lives: ${lives}`;
  }

  // Physics — tuned for responsiveness and instant stop on floor
  const velocity = new THREE.Vector3(0, 0, 0);
  const acceleration = new THREE.Vector3(0, 0, 0);
  const gravityBase = new THREE.Vector3(0, -24, 0);
  const gravity = gravityBase.clone();
  let accelGround = 16;
  let accelAir = 16;
  const friction = 8.5;
  const airControl = 0.6;
  let onGround = false;

  let jumpStrength = 13.0;
  let doubleJumpStrength = 11.0;
  let canDoubleJump = true;
  let doubleJumpEnabled = true;

  const keys = { left: false, right: false, up: false, down: false, jump: false };
  let moveDx = 0, moveDy = 0;
  let paused = false;
  const voidY = -20;
  let coinsCollected = 0;

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
    if (e.code === 'Space') keys.jump = true;
    if (e.code === 'KeyP') togglePause();
    if (e.code === 'Escape') mainMenu.style.display = 'none';
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
    if (e.code === 'Space') keys.jump = false;
  });

  // Pointer look (with deadzones)
  const moveStickEl = document.getElementById('moveStick');
  const jumpBtnEl = document.getElementById('jumpBtn');
  function inExpandedRect(e, rect, pad=80) {
    return e.clientX >= rect.left - pad && e.clientX <= rect.right + pad &&
           e.clientY >= rect.top - pad && e.clientY <= rect.bottom + pad;
  }
  let lastMouse = null;
  window.addEventListener('pointerdown', (e) => { lastMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('pointerup', () => { lastMouse = null; });
  window.addEventListener('pointermove', (e) => {
    if (!lastMouse) return;
    const moveRect = moveStickEl.getBoundingClientRect();
    const jumpRect = jumpBtnEl.getBoundingClientRect();
    if (inExpandedRect(e, moveRect, 80) || inExpandedRect(e, jumpRect, 80)) { lastMouse = { x: e.clientX, y: e.clientY }; return; }
    const dx = (e.clientX - lastMouse.x) / window.innerWidth;
    const dy = (e.clientY - lastMouse.y) / window.innerHeight;
    const jitterDeadzone = 0.02;
    if (Math.abs(dx) > jitterDeadzone) camYaw -= dx * camSensitivity;
    if (Math.abs(dy) > jitterDeadzone) {
      camPitch = THREE.MathUtils.clamp(
        camPitch + (cameraMode === 'third' ? dy * (camSensitivity * 0.66) : -dy * (camSensitivity * 0.66)),
        pitchMin, pitchMax
      );
    }
    lastMouse = { x: e.clientX, y: e.clientY };
  });

  // Virtual joystick
  function setupStick(stickId, thumbId, cb) {
    const stick = document.getElementById(stickId);
    const thumb = document.getElementById(thumbId);
    let active = false;
    const rect = () => stick.getBoundingClientRect();
    function setThumb(x, y) {
      const r = 80;
      const len = Math.hypot(x, y);
      const k = len > r ? r / len : 1;
      const tx = x * k, ty = y * k;
      thumb.style.transform = `translate(${tx}px,${ty}px)`;
      cb(tx / r, ty / r);
    }
    function reset() { thumb.style.transform = `translate(0px,0px)`; cb(0, 0); }
    stick.addEventListener('pointerdown', (e) => {
      active = true; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
      stick.setPointerCapture(e.pointerId);
    });
    stick.addEventListener('pointermove', (e) => { if (!active) return; const rc = rect(); setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2)); });
    stick.addEventListener('pointerup', () => { active = false; reset(); });
    stick.addEventListener('pointercancel', () => { active = false; reset(); });
  }
  setupStick('moveStick', 'moveThumb', (dx, dy) => { moveDx = -dx; moveDy = -dy; });

  // Jump button
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.addEventListener('pointerdown', () => keys.jump = true);
  jumpBtn.addEventListener('pointerup', () => keys.jump = false);

  // Pause/resume
  const pauseOverlay = document.getElementById('pauseOverlay');
  function togglePause() { paused = !paused; pauseOverlay.style.display = paused ? 'flex' : 'none'; }
  pauseOverlay.addEventListener('click', togglePause);
  pauseBtn.addEventListener('click', togglePause);

  // Prevent touch scrolling
  document.body.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive:false });

  // Toggle view
  toggleViewBtn.addEventListener('click', () => { cameraMode = cameraMode === 'third' ? 'first' : 'third'; player.visible = cameraMode !== 'first'; });

  // Open/close main menu
  openMenuBtn.addEventListener('click', () => { mainMenu.style.display = 'block'; });
  closeMenuBtn.addEventListener('click', () => { mainMenu.style.display = 'none'; });

  // Geometry helpers
  function makePlatform(x, y, z, w, d, alt, themeKey) {
    const theme = THEMES[themeKey] || THEMES.forest;
    const mat = alt ? theme.platformAlt : theme.platform;
    const geo = new THREE.BoxGeometry(w, 0.6, d);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true; mesh.receiveShadow = true;
    // simple rim (low segments)
    const rim = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, 0.05, d+0.2), new THREE.MeshStandardMaterial({ color: 0x1b2a45, roughness: 0.9 }));
    rim.position.set(0, 0.325, 0);
    mesh.add(rim);
    scene.add(mesh);
    platforms.push(mesh);
    return mesh;
  }
  function makeCoin(x, y, z) {
    const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16), coinMat);
    coin.rotation.x = Math.PI / 2;
    coin.position.set(x, y, z);
    coin.castShadow = false; // perf
    scene.add(coin);
    coins.push(coin);
    return coin;
  }
  function makeLamp(x, y, z, colorHex = 0xfff2b0) {
    const lamp = new THREE.PointLight(colorHex, 0.6, 12);
    lamp.position.set(x, y, z);
    lamp.castShadow = false; // perf
    scene.add(lamp);
    lights.push(lamp);
    return lamp;
  }
  function aabbSphereCollision(box, spherePos, sphereR) {
    const bPos = box.position;
    box.geometry.computeBoundingBox();
    const bb = box.geometry.boundingBox;
    const halfX = (bb.max.x - bb.min.x)/2, halfY = (bb.max.y - bb.min.y)/2, halfZ = (bb.max.z - bb.min.z)/2;
    const minX = bPos.x - halfX, minY = bPos.y - halfY, minZ = bPos.z - halfZ;
    const maxX = bPos.x + halfX, maxY = bPos.y + halfY, maxZ = bPos.z + halfZ;
    const cx = Math.max(minX, Math.min(spherePos.x, maxX));
    const cy = Math.max(minY, Math.min(spherePos.y, maxY));
    const cz = Math.max(minZ, Math.min(spherePos.z, maxZ));
    const dx = spherePos.x - cx, dy = spherePos.y - cy, dz = spherePos.z - cz;
    const dist2 = dx*dx + dy*dy + dz*dz;
    if (dist2 <= sphereR*sphereR) return new THREE.Vector3(dx, dy, dz);
    return null;
  }

  // Theme application
  function applyTheme(themeKey) {
    const theme = THEMES[themeKey] || THEMES.forest;
    scene.background = new THREE.Color(theme.sky);
    scene.fog.color = new THREE.Color(theme.sky);
    scene.fog.near = theme.fog[0];
    scene.fog.far = theme.fog[1];
    sun.color = new THREE.Color(theme.sun);
    hemi.color.setHex(theme.hemiTop);
    hemi.groundColor.setHex(theme.hemiBottom);
    ground.material.color.setHex(theme.sky);
  }

  // Level management
  let currentScene = 0;
  let currentLevel = 0;

  function clearLevel() {
    platforms.forEach(m => scene.remove(m));
    coins.forEach(c => scene.remove(c));
    lights.forEach(l => scene.remove(l));
    monkeys.forEach(m => scene.remove(m));
    if (lava) { scene.remove(lava); lava = null; }
    platforms = []; coins = []; lights = []; monkeys = [];
    if (goal) { scene.remove(goal); goal = null; }
  }

  function loadLevel(sceneIndex, levelIndex) {
    clearLevel();
    currentScene = sceneIndex;
    currentLevel = levelIndex;
    const lvl = SCENES[sceneIndex].levels[levelIndex];
    applyTheme(lvl.theme);

    lvl.platforms.forEach(p => {
      const mesh = makePlatform(p.x, p.y, p.z, p.w, p.d, p.alt, lvl.theme);
      if (Math.random() < 0.6) makeLamp(p.x, p.y + 3.0, p.z, THEMES[lvl.theme].lamp);
      mesh.userData = { vanishTimer: 0, stepped: false };
    });

    lvl.coins.forEach(([x,y,z]) => { makeCoin(x, y, z); if (Math.random()<0.5) makeLamp(x, y + 0.6, z, THEMES[lvl.theme].lamp); });

    goal = new THREE.Mesh(new THREE.TorusGeometry(1.4, 0.28, 12, 32), matGoal); // fewer segments
    goal.position.set(lvl.goal[0], lvl.goal[1], lvl.goal[2]);
    goal.castShadow = false; // perf
    scene.add(goal);

    player.position.set(lvl.spawn[0], lvl.spawn[1], lvl.spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    canDoubleJump = true;
    coinsCollected = 0;

    setupModeEnvironment();
    msgEl.textContent = 'Explore and reach the glowing goal!';
    updateHUD();
  }

  function applyMode(mode) {
    gameMode = mode;
    timeLeft = mode === 'time' ? 75.0 : 60.0;
    lives = 3;

    gravity.copy(gravityBase);
    accelGround = 16;
    accelAir = 16;
    jumpStrength = 13.0;
    doubleJumpStrength = 11.0;
    const themeFog = THEMES[SCENES[currentScene].theme].fog;
    scene.fog.near = themeFog[0]; scene.fog.far = themeFog[1];

    if (mode === 'speedRun') {
      accelGround = 22; accelAir = 22;
      jumpStrength = 14.0; doubleJumpStrength = 12.0;
      timeLeft = 60.0;
    } else if (mode === 'lowGravity') {
      gravity.set(0, -12, 0);
      jumpStrength = 15.0; doubleJumpStrength = 13.0;
    } else if (mode === 'fogMaze') {
      scene.fog.near = 10; scene.fog.far = 60;
    }

    setupModeEnvironment();
    updateHUD();
  }

  modeSelect.addEventListener('change', (e) => applyMode(e.target.value));
  restartBtn.addEventListener('click', () => loadLevel(currentScene, currentLevel));

  // Mode environment setup
  let lavaHeight = -50;
  function setupModeEnvironment() {
    if (lava) { scene.remove(lava); lava = null; }
    monkeys.forEach(m => scene.remove(m)); monkeys = [];

    if (gameMode === 'lavaTower') {
      lavaHeight = SCENES[currentScene].levels[currentLevel].spawn[1] - 20;
      const lavaGeo = new THREE.PlaneGeometry(200, 200);
      const lavaMat = new THREE.MeshStandardMaterial({ color: 0xff3b1f, emissive: 0x9c1c0f, emissiveIntensity: 0.7, roughness: 0.6, metalness: 0.0, side: THREE.DoubleSide });
      lava = new THREE.Mesh(lavaGeo, lavaMat);
      lava.rotation.x = -Math.PI / 2;
      lava.position.set(0, lavaHeight, 0);
      lava.receiveShadow = false;
      scene.add(lava);
    }

    if (gameMode === 'monkeyChase') spawnMonkeys(3);
  }

  function spawnMonkeys(count = 2) {
    const monkeyMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.6 });
    for (let i=0;i<count;i++) {
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), monkeyMat); // fewer segments
      const lvl = SCENES[currentScene].levels[currentLevel];
      const start = lvl.platforms[Math.min(lvl.platforms.length-1, 1+i)];
      m.position.set(start.x + (Math.random()-0.5)*4, start.y + 1.0, start.z + (Math.random()-0.5)*4);
      m.castShadow = false;
      scene.add(m);
      monkeys.push(m);
    }
  }

  // Respawn
  function respawn(penalize = true) {
    const spawn = SCENES[currentScene].levels[currentLevel].spawn;
    player.position.set(spawn[0], spawn[1], spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    canDoubleJump = true;
    if (gameMode === 'survival' && penalize) {
      lives -= 1;
      msgEl.textContent = lives > 0 ? `Oops! Lives left: ${lives}` : 'Game over. Restart or change level.';
      if (lives <= 0) paused = true;
    } else {
      msgEl.textContent = 'Try again!';
    }
    updateHUD();
  }

  // Ambient particles — reduced count
  const dustGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const dustMat = new THREE.MeshBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.22 });
  const dusts = [];
  for (let i=0;i<50;i++){ // reduced from 120
    const d = new THREE.Mesh(dustGeo, dustMat);
    d.position.set((Math.random()-0.5)*90, 2+Math.random()*14, (Math.random()-0.5)*140);
    scene.add(d); dusts.push(d);
  }

  // Init
  loadLevel(0, 0);
  applyMode('classic');

  // Main loop
  const clock = new THREE.Clock();
  let tGoal = 0;

  function animate() {
    requestAnimationFrame(animate);
    if (paused) return;

    const dt = Math.min(0.016, clock.getDelta()); // stable physics, smoother feel

    // Cosmetics
    hat.position.set(player.position.x, player.position.y + playerHeight * 0.5 + 0.4, player.position.z);
    trail.position.set(player.position.x, player.position.y + 0.2, player.position.z);
    trail.rotation.y += dt * 2.0;
    if (ownerUnlocked && !ownerSprite) ownerSprite = makeOwnerSprite();
    if (ownerUnlocked && ownerSprite) ownerSprite.position.set(player.position.x, player.position.y + playerHeight * 0.5 + 1.8, player.position.z);

    // Time attack
    if (gameMode === 'time') {
      timeLeft -= dt;
      if (timeLeft <= 0) { timeLeft = 0; msgEl.textContent = 'Time up! Restart or switch mode.'; paused = true; }
    }
    updateHUD();

    // Input vector
    const ix = (keys.right ? 1 : 0) - (keys.left ? 1 : 0) + moveDx;
    const iz = (keys.down ? 1 : 0) - (keys.up ? 1 : 0) + moveDy;
    const input = new THREE.Vector3(ix, 0, iz);
    if (input.lengthSq() > 1) input.normalize();

    // Camera forward/right
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

    // Movement relative to camera
    const moveVec = new THREE.Vector3().addScaledVector(forward, input.z).addScaledVector(right, input.x);
    acceleration.set(moveVec.x * (onGround ? accelGround : accelAir * airControl), 0, moveVec.z * (onGround ? accelGround : accelAir * airControl));
    acceleration.add(gravity);
    velocity.addScaledVector(acceleration, dt);

    // Jump handling
    if (keys.jump) {
      if (onGround) {
        velocity.y = jumpStrength;
        onGround = false;
        canDoubleJump = true;
        keys.jump = false;
      } else if (doubleJumpEnabled && canDoubleJump) {
        velocity.y = doubleJumpStrength;
        canDoubleJump = false;
        msgEl.textContent = 'Double jump!';
        keys.jump = false;
      }
    }

    // Integrate
    player.position.addScaledVector(velocity, dt);

    // Collisions + instant stop on floor
    const wasGrounded = onGround;
    onGround = false;
    for (const box of platforms) {
      const hit = aabbSphereCollision(box, player.position, playerRadius);
      if (hit) {
        const len = Math.hypot(hit.x, hit.y, hit.z) || 1;
        const nx = hit.x / len, ny = hit.y / len, nz = hit.z / len;
        const push = (playerRadius - len);
        player.position.x += nx * push;
        player.position.y += ny * push;
        player.position.z += nz * push;

        if (ny > 0.5) {
          onGround = true;
          if (velocity.y < 0) velocity.y = 0;
          // Instant stop horizontally when landing on floor
          velocity.x = 0;
          velocity.z = 0;
          if (gameMode === 'vanishPlatforms') box.userData.stepped = true;
        } else {
          velocity.x *= 0.82;
          velocity.z *= 0.82;
        }
      }
      if (gameMode === 'vanishPlatforms' && box.userData.stepped) {
        box.userData.vanishTimer += dt;
        if (box.userData.vanishTimer > 1.0) box.visible = false;
      }
    }
    if (!wasGrounded && onGround) canDoubleJump = true;

    // Ground plane instant stop safeguard
    if (player.position.y < 0.9) {
      player.position.y = 0.9;
      if (velocity.y < 0) velocity.y = 0;
      velocity.x = 0;
      velocity.z = 0;
      onGround = true;
    }

    // Coins: collectible
    for (const c of coins) {
      if (!c.visible) continue;
      c.rotation.z += dt * 2.0;
      const d = c.position.distanceTo(player.position);
      if (d < playerRadius + 0.6) {
        c.visible = false;
        coinsCollected += 1;
        msgEl.textContent = `Coin collected! (${coinsCollected}/${coins.length})`;
        updateHUD();
      }
    }

    // Monkey chase
    if (gameMode === 'monkeyChase') {
      for (const m of monkeys) {
        const dir = new THREE.Vector3().subVectors(player.position, m.position);
        const dist = dir.length();
        if (dist > 0.001) dir.normalize();
        m.position.addScaledVector(dir, dt * 4.0);
        if (dist < 0.7) { msgEl.textContent = 'Caught by a monkey!'; respawn(true); }
      }
    }

    // Lava rising
    if (gameMode === 'lavaTower' && lava) {
      lavaHeight += dt * 1.2;
      lava.position.y = lavaHeight;
      if (player.position.y < lavaHeight + 0.3) { msgEl.textContent = 'The lava got you!'; respawn(true); }
    }

    // Goal
    tGoal += dt;
    if (goal) {
      goal.rotation.x = Math.sin(tGoal * 1.2) * 0.18;
      goal.rotation.y += dt * 0.7;
      if (player.position.distanceTo(goal.position) < 1.6) {
        if (gameMode === 'coinCollector' && coinsCollected < coins.length) {
          msgEl.textContent = 'Collect all coins first!';
        } else {
          msgEl.textContent = 'Level complete! Loading next...';
          const nextLevel = (currentLevel + 1) % SCENES[currentScene].levels.length;
          setTimeout(() => { loadLevel(currentScene, nextLevel); }, 900);
        }
      }
    }

    // Void fall
    if (player.position.y < voidY) respawn(gameMode === 'survival');

    // Camera placement (snap)
    if (cameraMode === 'third') {
      const y = Math.sin(camPitch) * orbitRadius;
      const h = Math.cos(camPitch) * orbitRadius;
      const camX = player.position.x + Math.sin(camYaw) * h;
      const camZ = player.position.z + Math.cos(camYaw) * h;
      camera.position.set(camX, player.position.y + y + 1.6, camZ);
      camera.lookAt(new THREE.Vector3(player.position.x, player.position.y + 0.9, player.position.z));
    } else {
      const head = new THREE.Vector3(player.position.x, player.position.y + playerHeight * 0.5 + 0.5, player.position.z);
      const dir = new THREE.Vector3(Math.sin(camYaw) * Math.cos(camPitch), Math.sin(camPitch), Math.cos(camYaw) * Math.cos(camPitch));
      camera.position.copy(head);
      camera.lookAt(head.clone().add(dir));
    }

    // Ambient particles drift
    for (const d of dusts) {
      d.position.x += Math.sin(tGoal + d.id) * 0.003;
      d.position.y += Math.cos(tGoal + d.id) * 0.002;
    }

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
})();
</script>
</body>
</html>
