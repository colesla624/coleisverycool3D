<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Game Hub — Unified Settings + Fixed Camera (7 Games incl. Lava Monkey Jungle)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, sans-serif; }
    canvas { display:block; }

    /* Top bar, HUD, menu */
    #topbar { position:absolute; top:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; user-select:none; }
    #topbar .small { font-size:12px; opacity:0.85; font-weight:500; }
    #hud { position:absolute; bottom:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; display:none; }
    #hud .line { margin-top:6px; font-weight:600; }
    #menu { position:absolute; inset:0; display:grid; place-items:center; z-index:11; }
    #menuPanel { width:820px; max-width:94vw; background:#111a; backdrop-filter: blur(6px); border:1px solid #fff2; border-radius:16px; padding:20px; color:#fff; }
    #menuPanel h1 { margin:0 0 8px; font-size:28px; }
    #menuGrid { display:grid; grid-template-columns:repeat(2, minmax(280px, 1fr)); gap:12px; margin-top:10px; }
    .menuBtn { padding:14px; background:#222a; border:1px solid #fff2; color:#fff; border-radius:12px; cursor:pointer; text-align:left; }
    .menuBtn:hover { background:#2a2f; }
    .row { display:flex; gap:8px; align-items:center; margin-top:12px; }
    .pill { padding:8px 12px; border-radius:999px; background:#fff1; border:1px solid #fff2; cursor:pointer; }

    /* Back button and message */
    #backBtn { position:absolute; top:10px; right:10px; z-index:12; padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; display:none; cursor:pointer; }
    #msg { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#fff; z-index:12; text-align:center; font-weight:800; font-size:22px; display:none; }
    #msg button { margin-top:12px; background:#ff6a00; border:none; color:#fff; font-weight:800; padding:10px 16px; border-radius:10px; cursor:pointer; }

    /* Shared settings panel (Lava Monkey-style) */
    #settingsBar { position:absolute; top:56px; right:10px; z-index:12; display:none; display:flex; gap:8px; }
    .settingsBtn { padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; cursor:pointer; }

    /* Shop modal */
    #shop { position:absolute; top:20%; left:50%; transform:translateX(-50%); background:#1e1e1e; color:#fff; padding:20px; border-radius:12px; display:none; z-index:13; width:360px; border:1px solid #fff2; }
    #shop h2 { margin:0 0 10px; }
    #shop .row { margin:8px 0; display:flex; justify-content:space-between; align-items:center; }
    #shop .row button { padding:6px 10px; border:none; border-radius:8px; background:#444; color:#fff; cursor:pointer; }
    #closeShop { margin-top:12px; width:100%; padding:8px; border:none; border-radius:8px; background:#6a6a6a; color:#fff; cursor:pointer; }

    /* Mobile joysticks and buttons */
    #controls { position:absolute; bottom:16px; left:16px; right:16px; z-index:12; display:flex; justify-content:space-between; align-items:flex-end; pointer-events:none; }
    .stick { width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); position:relative; pointer-events:auto; touch-action:none; }
    .knob { position:absolute; width:64px; height:64px; border-radius:50%; background:rgba(255,255,255,0.25); left:calc(50% - 32px); top:calc(50% - 32px); }
    #rightPanel { display:flex; flex-direction:column; align-items:center; gap:12px; pointer-events:auto; }
    .btn { pointer-events:auto; touch-action:none; width:84px; height:84px; border-radius:16px; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); color:#fff; display:grid; place-items:center; font-weight:800; }

    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="title">3D Game Hub — Unified Settings + Fixed Camera</div>
    <div class="small" id="hint">Left stick: move. Right stick: look. Jump/Action buttons. Esc/Back to menu.</div>
  </div>

  <button id="backBtn">Back to menu</button>

  <div id="menu">
    <div id="menuPanel">
      <h1>Pick a game</h1>
      <div id="menuGrid">
        <button class="menuBtn" data-game="jungle">
          <div style="font-weight:800">Lava Monkey Jungle</div>
          <div class="small">Survive monkeys and rising lava. Coins & medkits. Full shop, skins, camera toggle.</div>
        </button>
        <button class="menuBtn" data-game="platformer">
          <div style="font-weight:800">Sky Platforms (First‑Person Platformer)</div>
          <div class="small">Jump across floating platforms to reach the goal. Full settings & toggle.</div>
        </button>
        <button class="menuBtn" data-game="racer">
          <div style="font-weight:800">Desert Ridge Racer</div>
          <div class="small">Drive from the cockpit. Pass gates to finish. Shop applies boosts & maps.</div>
        </button>
        <button class="menuBtn" data-game="arena">
          <div style="font-weight:800">Space Drone Arena</div>
          <div class="small">Shoot drones in zero‑g. Shop boosts weapon power & map variants.</div>
        </button>
        <button class="menuBtn" data-game="runner">
          <div style="font-weight:800">Forest Endless Runner</div>
          <div class="small">First‑person lane dodging with rising speed. Skins & map variants included.</div>
        </button>
        <button class="menuBtn" data-game="maze">
          <div style="font-weight:800">Crystal Maze</div>
          <div class="small">Navigate a glowing maze to find the exit. Map variants and camera toggle.</div>
        </button>
        <button class="menuBtn" data-game="range">
          <div style="font-weight:800">Target Range</div>
          <div class="small">Aim practice. Weapon upgrades and skins affect feel.</div>
        </button>
      </div>
      <div class="row">
        <div class="pill" id="graphicsLow">Graphics: Low</div>
        <div class="pill" id="graphicsHigh">Graphics: High</div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudPrimary">—</div>
    <div class="line" id="hudSecondary"></div>
  </div>

  <!-- Shared settings controls (Monkey-game style) -->
  <div id="settingsBar">
    <button id="viewBtn" class="settingsBtn">VIEW: FIRST</button>
    <button id="shopBtn" class="settingsBtn">SHOP</button>
  </div>

  <!-- Shop modal (shared across all games, context-aware effects) -->
  <div id="shop">
    <h2>Shop</h2>
    <div class="row"><span>Weapon upgrade</span><button data-cost="10" data-type="weapon">Buy (10)</button></div>
    <div class="row"><span>Map: Night</span><button data-cost="20" data-type="mapNight">Buy (20)</button></div>
    <div class="row"><span>Map: Day</span><button data-cost="0" data-type="mapDay">Use</button></div>
    <div class="row"><span>Skin: Red</span><button data-cost="15" data-type="skinRed">Buy (15)</button></div>
    <div class="row"><span>Skin: Blue</span><button data-cost="0" data-type="skinBlue">Use</button></div>
    <button id="closeShop">Close</button>
  </div>

  <div id="msg">
    <div id="msgText">—</div>
    <button id="restart">Restart</button>
  </div>

  <!-- Mobile controls shared across all games -->
  <div id="controls" style="display:none">
    <div id="leftStick" class="stick"><div class="knob" id="leftKnob"></div></div>
    <div id="rightPanel">
      <div id="rightStick" class="stick"><div class="knob" id="rightKnob"></div></div>
      <div style="display:flex; gap:12px;">
        <div id="jumpBtn" class="btn">JUMP</div>
        <div id="actionBtn" class="btn">ACTION</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Shared UI elements
    const menu = document.getElementById('menu');
    const backBtn = document.getElementById('backBtn');
    const hud = document.getElementById('hud');
    const hudPrimary = document.getElementById('hudPrimary');
    const hudSecondary = document.getElementById('hudSecondary');
    const msg = document.getElementById('msg');
    const msgText = document.getElementById('msgText');
    const restartBtn = document.getElementById('restart');
    const graphicsLow = document.getElementById('graphicsLow');
    const graphicsHigh = document.getElementById('graphicsHigh');
    const controls = document.getElementById('controls');
    const jumpBtn = document.getElementById('jumpBtn');
    const actionBtn = document.getElementById('actionBtn');
    const settingsBar = document.getElementById('settingsBar');
    const viewBtn = document.getElementById('viewBtn');
    const shopBtn = document.getElementById('shopBtn');
    const shopEl = document.getElementById('shop');
    const closeShopBtn = document.getElementById('closeShop');

    // Joystick setup (shared)
    function setupStick(stickId, knobId) {
      const stick = document.getElementById(stickId), knob = document.getElementById(knobId);
      let vec = { x: 0, y: 0 }, active = false;
      function setKnob(x, y) { const r = stick.getBoundingClientRect(); knob.style.left = `${x - r.left - 32}px`; knob.style.top = `${y - r.top - 32}px`; }
      function handle(e, a) {
        const r = stick.getBoundingClientRect(), cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let x = e.clientX, y = e.clientY; if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
        const dx = x - cx, dy = y - cy, len = Math.min(Math.hypot(dx, dy), r.width * 0.45);
        const nx = len ? dx / len : 0, ny = len ? dy / len : 0;
        active = a;
        if (a) { setKnob(cx + nx * len, cy + ny * len); vec = { x: nx * (len / (r.width * 0.45)), y: ny * (len / (r.width * 0.45)) }; }
        else { setKnob(cx, cy); vec = { x: 0, y: 0 }; }
      }
      stick.addEventListener('pointerdown', e => { stick.setPointerCapture(e.pointerId); handle(e, true); });
      stick.addEventListener('pointermove', e => { if (active) handle(e, true); });
      stick.addEventListener('pointerup', e => { stick.releasePointerCapture(e.pointerId); handle(e, false); });
      stick.addEventListener('touchstart', e => handle(e, true), { passive: false });
      stick.addEventListener('touchmove', e => handle(e, true), { passive: false });
      stick.addEventListener('touchend', e => handle(e, false), { passive: false });
      return { get: () => vec };
    }
    const moveStick = setupStick('leftStick', 'leftKnob');
    const lookStick = setupStick('rightStick', 'rightKnob');

    // Prevent iOS pinch/zoom gesture
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Graphics quality
    let quality = 'high';
    graphicsLow.onclick = () => { quality = 'low'; graphicsLow.style.background = '#44aa44'; graphicsHigh.style.background = '#fff1'; };
    graphicsHigh.onclick = () => { quality = 'high'; graphicsHigh.style.background = '#44aa44'; graphicsLow.style.background = '#fff1'; };
    graphicsHigh.click();

    // Shared hub state
    let scene = null, camera = null, cleanup = null, running = false;
    let keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Escape') showMenu(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // Shared player cosmetics state (shop)
    const shopState = {
      cameraMode: 'first',
      mapVariant: 'day',
      skin: 'blue',
      weaponLevel: 0 // 0=base, 1=upgraded
    };

    backBtn.onclick = () => showMenu();
    restartBtn.onclick = () => { if (cleanup && cleanup.restart) cleanup.restart(); };

    viewBtn.onclick = () => {
      shopState.cameraMode = (shopState.cameraMode === 'first') ? 'third' : 'first';
      viewBtn.textContent = `VIEW: ${shopState.cameraMode.toUpperCase()}`;
      if (cleanup && cleanup.setCameraMode) cleanup.setCameraMode(shopState.cameraMode);
    };

    shopBtn.onclick = () => { shopEl.style.display = 'block'; };
    closeShopBtn.onclick = () => { shopEl.style.display = 'none'; };

    // Shared shop apply
    shopEl.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON' || e.target.id === 'closeShop') return;
      const cost = parseInt(e.target.dataset.cost || '0', 10);
      if (cleanup && cleanup.getCurrency && cleanup.setCurrency) {
        const coins = cleanup.getCurrency();
        if (cost > coins) { alert('Not enough coins'); return; }
        if (cost > 0) cleanup.setCurrency(coins - cost);
      }
      const type = e.target.dataset.type;
      applyShop(type);
    });

    function applyShop(type) {
      switch (type) {
        case 'weapon':
          shopState.weaponLevel = 1;
          if (cleanup && cleanup.applyWeaponUpgrade) cleanup.applyWeaponUpgrade();
          break;
        case 'mapNight':
          shopState.mapVariant = 'night';
          if (cleanup && cleanup.applyMapVariant) cleanup.applyMapVariant('night');
          break;
        case 'mapDay':
          shopState.mapVariant = 'day';
          if (cleanup && cleanup.applyMapVariant) cleanup.applyMapVariant('day');
          break;
        case 'skinRed':
          shopState.skin = 'red';
          if (cleanup && cleanup.applySkin) cleanup.applySkin('red');
          break;
        case 'skinBlue':
          shopState.skin = 'blue';
          if (cleanup && cleanup.applySkin) cleanup.applySkin('blue');
          break;
      }
    }

    function showMenu() {
      running = false;
      hud.style.display = 'none';
      settingsBar.style.display = 'none';
      controls.style.display = 'none';
      msg.style.display = 'none';
      shopEl.style.display = 'none';
      menu.style.display = 'grid';
      if (cleanup && cleanup.dispose) cleanup.dispose();
      cleanup = null;
      scene = null;
      camera = null;
    }

    function startGame(setup) {
      if (cleanup && cleanup.dispose) cleanup.dispose();
      cleanup = setup(quality, shopState);
      scene = cleanup.scene;
      camera = cleanup.camera;
      running = true;
      hud.style.display = 'block';
      backBtn.style.display = 'inline-block';
      controls.style.display = 'flex';
      settingsBar.style.display = 'flex';
      menu.style.display = 'none';
      viewBtn.textContent = `VIEW: ${shopState.cameraMode.toUpperCase()}`;
    }

    // Menu button routing
    document.querySelectorAll('.menuBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const game = btn.dataset.game;
        switch (game) {
          case 'jungle': startGame(setupJungleFP); break;
          case 'platformer': startGame(setupPlatformerFP); break;
          case 'racer': startGame(setupRacerFP); break;
          case 'arena': startGame(setupArenaFP); break;
          case 'runner': startGame(setupRunnerFP); break;
          case 'maze': startGame(setupMazeFP); break;
          case 'range': startGame(setupRangeFP); break;
        }
      });
    });

    // Common helpers
    function makeLights(env) {
      const group = new THREE.Group();
      if (env === 'day') {
        const hemi = new THREE.HemisphereLight(0xffffff, 0x228822, 1.0);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(20, 40, 10);
        group.add(hemi, sun);
      } else if (env === 'space') {
        const amb = new THREE.AmbientLight(0x8888aa, 0.9);
        const key = new THREE.DirectionalLight(0xffffff, 0.7);
        key.position.set(15, 25, -10);
        group.add(amb, key);
      } else if (env === 'maze') {
        const amb = new THREE.AmbientLight(0x6666ff, 0.6);
        const key = new THREE.PointLight(0x88aaff, 1.0, 200);
        key.position.set(0, 20, 0);
        group.add(amb, key);
      }
      return group;
    }

    // Camera helpers (fixed yaw/pitch, no roll)
    function updateFirstPersonCamera(cam, playerPos, yaw, pitch, eyeHeight=1.1) {
      cam.position.set(playerPos.x, playerPos.y + eyeHeight, playerPos.z);
      cam.rotation.set(0, 0, 0);
      cam.rotateX(THREE.MathUtils.clamp(pitch, -1.2, 1.2));
      cam.rotateY(yaw);
    }
    function updateThirdPersonCamera(cam, playerPos, yaw, dist=6.0, height=2.5) {
      const offset = new THREE.Vector3(Math.sin(yaw) * dist, height, -Math.cos(yaw) * dist);
      cam.position.copy(playerPos).add(offset);
      cam.lookAt(playerPos.x, playerPos.y + 1.0, playerPos.z);
    }

    // Shared look application from right stick
    function applyLookFromStick(yawPitch, dt, sensitivity=1.8, flip=false) {
      const ls = lookStick.get();
      const lx = flip ? -ls.x : ls.x;
      const ly = flip ? -ls.y : ls.y;
      yawPitch.yaw += lx * sensitivity * dt;
      yawPitch.pitch = THREE.MathUtils.clamp(yawPitch.pitch + ly * sensitivity * dt, -1.2, 1.2);
    }

    // GAME 1: Lava Monkey Jungle (Full features preserved)
    function setupJungleFP(quality, shopState) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(140, 140), new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      function addTree(x, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 2.2, 10), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
        trunk.position.set(x, 1.1, z);
        const foliage = new THREE.Mesh(new THREE.SphereGeometry(1.3, 18, 18), new THREE.MeshStandardMaterial({ color: 0x006400 }));
        foliage.position.set(x, 2.6, z);
        sc.add(trunk, foliage);
      }
      for (let i = 0; i < (quality === 'high' ? 28 : 16); i++) {
        const a = Math.random() * Math.PI * 2, d = 12 + Math.random() * 55;
        addTree(Math.cos(a) * d, Math.sin(a) * d);
      }

      const playerRadius = 0.5;
      const playerMat = new THREE.MeshStandardMaterial({ color: (shopState.skin === 'red' ? 0xff4444 : 0x66aaff) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.6, 8, 16), playerMat);
      player.position.set(0, playerRadius + 0.3, 0); sc.add(player);

      const weaponMat = new THREE.MeshStandardMaterial({ color: 0x885000 });
      const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.12), weaponMat);
      if (shopState.weaponLevel > 0) { weapon.scale.set(1.1, 1.3, 1.1); weaponMat.color.set(0x553300); }
      weapon.position.set(0.45, 0.35, 0.0); player.add(weapon);

      const lava = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 0.3, 48, 1, true),
        new THREE.MeshStandardMaterial({ color: 0xff3c00, emissive: 0xff2200, emissiveIntensity: 0.95 }));
      lava.position.y = -2.5; sc.add(lava);

      const enemies = [];
      function createMonkey() {
        const g = new THREE.Group();
        const m = new THREE.MeshStandardMaterial({ color: 0x7a4b2a });
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), m);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), m); head.position.set(0, 0.52, 0.02);
        const earL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), m); earL.position.set(-0.22, 0.58, 0.02);
        const earR = earL.clone(); earR.position.x = 0.22;
        g.add(body, head, earL, earR); return g;
      }
      function spawnEnemy() {
        const e = createMonkey();
        const a = Math.random() * Math.PI * 2, d = 16 + Math.random() * 14;
        e.position.set(Math.cos(a) * d, 0.45, Math.sin(a) * d);
        e.userData.speed = 5.9 + Math.random() * 0.8;
        enemies.push(e); sc.add(e);
      }
      let run = true;
      let spawnTimer = setInterval(() => { if (run) spawnEnemy(); }, 1000);

      const coins = [], medkits = []; let coinCount = 0;
      function coin() {
        const c = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 24), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
        c.rotation.x = Math.PI / 2;
        c.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110);
        coins.push(c); sc.add(c);
      }
      function medkit() {
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.5), new THREE.MeshStandardMaterial({ color: 0xFF0000 }));
        m.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110);
        medkits.push(m); sc.add(m);
      }
      for (let i = 0; i < (quality === 'high' ? 14 : 8); i++) coin();
      for (let i = 0; i < (quality === 'high' ? 6 : 3); i++) medkit();

      let health = 100, start = performance.now();
      const velocity = new THREE.Vector3();
      const accelGround = 16, accelAir = 6, friction = 12, maxSpeed = 7.2, gravity = 18, jumpStrength = 10.8;
      let onGround = true;
      let yaw = 0, pitch = 0;
      let cameraMode = shopState.cameraMode;

      hudPrimary.textContent = 'Jungle — Survive';
      hudSecondary.textContent = 'Health 100 | Coins 0';

      // Attack
      let attacking = false, attackStart = 0;
      let attackDuration = 200;
      let attackRange = (shopState.weaponLevel > 0) ? 1.8 : 1.4;
      const attackArcCos = Math.cos(Math.PI / 3);

      function startAttack() {
        if (attacking || !run) return;
        attacking = true; attackStart = performance.now();
        weapon.rotation.z = -Math.PI * 0.35;
        const forward = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
        const p = player.position.clone();
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const to = new THREE.Vector3().subVectors(e.position, p);
          const dist = to.length(); if (dist > attackRange) continue;
          to.normalize(); const dot = to.dot(forward);
          if (dot >= attackArcCos) { sc.remove(e); enemies.splice(i, 1); }
        }
        setTimeout(() => { attacking = false; weapon.rotation.z = 0; }, attackDuration);
      }
      actionBtn.onclick = startAttack;
      jumpBtn.onclick = () => { if (onGround && run) velocity.y = jumpStrength; };

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x0a1020);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x1c3a1c);
        } else {
          sc.background = new THREE.Color(0x87ceeb);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0x228B22);
        }
      }
      applyMapVariant(shopState.mapVariant);

      function applySkin(skin) {
        playerMat.color.set(skin === 'red' ? 0xff4444 : 0x66aaff);
      }

      function restart() {
        health = 100; coinCount = 0; start = performance.now();
        velocity.set(0, 0, 0); player.position.set(0, playerRadius + 0.3, 0);
        yaw = 0; pitch = 0; lava.position.y = -2.5;
        enemies.forEach(e => sc.remove(e)); enemies.length = 0;
        coins.forEach(c => sc.remove(c)); coins.length = 0;
        medkits.forEach(m => sc.remove(m)); medkits.length = 0;
        for (let i = 0; i < (quality === 'high' ? 14 : 8); i++) coin();
        for (let i = 0; i < (quality === 'high' ? 6 : 3); i++) medkit();
        run = true; msg.style.display = 'none';
        hudSecondary.textContent = 'Health 100 | Coins 0';
      }

      function dispose() { clearInterval(spawnTimer); }

      // Keyboard fallback
      window.addEventListener('keydown', e => {
        if (e.code === 'Space' && onGround && run) velocity.y = jumpStrength;
        if (e.code === 'KeyF' && run) startAttack();
      });

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        getCurrency: () => coinCount,
        setCurrency: v => { coinCount = v; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => { attackRange = 1.8; weapon.scale.set(1.1, 1.3, 1.1); weaponMat.color.set(0x553300); },
        setCameraMode: mode => { cameraMode = mode; },
        update(dt, now) {
          if (!run) return;

          // Look (flip axes in first-person for feel)
          const flip = (cameraMode === 'first');
          applyLookFromStick({ yaw, pitch }, dt, 1.8, flip);
          // assign back (applyLookFromStick uses a temp object)
          const ls = lookStick.get();
          const lx = flip ? -ls.x : ls.x;
          const ly = flip ? -ls.y : ls.y;
          yaw += lx * 1.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * 1.8 * dt, -1.2, 1.2);

          // Movement
          const mv = moveStick.get();
          let inputX = mv.x, inputY = -mv.y;
          const kForward = (keys.KeyW || keys.ArrowUp) ? 1 : 0;
          const kBack = (keys.KeyS || keys.ArrowDown) ? 1 : 0;
          const kLeft = (keys.KeyA || keys.ArrowLeft) ? 1 : 0;
          const kRight = (keys.KeyD || keys.ArrowRight) ? 1 : 0;
          inputX += (kRight - kLeft);
          inputY += (kForward - kBack);

          const mag = Math.hypot(inputX, inputY);
          if (mag > 1) { inputX /= mag; inputY /= mag; }

          const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
          const fwd = new THREE.Vector3(sinY, 0, -cosY);
          const right = new THREE.Vector3(cosY, 0, sinY);
          const wishdir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(fwd, inputY);
          if (wishdir.lengthSq() > 0) wishdir.normalize();

          const accel = onGround ? accelGround : accelAir;
          velocity.addScaledVector(wishdir, accel * dt);

          // Friction
          if (onGround && mag < 0.05) {
            const horiz = new THREE.Vector2(velocity.x, velocity.z);
            const speed = horiz.length();
            const drop = friction * dt;
            const newSpeed = Math.max(speed - drop, 0);
            if (speed > 0) {
              horiz.multiplyScalar(newSpeed / speed);
              velocity.x = horiz.x; velocity.z = horiz.y;
            }
          }

          // Cap speed
          const horiz = new THREE.Vector2(velocity.x, velocity.z);
          const speed = horiz.length();
          if (speed > maxSpeed) {
            horiz.multiplyScalar(maxSpeed / speed);
            velocity.x = horiz.x; velocity.z = horiz.y;
          }

          // Gravity/integration
          velocity.y -= gravity * dt;
          player.position.addScaledVector(velocity, dt);

          // Ground
          const groundY = playerRadius + 0.3;
          if (player.position.y < groundY) { player.position.y = groundY; velocity.y = 0; onGround = true; }
          else onGround = false;

          // Camera
          if (cameraMode === 'first') updateFirstPersonCamera(cam, player.position, yaw, pitch, 1.1);
          else updateThirdPersonCamera(cam, player.position, yaw);

          // Weapon anim
          if (!attacking) {
            weapon.rotation.x = Math.sin(now * 0.004) * 0.08;
            weapon.rotation.z = 0;
          } else {
            const t = Math.min((performance.now() - attackStart) / attackDuration, 1);
            weapon.rotation.x = -0.2;
            weapon.rotation.z = -Math.PI * 0.35 + Math.sin(t * Math.PI) * 0.5;
          }

          // Lava rise
          lava.position.y += 0.018 * dt;

          // Enemies + separation + damage
          const bob = Math.sin(now * 0.004) * 0.02;
          for (let i = 0; i < enemies.length; i++) {
            const e = enemies[i];
            e.position.y = 0.45 + bob;
            const toP = new THREE.Vector3().subVectors(player.position, e.position);
            const d = toP.length();
            if (d > 0.0001) toP.normalize();
            e.position.addScaledVector(toP, e.userData.speed * dt);

            for (let j = i + 1; j < enemies.length; j++) {
              const f = enemies[j];
              const sep = new THREE.Vector3().subVectors(e.position, f.position);
              const sl = sep.length();
              if (sl > 0 && sl < 0.9) {
                sep.normalize();
                e.position.addScaledVector(sep, (0.9 - sl) * 0.15);
                f.position.addScaledVector(sep.multiplyScalar(-1), (0.9 - sl) * 0.15);
              }
            }

            if (d < 0.85) { health -= 18 * dt; if (health < 0) health = 0; }
          }

          // Collectibles
          for (let i = coins.length - 1; i >= 0; i--) {
            const c = coins[i];
            if (c.position.distanceTo(player.position) < 0.8) {
              coinCount += 1; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;
              sc.remove(c); coins.splice(i, 1);
            }
          }
          for (let i = medkits.length - 1; i >= 0; i--) {
            const m = medkits[i];
            if (m.position.distanceTo(player.position) < 0.9) {
              health = Math.min(100, health + 25);
              hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;
              sc.remove(m); medkits.splice(i, 1);
            }
          }

          // Lose
          const feet = player.position.y - groundY;
          const lavaTop = lava.position.y + 0.15;
          if (feet <= lavaTop || health <= 0) {
            run = false; msgText.textContent = 'Game Over — Jungle'; msg.style.display = 'block';
          }

          // HUD
          hudPrimary.textContent = `Jungle — ${((performance.now() - start) / 1000).toFixed(1)}s`;
          hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;
        }
      };
    }

    // GAME 2: First‑Person Platformer (with shared settings)
    function setupPlatformerFP(quality, shopState) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87b3ff);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const platMat = new THREE.MeshStandardMaterial({ color: 0x6aa86a, roughness: 0.8 });
      const plats = [];
      function platform(w, h, d, x, y, z) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), platMat);
        p.position.set(x, y, z);
        sc.add(p); plats.push(p);
      }
      const baseY = 0;
      platform(40, 2, 12, 0, baseY, 0);
      platform(12, 2, 12, 28, baseY + 8, -6);
      platform(16, 2, 12, 48, baseY + 16, 8);
      platform(10, 2, 10, 66, baseY + 24, 0);
      platform(14, 2, 12, 86, baseY + 30, -10);
      platform(20, 2, 12, 110, baseY + 34, 6);

      const goal = new THREE.Mesh(new THREE.TorusKnotGeometry(3, 1, 90, 12), new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0x553300, emissiveIntensity: 0.3 }));
      goal.position.set(120, baseY + 40, 6); sc.add(goal);

      const playerRadius = 0.6;
      const playerMat = new THREE.MeshStandardMaterial({ color: (shopState.skin === 'red' ? 0xff4444 : 0x44aaff) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.8, 8, 12), playerMat);
      player.visible = false; player.position.set(-16, baseY + 6, 0); sc.add(player);

      const vel = new THREE.Vector3(0, 0, 0);
      const gravity = 18, moveSpeed = 10, jumpVel = 12.5;
      let onGround = false, run = true, won = false;
      let yaw = 0, pitch = 0;
      let cameraMode = shopState.cameraMode;

      hudPrimary.textContent = 'Sky Platforms';
      hudSecondary.textContent = 'Reach the glowing goal';

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x0a2030);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          platMat.color.set(0x355a35);
        } else {
          sc.background = new THREE.Color(0x87b3ff);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          platMat.color.set(0x6aa86a);
        }
      }
      applyMapVariant(shopState.mapVariant);

      function applySkin(skin) { playerMat.color.set(skin === 'red' ? 0xff4444 : 0x44aaff); }

      jumpBtn.onclick = () => { if (onGround && run) vel.y = jumpVel; };
      actionBtn.onclick = () => {}; // no attack

      function collide() {
        onGround = false;
        for (const p of plats) {
          const top = p.position.y + p.geometry.parameters.height / 2;
          const halfW = p.geometry.parameters.width / 2;
          const halfD = p.geometry.parameters.depth / 2;
          const withinX = (player.position.x > p.position.x - halfW - playerRadius) && (player.position.x < p.position.x + halfW + playerRadius);
          const withinZ = (player.position.z > p.position.z - halfD - playerRadius) && (player.position.z < p.position.z + halfD + playerRadius);
          const nearTop = Math.abs(player.position.y - (top + playerRadius)) < 0.6 && vel.y <= 0;
          if (withinX && withinZ && nearTop) {
            player.position.y = top + playerRadius;
            vel.y = 0;
            onGround = true;
          }
        }
        if (player.position.y < -30) { run = false; msgText.textContent = 'You fell — Platformer'; msg.style.display = 'block'; }
      }

      function restart() {
        player.position.set(-16, baseY + 6, 0);
        vel.set(0, 0, 0);
        yaw = 0; pitch = 0;
        won = false; run = true; msg.style.display = 'none';
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => 0,
        setCurrency: () => {},
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {}, // not used
        setCameraMode: mode => { cameraMode = mode; },
        update(dt) {
          if (!run || won) return;

          // Look
          const flip = (cameraMode === 'first');
          const ls = lookStick.get();
          const lx = flip ? -ls.x : ls.x;
          const ly = flip ? -ls.y : ls.y;
          yaw += lx * 1.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * 1.8 * dt, -1.2, 1.2);

          // Move
          const mv = moveStick.get();
          let inputX = mv.x, inputY = -mv.y;
          const mag = Math.hypot(inputX, inputY);
          if (mag > 1) { inputX /= mag; inputY /= mag; }
          const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
          const fwd = new THREE.Vector3(sinY, 0, -cosY);
          const right = new THREE.Vector3(cosY, 0, sinY);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(fwd, inputY);
          if (dir.lengthSq() > 0) dir.normalize();

          vel.x = THREE.MathUtils.lerp(vel.x, dir.x * moveSpeed, 8 * dt);
          vel.z = THREE.MathUtils.lerp(vel.z, dir.z * moveSpeed, 8 * dt);

          vel.y -= gravity * dt;
          player.position.addScaledVector(vel, dt);

          collide();

          // Camera
          if (cameraMode === 'first') updateFirstPersonCamera(cam, player.position, yaw, pitch, 1.1);
          else updateThirdPersonCamera(cam, player.position, yaw);

          if (player.position.distanceTo(goal.position) < 5) {
            won = true; msgText.textContent = 'Goal reached! — Platformer'; msg.style.display = 'block';
          }

          hudPrimary.textContent = 'Sky Platforms';
          hudSecondary.textContent = onGround ? 'On platform' : 'In air';
        }
      };
    }

    // GAME 3: Racer (with shared settings)
    function setupRacerFP(quality, shopState) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0xd0b38a);
      const cam = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1200);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshStandardMaterial({ color: 0xb5894a, roughness: 0.8 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      const carMat = new THREE.MeshStandardMaterial({ color: (shopState.skin === 'red' ? 0xff4444 : 0x3366ff) });
      const car = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 5), carMat);
      car.position.set(0, 0.6, 0); sc.add(car);

      const gates = [];
      function gate(x, z) {
        const g = new THREE.Mesh(new THREE.TorusGeometry(4, 0.3, 12, 24), new THREE.MeshStandardMaterial({ color: 0xffee88 }));
        g.position.set(x, 2.5, z);
        sc.add(g); gates.push(g);
      }
      for (let i = 0; i < 12; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);

      let speed = 0, heading = 0, score = 0, run = true;
      let yaw = 0, pitch = 0;
      let cameraMode = shopState.cameraMode;

      // Weapon upgrade repurposed to slight performance boost
      const accelBoost = (shopState.weaponLevel > 0) ? 1.1 : 1.0;

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x302018);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x8b6a3a);
        } else {
          sc.background = new THREE.Color(0xd0b38a);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0xb5894a);
        }
      }
      applyMapVariant(shopState.mapVariant);
      function applySkin(skin) { carMat.color.set(skin === 'red' ? 0xff4444 : 0x3366ff); }

      hudPrimary.textContent = 'Desert Racer';
      hudSecondary.textContent = 'Gates 0/12';

      actionBtn.onclick = () => {};
      jumpBtn.onclick = () => {};

      function restart() {
        car.position.set(0, 0.6, 0);
        speed = 0; heading = 0; score = 0; run = true; msg.style.display = 'none';
        gates.forEach(g => sc.remove(g)); gates.length = 0;
        for (let i = 0; i < 12; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);
        hudSecondary.textContent = 'Gates 0/12';
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => score, // treat score as currency here
        setCurrency: v => { score = v; hudSecondary.textContent = `Gates ${score}/12`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        setCameraMode: mode => { cameraMode = mode; },
        update(dt) {
          if (!run) return;

          const ls = lookStick.get();
          yaw += ls.x * 0.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ls.y * 0.8 * dt, -0.5, 0.5);

          const mv = moveStick.get();
          const steer = mv.x;
          const throttle = Math.max(0, -mv.y);
          const brake = Math.max(0, mv.y);

          speed += ((throttle * 22 * accelBoost) - (brake * 28) - speed * 0.85) * dt;
          heading += steer * 1.8 * dt;

          const dir = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
          car.position.addScaledVector(dir, speed * dt);
          car.rotation.y = heading;

          // Camera: FP cockpit vs 3rd-person chase
          if (cameraMode === 'first') {
            const eye = new THREE.Vector3(0, 0.9, 1.2).applyEuler(new THREE.Euler(0, heading, 0));
            const eyePos = new THREE.Vector3().copy(car.position).add(eye);
            cam.position.copy(eyePos);
            cam.rotation.set(0, heading, 0);
            cam.rotateX(pitch);
            cam.rotateY(yaw * 0.2);
          } else {
            updateThirdPersonCamera(cam, car.position, heading, 8.0, 3.2);
          }

          for (let i = gates.length - 1; i >= 0; i--) {
            const g = gates[i];
            if (car.position.distanceTo(g.position) < 4) {
              score++; sc.remove(g); gates.splice(i, 1);
              hudSecondary.textContent = `Gates ${score}/12`;
            }
          }

          if (gates.length === 0) { run = false; msgText.textContent = 'Finish! — Racer'; msg.style.display = 'block'; }
          hudPrimary.textContent = `Speed ${speed.toFixed(1)}`;
        }
      };
    }

    // GAME 4: Space Drone Arena (shared settings)
    function setupArenaFP(quality, shopState) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x080a12);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('space'); sc.add(lights);

      const arena = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 2, 40), new THREE.MeshStandardMaterial({ color: 0x1c2233, metalness: 0.2, roughness: 0.7 }));
      arena.position.y = -2; sc.add(arena);

      const rigMat = new THREE.MeshStandardMaterial({ color: (shopState.skin === 'red' ? 0xff4444 : 0x66aaff) });
      const rigVis = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.6, 8, 12), rigMat);
      rigVis.visible = false; sc.add(rigVis);
      const rig = new THREE.Object3D(); rig.position.set(0, 1, 0); sc.add(rig);

      const drones = [];
      function drone() {
        const d = new THREE.Mesh(new THREE.TetrahedronGeometry(1.2), new THREE.MeshStandardMaterial({ color: 0xff6666 }));
        const a = Math.random() * Math.PI * 2, r = 40;
        d.position.set(Math.cos(a) * r, 1.2, Math.sin(a) * r);
        d.userData.vel = new THREE.Vector3((Math.random() - 0.5) * 4, 0, (Math.random() - 0.5) * 4);
        sc.add(d); drones.push(d);
      }
      for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) drone();

      const bullets = [];
      const bulletSpeed = (shopState.weaponLevel > 0) ? 50 : 40;
      function shoot() {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444400 }));
        const dir = new THREE.Vector3(0, 0, -1).applyEuler(cam.rotation);
        b.position.copy(cam.position);
        b.userData.dir = dir.clone();
        sc.add(b); bullets.push(b);
      }
      actionBtn.onclick = shoot;
      jumpBtn.onclick = () => {};

      let run = true, score = 0, yaw = 0, pitch = 0;
      let cameraMode = shopState.cameraMode;

      hudPrimary.textContent = 'Space Arena';
      hudSecondary.textContent = 'Score 0 | ACTION to shoot';

      function applyMapVariant(variant) {
        sc.background = (variant === 'night') ? new THREE.Color(0x04060c) : new THREE.Color(0x080a12);
      }
      applyMapVariant(shopState.mapVariant);
      function applySkin(skin) { rigMat.color.set(skin === 'red' ? 0xff4444 : 0x66aaff); }

      function restart() {
        drones.forEach(d => sc.remove(d)); drones.length = 0;
        bullets.forEach(b => sc.remove(b)); bullets.length = 0;
        for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) drone();
        score = 0; hudSecondary.textContent = 'Score 0 | ACTION to shoot';
        rig.position.set(0, 1, 0); yaw = 0; pitch = 0; run = true; msg.style.display = 'none';
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => score,
        setCurrency: v => { score = v; hudSecondary.textContent = `Score ${score} | ACTION to shoot`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        setCameraMode: mode => { cameraMode = mode; },
        update(dt) {
          if (!run) return;

          // Look
          const flip = (cameraMode === 'first');
          const ls = lookStick.get();
          const lx = flip ? -ls.x : ls.x;
          const ly = flip ? -ls.y : ls.y;
          yaw += lx * 1.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * 1.8 * dt, -1.2, 1.2);

          // Move
          const mv = moveStick.get();
          let inputX = mv.x, inputY = -mv.y;
          const mag = Math.hypot(inputX, inputY);
          if (mag > 1) { inputX /= mag; inputY /= mag; }
          const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
          const fwd = new THREE.Vector3(sinY, 0, -cosY);
          const right = new THREE.Vector3(cosY, 0, sinY);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(fwd, inputY);
          if (dir.lengthSq() > 0) dir.normalize();
          rig.position.addScaledVector(dir, 10 * dt);
          rigVis.position.copy(rig.position);

          // Camera
          if (cameraMode === 'first') updateFirstPersonCamera(cam, rig.position, yaw, pitch, 0.9);
          else updateThirdPersonCamera(cam, rig.position, yaw, 8.0, 3.0);

          // Drones
          for (const d of drones) {
            d.position.addScaledVector(d.userData.vel, dt);
            if (d.position.length() > 78) d.userData.vel.multiplyScalar(-1);
          }

          // Bullets
          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.addScaledVector(b.userData.dir, bulletSpeed * dt);
            if (b.position.length() > 120) { sc.remove(b); bullets.splice(i, 1); continue; }
            for (let j = drones.length - 1; j >= 0; j--) {
              const d = drones[j];
              if (b.position.distanceTo(d.position) < 1.4) {
                sc.remove(d); drones.splice(j, 1);
                sc.remove(b); bullets.splice(i, 1);
                score++; hudSecondary.textContent = `Score ${score} | ACTION to shoot`;
                break;
              }
            }
          }

          if (drones.length === 0) { run = false; msgText.textContent = 'All drones cleared! — Arena'; msg.style.display = 'block'; }
        }
      };
    }

    // GAME 5: Runner (shared settings)
    function setupRunnerFP(quality, shopState) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 60), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      ground.rotation.x = -Math.PI / 2; ground.position.z = -40; sc.add(ground);

      const rigMat = new THREE.MeshStandardMaterial({ color: (shopState.skin === 'red' ? 0xff4444 : 0x66aaff) });
      const rigVis = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rigVis.visible = false; sc.add(rigVis);
      const rig = new THREE.Object3D(); rig.position.set(0, 1, 0); sc.add(rig);

      const obstacles = [];
      function makeObs(z) {
        const o = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x884444 }));
        o.position.set((Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2, 0.6, -z);
        sc.add(o); obstacles.push(o);
      }
      for (let i = 0; i < (quality === 'high' ? 30 : 18); i++) makeObs(6 + i * 6);

      let laneX = 0, speed = 8, time = 0, run = true, rings = 0;
      let yaw = 0, pitch = 0;
      let cameraMode = shopState.cameraMode;

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x102020);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x1c3a1c);
        } else {
          sc.background = new THREE.Color(0x87ceeb);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0x228B22);
        }
      }
      applyMapVariant(shopState.mapVariant);
      function applySkin(skin) { rigMat.color.set(skin === 'red' ? 0xff4444 : 0x66aaff); }

      jumpBtn.onclick = () => {};
      actionBtn.onclick = () => {};

      function restart() {
        obstacles.forEach(o => sc.remove(o)); obstacles.length = 0;
        for (let i = 0; i < (quality === 'high' ? 30 : 18); i++) makeObs(6 + i * 6);
        laneX = 0; speed = 8; time = 0; rings = 0; run = true; msg.style.display = 'none';
        rig.position.set(0, 1, 0);
        hudSecondary.textContent = 'Rings 0';
      }

      hudPrimary.textContent = 'Endless Runner';
      hudSecondary.textContent = 'Rings 0';

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => rings,
        setCurrency: v => { rings = v; hudSecondary.textContent = `Rings ${rings}`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        setCameraMode: mode => { cameraMode = mode; },
        update(dt) {
