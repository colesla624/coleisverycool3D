<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Game Hub — Third Person, Levels, Local Online, Skins, Leaderboard, Voxel Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; }
    canvas { display:block; }

    #topbar { position:absolute; top:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; user-select:none; }
    #topbar .small { font-size:12px; opacity:0.85; font-weight:500; }

    #netbar { position:absolute; top:10px; left:50%; transform:translateX(-50%); background:#111a; color:#fff; padding:8px 12px; border-radius:10px; border:1px solid #fff2; z-index:12; display:none; }
    #netbar input { background:#222; border:1px solid #444; color:#fff; border-radius:8px; padding:6px 8px; margin-left:6px; width:150px; }
    #netbar .server { width:220px; }

    #backBtn { position:absolute; top:10px; right:10px; z-index:12; padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; display:none; cursor:pointer; }

    #menu { position:absolute; inset:0; display:grid; place-items:center; z-index:11; }
    #menuPanel { width:1020px; max-width:95vw; background:#111a; backdrop-filter: blur(8px); border:1px solid #fff2; border-radius:16px; padding:20px; color:#fff; }
    #menuPanel h1 { margin:0 0 8px; font-size:28px; }
    #menuGrid { display:grid; grid-template-columns:repeat(2, minmax(320px, 1fr)); gap:12px; margin-top:10px; }
    .menuBtn { padding:14px; background:#222a; border:1px solid #fff2; color:#fff; border-radius:12px; cursor:pointer; text-align:left; }
    .menuBtn:hover { background:#2a2f; }
    .row { display:flex; gap:8px; align-items:center; margin-top:12px; flex-wrap:wrap; }
    .pill { padding:8px 12px; border-radius:999px; background:#fff1; border:1px solid #fff2; cursor:pointer; }
    .inputRow { display:flex; gap:8px; align-items:center; margin-top:12px; }
    .inputRow input { background:#222; border:1px solid #444; color:#fff; border-radius:8px; padding:8px 10px; width:220px; }
    #exitBtn { background:#ff4d4d; border-color:#ff7a7a; }

    #levelBar { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .levelBtn { padding:8px 12px; border-radius:999px; background:#222a; border:1px solid #fff2; color:#fff; cursor:pointer; }

    #hud { position:absolute; bottom:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; display:none; }
    #hud .line { margin-top:6px; font-weight:600; }

    #settingsBar { position:absolute; top:56px; right:10px; z-index:12; display:none; display:flex; gap:8px; }
    .settingsBtn { padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; cursor:pointer; }

    #skins { position:absolute; top:18%; left:50%; transform:translateX(-50%); background:#1e1e1e; color:#fff; padding:20px; border-radius:12px; display:none; z-index:13; width:440px; border:1px solid #fff2; }
    #skins h2 { margin:0 0 10px; }
    #skins .grid { display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; }
    .swatch { height:40px; border-radius:10px; border:1px solid #fff3; cursor:pointer; }
    #skins .row { display:flex; gap:8px; align-items:center; margin-top:12px; }
    #closeSkins { margin-top:12px; width:100%; padding:8px; border:none; border-radius:8px; background:#6a6a6a; color:#fff; cursor:pointer; }

    #shop { position:absolute; top:20%; left:50%; transform:translateX(-50%); background:#1e1e1e; color:#fff; padding:20px; border-radius:12px; display:none; z-index:13; width:380px; border:1px solid #fff2; }
    #shop h2 { margin:0 0 10px; }
    #shop .row { margin:8px 0; display:flex; justify-content:space-between; align-items:center; }
    #shop .row button { padding:6px 10px; border:none; border-radius:8px; background:#444; color:#fff; cursor:pointer; }
    #closeShop { margin-top:12px; width:100%; padding:8px; border:none; border-radius:8px; background:#6a6a6a; color:#fff; cursor:pointer; }

    #leaderboard { position:absolute; top:28%; left:50%; transform:translateX(-50%); background:#1e1e1e; color:#fff; padding:20px; border-radius:12px; display:none; z-index:13; width:480px; border:1px solid #fff2; }
    #leaderboard h2 { margin:0 0 10px; }
    #leaderboard table { width:100%; border-collapse:collapse; }
    #leaderboard th, #leaderboard td { border-bottom:1px solid #444; padding:6px 8px; text-align:left; }
    #leaderboard .controls { margin-top:12px; display:flex; gap:8px; }
    #closeLeaderboard { padding:8px; border:none; border-radius:8px; background:#6a6a6a; color:#fff; cursor:pointer; }

    #msg { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#fff; z-index:12; text-align:center; font-weight:800; font-size:22px; display:none; }
    #msg button { margin-top:12px; background:#ff6a00; border:none; color:#fff; font-weight:800; padding:10px 16px; border-radius:10px; cursor:pointer; }

    #controls { position:absolute; bottom:16px; left:16px; right:16px; z-index:12; display:flex; justify-content:space-between; align-items:flex-end; pointer-events:none; }
    .stick { width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); position:relative; pointer-events:auto; touch-action:none; }
    .knob { position:absolute; width:64px; height:64px; border-radius:50%; background:rgba(255,255,255,0.25); left:calc(50% - 32px); top:calc(50% - 32px); }
    #rightPanel { display:flex; flex-direction:column; align-items:center; gap:12px; pointer-events:auto; }
    .btn { pointer-events:auto; touch-action:none; width:84px; height:84px; border-radius:16px; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); color:#fff; display:grid; place-items:center; font-weight:800; }

    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="title">3D Game Hub — Third Person, Levels, Local Online, Skins, Leaderboard, Voxel Builder</div>
    <div class="small" id="hint">Left: move. Right: look. Jump/Action. Esc returns to menu.</div>
  </div>

  <div id="netbar">
    <label>Player:<input id="playerName" placeholder="Guest" /></label>
    <label>Server:<input id="serverUrl" class="server" /></label>
    <button id="connectBtn">Connect</button>
    <span id="connStatus" style="margin-left:8px; opacity:0.8"></span>
  </div>

  <button id="backBtn">Back to menu</button>

  <div id="menu">
    <div id="menuPanel">
      <h1>Pick a game</h1>
      <div id="menuGrid">
        <button class="menuBtn" data-game="jungle"><div style="font-weight:800">Lava Monkey Jungle</div><div class="small">Survive enemies and lava. Levels & coins.</div></button>
        <button class="menuBtn" data-game="platformer"><div style="font-weight:800">Sky Platforms (Double Jump)</div><div class="small">Reach the goal. Visible player. Levels.</div></button>
        <button class="menuBtn" data-game="racer"><div style="font-weight:800">Desert Ridge Racer</div><div class="small">Gate racing. Levels.</div></button>
        <button class="menuBtn" data-game="arena"><div style="font-weight:800">Space Drone Arena</div><div class="small">Clear drones. Levels.</div></button>
        <button class="menuBtn" data-game="runner"><div style="font-weight:800">Forest Endless Runner</div><div class="small">Lane dodging. Levels.</div></button>
        <button class="menuBtn" data-game="maze"><div style="font-weight:800">Crystal Maze</div><div class="small">Find exit. Levels.</div></button>
        <button class="menuBtn" data-game="range"><div style="font-weight:800">Target Range</div><div class="small">Aim practice. Levels.</div></button>
        <button class="menuBtn" data-game="voxel"><div style="font-weight:800">Voxel Builder (Minecraft‑like)</div><div class="small">Place/remove blocks. Sandbox.</div></button>
      </div>

      <div class="row">
        <div class="pill" id="graphicsLow">Graphics: Low</div>
        <div class="pill" id="graphicsHigh">Graphics: High</div>
        <div class="pill" id="skinsBtn">Player skins</div>
        <div class="pill" id="leaderboardBtn">Leaderboard</div>
        <div class="pill" id="exitBtn">Exit</div>
      </div>

      <div class="inputRow">
        <label for="codeInput">Code:</label>
        <input id="codeInput" />
        <button id="applyCodeBtn" class="pill">Apply</button>
        <span id="codeStatus" class="small" style="opacity:0.85"></span>
      </div>

      <div id="levelBar" class="row">
        <span class="small" style="opacity:0.8">Start level:</span>
        <button class="levelBtn" data-level="0">Level 1</button>
        <button class="levelBtn" data-level="1">Level 2</button>
        <button class="levelBtn" data-level="2">Level 3</button>
        <button class="levelBtn" data-level="3">Level 4</button>
        <button class="levelBtn" data-level="4">Level 5</button>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudPrimary">—</div>
    <div class="line" id="hudSecondary"></div>
  </div>

  <div id="settingsBar" style="display:none">
    <button id="shopBtn" class="settingsBtn">SHOP</button>
  </div>

  <div id="skins">
    <h2>Choose your player skin</h2>
    <div class="grid">
      <div class="swatch" data-skin="blue" style="background:#4da3ff"></div>
      <div class="swatch" data-skin="red" style="background:#ff4d4d"></div>
      <div class="swatch" data-skin="green" style="background:#43c86b"></div>
      <div class="swatch" data-skin="purple" style="background:#aa66ff"></div>
      <div class="swatch" data-skin="orange" style="background:#ff9a3c"></div>
      <div class="swatch" data-skin="white" style="background:#f0f0f0"></div>
      <div class="swatch" data-skin="black" style="background:#222"></div>
      <div class="swatch" data-skin="yellow" style="background:#ffd84d"></div>
    </div>
    <div class="row"><span style="opacity:0.8">Applies to all games and online presence.</span></div>
    <button id="closeSkins">Close</button>
  </div>

  <div id="shop" style="display:none">
    <h2>Shop</h2>
    <div class="row"><span>Weapon upgrade</span><button data-cost="10" data-type="weapon">Buy (10)</button></div>
    <div class="row"><span>Map: Night</span><button data-cost="20" data-type="mapNight">Buy (20)</button></div>
    <div class="row"><span>Map: Day</span><button data-cost="0" data-type="mapDay">Use</button></div>
    <button id="closeShop">Close</button>
  </div>

  <div id="leaderboard">
    <h2>Leaderboard</h2>
    <div class="row">
      <label>Game:
        <select id="lbGame">
          <option value="jungle">Jungle</option>
          <option value="platformer">Platformer</option>
          <option value="racer">Racer</option>
          <option value="arena">Arena</option>
          <option value="runner">Runner</option>
          <option value="maze">Maze</option>
          <option value="range">Range</option>
          <option value="voxel">Voxel Builder</option>
        </select>
      </label>
    </div>
    <table id="lbTable">
      <thead><tr><th>Rank</th><th>Name</th><th>Score</th><th>Date</th></tr></thead>
      <tbody></tbody>
    </table>
    <div class="controls">
      <button id="closeLeaderboard">Close</button>
      <button id="resetLeaderboard">Reset</button>
    </div>
  </div>

  <div id="msg">
    <div id="msgText">—</div>
    <button id="restart">Restart</button>
  </div>

  <div id="controls" style="display:none">
    <div id="leftStick" class="stick"><div class="knob" id="leftKnob"></div></div>
    <div id="rightPanel">
      <div id="rightStick" class="stick"><div class="knob" id="rightKnob"></div></div>
      <div style="display:flex; gap:12px;">
        <div id="jumpBtn" class="btn">JUMP</div>
        <div id="actionBtn" class="btn">ACTION</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // UI refs
    const menu = document.getElementById('menu');
    const backBtn = document.getElementById('backBtn');
    const hud = document.getElementById('hud');
    const hudPrimary = document.getElementById('hudPrimary');
    const hudSecondary = document.getElementById('hudSecondary');
    const msg = document.getElementById('msg');
    const msgText = document.getElementById('msgText');
    const restartBtn = document.getElementById('restart');
    const graphicsLow = document.getElementById('graphicsLow');
    const graphicsHigh = document.getElementById('graphicsHigh');
    const controls = document.getElementById('controls');
    const jumpBtn = document.getElementById('jumpBtn');
    const actionBtn = document.getElementById('actionBtn');
    const settingsBar = document.getElementById('settingsBar');
    const shopBtn = document.getElementById('shopBtn');
    const shopEl = document.getElementById('shop');
    const closeShopBtn = document.getElementById('closeShop');
    const skinsBtn = document.getElementById('skinsBtn');
    const skinsEl = document.getElementById('skins');
    const closeSkinsBtn = document.getElementById('closeSkins');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const leaderboardEl = document.getElementById('leaderboard');
    const lbGame = document.getElementById('lbGame');
    const lbTable = document.getElementById('lbTable').querySelector('tbody');
    const closeLeaderboardBtn = document.getElementById('closeLeaderboard');
    const resetLeaderboardBtn = document.getElementById('resetLeaderboard');
    const exitBtn = document.getElementById('exitBtn');

    const netbar = document.getElementById('netbar');
    const playerNameInput = document.getElementById('playerName');
    const serverUrlInput = document.getElementById('serverUrl');
    const connectBtn = document.getElementById('connectBtn');
    const connStatus = document.getElementById('connStatus');

    const codeInput = document.getElementById('codeInput');
    const applyCodeBtn = document.getElementById('applyCodeBtn');
    const codeStatus = document.getElementById('codeStatus');

    // Joystick setup
    function setupStick(stickId, knobId) {
      const stick = document.getElementById(stickId), knob = document.getElementById(knobId);
      let vec = { x: 0, y: 0 }, active = false;
      function setKnob(x, y) { const r = stick.getBoundingClientRect(); knob.style.left = `${x - r.left - 32}px`; knob.style.top = `${y - r.top - 32}px`; }
      function handle(e, a) {
        const r = stick.getBoundingClientRect(), cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let x = e.clientX, y = e.clientY; if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
        const dx = x - cx, dy = y - cy, len = Math.min(Math.hypot(dx, dy), r.width * 0.45);
        const nx = len ? dx / len : 0, ny = len ? dy / len : 0;
        active = a;
        if (a) { setKnob(cx + nx * len, cy + ny * len); vec = { x: nx * (len / (r.width * 0.45)), y: ny * (len / (r.width * 0.45)) }; }
        else { setKnob(cx, cy); vec = { x: 0, y: 0 }; }
      }
      stick.addEventListener('pointerdown', e => { stick.setPointerCapture(e.pointerId); handle(e, true); });
      stick.addEventListener('pointermove', e => { if (active) handle(e, true); });
      stick.addEventListener('pointerup', e => { stick.releasePointerCapture(e.pointerId); handle(e, false); });
      stick.addEventListener('touchstart', e => handle(e, true), { passive: false });
      stick.addEventListener('touchmove', e => handle(e, true), { passive: false });
      stick.addEventListener('touchend', e => handle(e, false), { passive: false });
      return { get: () => vec };
    }
    const moveStick = setupStick('leftStick', 'leftKnob');
    const lookStick = setupStick('rightStick', 'rightKnob');

    // Prevent iOS pinch/zoom gesture
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Graphics quality toggle
    let quality = 'high';
    graphicsLow.onclick = () => { quality = 'low'; graphicsLow.style.background = '#44aa44'; graphicsHigh.style.background = '#fff1'; };
    graphicsHigh.onclick = () => { quality = 'high'; graphicsHigh.style.background = '#44aa44'; graphicsLow.style.background = '#fff1'; };
    graphicsHigh.click();

    // Hub state
    let scene = null, camera = null, cleanup = null, running = false, selectedLevel = 0;

    // Progression order (after finishing all levels in a game, advance to the next game)
    const gameOrder = ['jungle', 'platformer', 'racer', 'arena', 'runner', 'maze', 'range', 'voxel'];
    const maxLevels = 5;

    let keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Escape') showMenu(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // Shared state (local-only networking: default to LAN server on same hostname)
    const defaultLAN = 'ws://' + window.location.hostname + ':8080';
    const shared = {
      skin: localStorage.getItem('skin') || 'blue',
      name: localStorage.getItem('name') || '',
      server: localStorage.getItem('server') || defaultLAN,
      ws: null,
      id: Math.random().toString(36).slice(2),
      peers: new Map(), // id -> {mesh, label, lastSeen, data}
      currentGame: null,
      owner: localStorage.getItem('owner') === 'true' || false
    };

    playerNameInput.value = shared.name;
    serverUrlInput.value = shared.server;
    netbar.style.display = 'block';

    // Utility: color by skin
    function skinToColor(skin) {
      switch (skin) {
        case 'red': return 0xff4d4d;
        case 'green': return 0x43c86b;
        case 'purple': return 0xaa66ff;
        case 'orange': return 0xff9a3c;
        case 'white': return 0xf0f0f0;
        case 'black': return 0x222222;
        case 'yellow': return 0xffd84d;
        default: return 0x4da3ff; // blue
      }
    }

    // Owner cosmetic: billboard text “OWNER”
    function makeOwnerLabel() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ff3b3b';
      ctx.font = 'bold 60px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('OWNER', canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.4, 1.2, 1);
      sprite.position.set(0, 1.9, 0);
      return sprite;
    }

    // Skins modal
    skinsBtn.onclick = () => { skinsEl.style.display = 'block'; };
    closeSkinsBtn.onclick = () => { skinsEl.style.display = 'none'; };
    skinsEl.addEventListener('click', (e) => {
      if (e.target.classList.contains('swatch')) {
        shared.skin = e.target.dataset.skin;
        localStorage.setItem('skin', shared.skin);
        if (cleanup && cleanup.applySkin) cleanup.applySkin(shared.skin);
        broadcastState();
      }
    });

    // Code input (owner cosmetic)
    applyCodeBtn.onclick = () => {
      const code = codeInput.value.trim().toLowerCase();
      if (code === 'ownercole') {
        shared.owner = true;
        localStorage.setItem('owner', 'true');
        codeStatus.textContent = 'Owner cosmetic unlocked!';
        codeStatus.style.color = '#ff4d4d';
        if (cleanup && cleanup.applyOwner) cleanup.applyOwner(true);
      } else {
        codeStatus.textContent = 'Invalid code';
        codeStatus.style.color = '#ccc';
      }
    };

    // Exit button (web)
    exitBtn.onclick = () => { window.location.href = 'about:blank'; };

    // Levels selection
    document.querySelectorAll('.levelBtn').forEach(b => {
      b.onclick = () => {
        selectedLevel = parseInt(b.dataset.level,10) || 0;
        b.style.background = '#44aa44';
        document.querySelectorAll('.levelBtn').forEach(o => { if (o !== b) o.style.background = '#222a'; });
      };
    });

    // Leaderboard
    leaderboardBtn.onclick = () => { leaderboardEl.style.display = 'block'; refreshLeaderboard(lbGame.value); };
    closeLeaderboardBtn.onclick = () => { leaderboardEl.style.display = 'none'; };
    lbGame.onchange = () => refreshLeaderboard(lbGame.value);
    resetLeaderboardBtn.onclick = () => { localStorage.removeItem('leaderboard'); refreshLeaderboard(lbGame.value); };

    function getLB() {
      const raw = localStorage.getItem('leaderboard');
      return raw ? JSON.parse(raw) : {};
    }
    function setLB(data) { localStorage.setItem('leaderboard', JSON.stringify(data)); }
    function addScore(game, name, score) {
      const lb = getLB();
      if (!lb[game]) lb[game] = [];
      lb[game].push({ name, score, date: new Date().toISOString() });
      lb[game].sort((a,b)=>b.score-a.score);
      lb[game] = lb[game].slice(0, 20);
      setLB(lb);
    }
    function refreshLeaderboard(game) {
      const lb = getLB()[game] || [];
      lbTable.innerHTML = '';
      lb.forEach((row, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${row.name}</td><td>${row.score}</td><td>${new Date(row.date).toLocaleString()}</td>`;
        lbTable.appendChild(tr);
      });
    }

    // Networking (LAN-only default)
    connectBtn.onclick = () => {
      const name = playerNameInput.value.trim();
      const server = serverUrlInput.value.trim();
      shared.name = name || 'Guest';
      shared.server = server || defaultLAN; // default to local hostname
      localStorage.setItem('name', shared.name);
      localStorage.setItem('server', shared.server);
      connectWS();
    };

    function connectWS() {
      try {
        if (shared.ws) { shared.ws.close(); shared.ws = null; }
        const ws = new WebSocket(shared.server);
        shared.ws = ws;
        connStatus.textContent = 'Connecting...';
        ws.onopen = () => { connStatus.textContent = 'Connected'; broadcastState(true); };
        ws.onmessage = (evt) => {
          try { handleNetMessage(JSON.parse(evt.data)); } catch {}
        };
        ws.onclose = () => { connStatus.textContent = 'Disconnected'; };
        ws.onerror = () => { connStatus.textContent = 'Error'; };
      } catch { connStatus.textContent = 'Error'; }
    }

    function handleNetMessage(msg) {
      // {type:'state', id, name, skin, owner, game, x,y,z, yaw, t}
      if (msg.type === 'state' && msg.id && msg.id !== shared.id) {
        if (msg.game !== shared.currentGame || !scene) return;
        let peer = shared.peers.get(msg.id);
        if (!peer) {
          const mesh = createPeerMesh(msg.game, msg.skin, msg.owner);
          scene.add(mesh);
          const label = makeNameLabel(msg.name);
          mesh.add(label);
          peer = { mesh, label, lastSeen: performance.now(), data: msg };
          shared.peers.set(msg.id, peer);
        }
        peer.lastSeen = performance.now();
        peer.data = msg;
        peer.mesh.position.set(msg.x, msg.y, msg.z);
        setPeerYaw(peer.mesh, msg.yaw);
        setPeerSkin(peer.mesh, msg.skin);
        setPeerOwner(peer.mesh, !!msg.owner);
      }
    }

    function makeNameLabel(name) {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 48px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(name || 'Guest', canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.0, 1.0, 1);
      sprite.position.set(0, 1.5, 0);
      return sprite;
    }

    function createPeerMesh(game, skin, owner=false) {
      const color = skinToColor(skin);
      let mesh;
      if (game === 'racer') {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 5), new THREE.MeshStandardMaterial({ color }));
      } else if (game === 'voxel') {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 1), new THREE.MeshStandardMaterial({ color }));
      } else {
        mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), new THREE.MeshStandardMaterial({ color }));
      }
      mesh.userData.isPeer = true;
      if (owner) {
        const ownerSprite = makeOwnerLabel();
        mesh.add(ownerSprite);
      }
      return mesh;
    }
    function setPeerYaw(mesh, yaw) { mesh.rotation.y = yaw || 0; }
    function setPeerSkin(mesh, skin) { const color = skinToColor(skin); if (mesh.material && mesh.material.color) mesh.material.color.setHex(color); }
    function setPeerOwner(mesh, owner) {
      const existing = mesh.children.find(ch => ch.isSprite && ch.material && ch.material.map && ch.material.map.image);
      if (owner && !existing) mesh.add(makeOwnerLabel());
      if (!owner && existing) mesh.remove(existing);
    }
    function broadcastState(initial=false) {
      if (!shared.ws || shared.ws.readyState !== 1 || !cleanup) return;
      const p = cleanup.getLocalState ? cleanup.getLocalState() : null;
      if (!p) return;
      const msg = {
        type: 'state',
        id: shared.id,
        name: shared.name || 'Guest',
        skin: shared.skin,
        owner: shared.owner,
        game: shared.currentGame || '',
        x: p.pos.x, y: p.pos.y, z: p.pos.z,
        yaw: p.yaw || 0,
        t: Date.now(),
        initial
      };
      try { shared.ws.send(JSON.stringify(msg)); } catch {}
    }

    // Clean old peers periodically
    setInterval(() => {
      const now = performance.now();
      for (const [id, peer] of shared.peers) {
        if (now - peer.lastSeen > 8000) {
          if (scene) scene.remove(peer.mesh);
          shared.peers.delete(id);
        }
      }
    }, 4000);

    // Show/hide
    function showMenu() {
      running = false;
      hud.style.display = 'none';
      settingsBar.style.display = 'none';
      controls.style.display = 'none';
      msg.style.display = 'none';
      shopEl.style.display = 'none';
      skinsEl.style.display = 'none';
      leaderboardEl.style.display = 'none';
      menu.style.display = 'grid';
      if (cleanup && cleanup.dispose) cleanup.dispose();
      if (scene) { for (const [, peer] of shared.peers) scene.remove(peer.mesh); }
      shared.peers.clear();
      cleanup = null; scene = null; camera = null;
      netbar.style.display = 'block';
    }
    function startGame(setup, gameKey, levelIdx) {
      if (cleanup && cleanup.dispose) cleanup.dispose();
      cleanup = setup(quality, shared.skin, levelIdx, shared.owner);
      scene = cleanup.scene; camera = cleanup.camera;
      shared.currentGame = gameKey;
      running = true;
      hud.style.display = 'block';
      backBtn.style.display = 'inline-block';
      controls.style.display = 'flex';
      settingsBar.style.display = 'flex';
      netbar.style.display = 'block';
      menu.style.display = 'none';
      if (cleanup.applySkin) cleanup.applySkin(shared.skin);
      if (cleanup.applyOwner) cleanup.applyOwner(shared.owner);
      // Attach progression hooks
      cleanup.nextLevel = () => advanceLevel(gameKey, levelIdx + 1);
      cleanup.nextGame = () => advanceToNextGame(gameKey);
      broadcastState(true);
    }

    function advanceLevel(gameKey, nextIndex) {
      if (nextIndex < maxLevels) {
        startGame(gameSetups[gameKey], gameKey, nextIndex);
      } else {
        // Finished all levels in this game: move to next game
        advanceToNextGame(gameKey);
      }
    }

    function advanceToNextGame(current) {
      const idx = gameOrder.indexOf(current);
      const nextGame = gameOrder[(idx + 1) % gameOrder.length];
      startGame(gameSetups[nextGame], nextGame, 0);
    }

    document.querySelectorAll('.menuBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const game = btn.dataset.game;
        startGame(gameSetups[game], game, selectedLevel);
      });
    });

    // Shop minimal behavior
    shopBtn.onclick = () => { shopEl.style.display = 'block'; };
    closeShopBtn.onclick = () => { shopEl.style.display = 'none'; };
    shopEl.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON' || e.target.id === 'closeShop') return;
      const cost = parseInt(e.target.dataset.cost || '0', 10);
      if (cleanup && cleanup.getCurrency && cleanup.setCurrency) {
        const coins = cleanup.getCurrency();
        if (cost > coins) { alert('Not enough currency'); return; }
        if (cost > 0) cleanup.setCurrency(coins - cost);
      }
      const type = e.target.dataset.type;
      if (type === 'weapon' && cleanup.applyWeaponUpgrade) cleanup.applyWeaponUpgrade();
      if (type === 'mapNight' && cleanup.applyMapVariant) cleanup.applyMapVariant('night');
      if (type === 'mapDay' && cleanup.applyMapVariant) cleanup.applyMapVariant('day');
    });

    // Camera helpers (third person only)
    function updateThirdPersonCamera(cam, playerPos, yaw, pitch=0, dist=6.5, height=2.6) {
      const h = height + Math.sin(pitch) * 0.5;
      const offset = new THREE.Vector3(Math.sin(yaw) * dist, h, -Math.cos(yaw) * dist);
      cam.position.copy(playerPos).add(offset);
      cam.lookAt(playerPos.x, playerPos.y + 1.0, playerPos.z);
    }
    function getCameraBasisXZ(cam, center) {
      const forward = new THREE.Vector3().subVectors(center, cam.position);
      forward.y = 0; if (forward.lengthSq() < 1e-6) forward.set(0,0,-1);
      forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
      return { forward, right };
    }
    function getLookDelta(mult=1.8) { const ls = lookStick.get(); return { lx: ls.x * mult, ly: ls.y * mult }; }
    function getMoveInput(keys, mv) {
      let inputX = mv.x, inputY = -mv.y;
      const kForward = (keys.KeyW || keys.ArrowUp) ? 1 : 0;
      const kBack = (keys.KeyS || keys.ArrowDown) ? 1 : 0;
      const kLeft = (keys.KeyA || keys.ArrowLeft) ? 1 : 0;
      const kRight = (keys.KeyD || keys.ArrowRight) ? 1 : 0;
      inputX += (kRight - kLeft); inputY += (kForward - kBack);
      const mag = Math.hypot(inputX, inputY); if (mag > 1) { inputX /= mag; inputY /= mag; }
      return { inputX, inputY };
    }

    // Lights
    function makeLights(env) {
      const group = new THREE.Group();
      if (env === 'day') {
        const hemi = new THREE.HemisphereLight(0xffffff, 0x228822, 1.0);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5); sun.position.set(20, 40, 10);
        group.add(hemi, sun);
      } else if (env === 'space') {
        const amb = new THREE.AmbientLight(0x8888aa, 0.9);
        const key = new THREE.DirectionalLight(0xffffff, 0.7); key.position.set(15, 25, -10);
        group.add(amb, key);
      } else if (env === 'maze') {
        const amb = new THREE.AmbientLight(0x6666ff, 0.6);
        const key = new THREE.PointLight(0x88aaff, 1.0, 200); key.position.set(0, 20, 0);
        group.add(amb, key);
      }
      return group;
    }

    // Level data (5 levels each)
    const jungleLevels = [
      { trees: 12, coins: 8, kits: 3, lavaSpeed: 0.015, enemyRate: 1.2 },
      { trees: 16, coins: 10, kits: 3, lavaSpeed: 0.020, enemyRate: 1.0 },
      { trees: 22, coins: 12, kits: 4, lavaSpeed: 0.024, enemyRate: 0.9 },
      { trees: 26, coins: 14, kits: 5, lavaSpeed: 0.028, enemyRate: 0.8 },
      { trees: 30, coins: 16, kits: 6, lavaSpeed: 0.032, enemyRate: 0.7 },
    ];
    const platformerLevels = [
      { moveSpeed: 9, jumpVel: 16, layoutScale: 1.0 },
      { moveSpeed: 10, jumpVel: 16.5, layoutScale: 1.05 },
      { moveSpeed: 11, jumpVel: 17, layoutScale: 1.1 },
      { moveSpeed: 12, jumpVel: 17.2, layoutScale: 1.15 },
      { moveSpeed: 13, jumpVel: 17.5, layoutScale: 1.2 },
    ];
    const racerLevels = [
      { gates: 10, speedMul: 1.0 }, { gates: 12, speedMul: 1.05 }, { gates: 14, speedMul: 1.1 }, { gates: 16, speedMul: 1.15 }, { gates: 18, speedMul: 1.2 }
    ];
    const arenaLevels = [
      { drones: 8 }, { drones: 12 }, { drones: 16 }, { drones: 20 }, { drones: 24 }
    ];
    const runnerLevels = [
      { obstacles: 16, accel: 1.0 }, { obstacles: 20, accel: 1.1 }, { obstacles: 24, accel: 1.2 }, { obstacles: 28, accel: 1.3 }, { obstacles: 32, accel: 1.4 }
    ];
    const mazeLevels = [
      { walls: 12 }, { walls: 16 }, { walls: 20 }, { walls: 24 }, { walls: 28 }
    ];
    const rangeLevels = [
      { targets: 8, respawn: 1.2 }, { targets: 10, respawn: 1.0 }, { targets: 12, respawn: 0.9 }, { targets: 14, respawn: 0.8 }, { targets: 16, respawn: 0.7 }
    ];
    const voxelLevels = [
      { size: 16, startBlocks: 60 }, { size: 18, startBlocks: 80 }, { size: 20, startBlocks: 100 }, { size: 22, startBlocks: 120 }, { size: 24, startBlocks: 140 }
    ];

    // GAME SETUPS (map names to setup functions for progression)
    const gameSetups = {
      jungle: setupJungleTP,
      platformer: setupPlatformerTP,
      racer: setupRacerTP,
      arena: setupArenaTP,
      runner: setupRunnerTP,
      maze: setupMazeTP,
      range: setupRangeTP,
      voxel: setupVoxelTP
    };

    // GAME 1: Jungle
    function setupJungleTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = jungleLevels[levelIndex] || jungleLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(140, 140), new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      function addTree(x, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 2.2, 10), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
        trunk.position.set(x, 1.1, z);
        const foliage = new THREE.Mesh(new THREE.SphereGeometry(1.3, 18, 18), new THREE.MeshStandardMaterial({ color: 0x006400 }));
        foliage.position.set(x, 2.6, z);
        sc.add(trunk, foliage);
      }
      for (let i = 0; i < lvl.trees; i++) { const a = Math.random() * Math.PI * 2, d = 12 + Math.random() * 55; addTree(Math.cos(a) * d, Math.sin(a) * d); }

      const playerRadius = 0.5;
      const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.6, 8, 16), playerMat);
      player.position.set(0, playerRadius + 0.3, 0); sc.add(player);
      if (ownerFlag) player.add(makeOwnerLabel());

      const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.12), new THREE.MeshStandardMaterial({ color: 0x885000 }));
      weapon.position.set(0.45, 0.35, 0.0); player.add(weapon);

      const lava = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 0.3, 48, 1, true),
        new THREE.MeshStandardMaterial({ color: 0xff3c00, emissive: 0xff2200, emissiveIntensity: 0.95 }));
      lava.position.y = -2.5; sc.add(lava);

      const enemies = [];
      function createMonkey() {
        const g = new THREE.Group();
        const m = new THREE.MeshStandardMaterial({ color: 0x7a4b2a });
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), m);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), m); head.position.set(0, 0.52, 0.02);
        const earL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), m); earL.position.set(-0.22, 0.58, 0.02);
        const earR = earL.clone(); earR.position.x = 0.22;
        g.add(body, head, earL, earR); return g;
      }
      function spawnEnemy() {
        const e = createMonkey();
        const a = Math.random() * Math.PI * 2, d = 16 + Math.random() * 14;
        e.position.set(Math.cos(a) * d, 0.45, Math.sin(a) * d);
        e.userData.speed = 5.9 + Math.random() * 0.8;
        enemies.push(e); sc.add(e);
      }
      let run = true;
      let spawnTimer = setInterval(() => { if (run) spawnEnemy(); }, 1000 * lvl.enemyRate);

      const coins = [], medkits = []; let coinCount = 0;
      function coin() { const c = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 24), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
        c.rotation.x = Math.PI / 2; c.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110); coins.push(c); sc.add(c); }
      function medkit() { const m = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.5), new THREE.MeshStandardMaterial({ color: 0xFF0000 }));
        m.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110); medkits.push(m); sc.add(m); }
      for (let i = 0; i < lvl.coins; i++) coin();
      for (let i = 0; i < lvl.kits; i++) medkit();

      let health = 100, start = performance.now();
      const velocity = new THREE.Vector3();
      const accelGround = 16, accelAir = 6, friction = 12, maxSpeed = 7.2, gravity = 18, jumpStrength = 14.5;
      let onGround = true;
      let yaw = 0, pitch = 0;

      hudPrimary.textContent = `Jungle — Level ${levelIndex+1}`;
      hudSecondary.textContent = 'Health 100 | Coins 0';

      let attacking = false, attackStart = 0;
      const attackDuration = 200;
      let attackRange = 1.4;
      const attackArcCos = Math.cos(Math.PI / 3);

      function startAttack() {
        if (attacking || !run) return;
        attacking = true; attackStart = performance.now();
        weapon.rotation.z = -Math.PI * 0.35;
        const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
        const p = player.position.clone();
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const to = new THREE.Vector3().subVectors(e.position, p);
          const dist = to.length(); if (dist > attackRange) continue;
          to.normalize(); const dot = to.dot(forward);
          if (dot >= attackArcCos) { sc.remove(e); enemies.splice(i, 1); }
        }
        setTimeout(() => { attacking = false; weapon.rotation.z = 0; }, attackDuration);
      }
      actionBtn.onclick = startAttack;
      jumpBtn.onclick = () => { if (onGround && run) velocity.y = jumpStrength; };

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x0a1020);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x1c3a1c);
        } else {
          sc.background = new THREE.Color(0x87ceeb);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0x228B22);
        }
      }
      applyMapVariant('day');

      function applySkin(newSkin) { playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) {
        const existing = player.children.find(ch => ch.isSprite);
        if (flag && !existing) player.add(makeOwnerLabel());
        if (!flag && existing) player.remove(existing);
      }

      function restart() {
        health = 100; coinCount = 0; start = performance.now();
        velocity.set(0, 0, 0); player.position.set(0, playerRadius + 0.3, 0);
        yaw = 0; pitch = 0; lava.position.y = -2.5;
        enemies.forEach(e => sc.remove(e)); enemies.length = 0;
        coins.forEach(c => sc.remove(c)); coins.length = 0;
        medkits.forEach(m => sc.remove(m)); medkits.length = 0;
        for (let i = 0; i < lvl.coins; i++) coin();
        for (let i = 0; i < lvl.kits; i++) medkit();
        run = true; msg.style.display = 'none';
        hudSecondary.textContent = 'Health 100 | Coins 0';
      }
      function dispose() { clearInterval(spawnTimer); }

      return {
        scene: sc, camera: cam, restart, dispose,
        getCurrency: () => coinCount, setCurrency: v => { coinCount = v; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`; },
        applyMapVariant, applySkin, applyOwner,
        applyWeaponUpgrade: () => { attackRange = 1.8; weapon.scale.set(1.1, 1.3, 1.1); },
        getLocalState: () => ({ pos: player.position, yaw }),
        update(dt, now) {
          if (!run) return;
          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 7.0, 2.6);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, player.position);
          const wishdir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (wishdir.lengthSq() > 0) wishdir.normalize();
          const accel = onGround ? accelGround : accelAir;
          velocity.addScaledVector(wishdir, accel * dt);

          if (onGround && Math.hypot(inputX, inputY) < 0.05) {
            const horiz = new THREE.Vector2(velocity.x, velocity.z);
            const speed = horiz.length();
            const drop = friction * dt;
            const newSpeed = Math.max(speed - drop, 0);
            if (speed > 0) { horiz.multiplyScalar(newSpeed / speed); velocity.x = horiz.x; velocity.z = horiz.y; }
          }

          const horiz = new THREE.Vector2(velocity.x, velocity.z);
          const speed = horiz.length(); if (speed > maxSpeed) { horiz.multiplyScalar(maxSpeed / speed); velocity.x = horiz.x; velocity.z = horiz.y; }

          velocity.y -= gravity * dt;
          player.position.addScaledVector(velocity, dt);

          const groundY = playerRadius + 0.3;
          if (player.position.y < groundY) { player.position.y = groundY; velocity.y = 0; onGround = true; } else onGround = false;

          if (!attacking) { weapon.rotation.x = Math.sin(now * 0.004) * 0.08; weapon.rotation.z = 0; }
          else { const t = Math.min((performance.now() - attackStart) / attackDuration, 1); weapon.rotation.x = -0.2; weapon.rotation.z = -Math.PI * 0.35 + Math.sin(t * Math.PI) * 0.5; }

          lava.position.y += lvl.lavaSpeed * dt;

          const bob = Math.sin(now * 0.004) * 0.02;
          for (let i = 0; i < enemies.length; i++) {
            const e = enemies[i];
            e.position.y = 0.45 + bob;
            const toP = new THREE.Vector3().subVectors(player.position, e.position);
            const d = toP.length(); if (d > 0.0001) toP.normalize();
            e.position.addScaledVector(toP, e.userData.speed * dt);
            if (d < 0.85) { health -= 18 * dt; if (health < 0) health = 0; }
          }

          for (let i = coins.length - 1; i >= 0; i--) {
            const c = coins[i];
            if (c.position.distanceTo(player.position) < 0.8) { coinCount += 1; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`; sc.remove(c); coins.splice(i, 1); }
          }
          for (let i = medkits.length - 1; i >= 0; i--) {
            const m = medkits[i];
            if (m.position.distanceTo(player.position) < 0.9) { health = Math.min(100, health + 25); hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`; sc.remove(m); medkits.splice(i, 1); }
          }

          const feet = player.position.y - groundY;
          const lavaTop = lava.position.y + 0.15;
          if (feet <= lavaTop || health <= 0) {
            run = false; msgText.textContent = `Game Over — Jungle (Lvl ${levelIndex+1})`; msg.style.display = 'block';
            addScore('jungle', shared.name || 'Guest', Math.round(coinCount));
          }

          // win condition: survive X seconds? For simplicity, coins collected target:
          if (coinCount >= lvl.coins) {
            run = false;
            addScore('jungle', shared.name || 'Guest', coinCount);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          hudPrimary.textContent = `Jungle — Level ${levelIndex+1}`;
          hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;

          broadcastState();
        }
      };
    }

    // GAME 2: Platformer (double jump)
    function setupPlatformerTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = platformerLevels[levelIndex] || platformerLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87b3ff);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const platMat = new THREE.MeshStandardMaterial({ color: 0x6aa86a, roughness: 0.8 });
      const plats = [];
      function platform(w, h, d, x, y, z) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), platMat);
        p.position.set(x * lvl.layoutScale, y * lvl.layoutScale, z * lvl.layoutScale); sc.add(p); plats.push(p);
      }
      const baseY = 0;
      platform(40, 2, 12, 0, baseY, 0);
      platform(12, 2, 12, 28, baseY + 8, -6);
      platform(16, 2, 12, 48, baseY + 16, 8);
      platform(10, 2, 10, 66, baseY + 24, 0);
      platform(14, 2, 12, 86, baseY + 30, -10);
      platform(20, 2, 12, 110, baseY + 34, 6);

      const goal = new THREE.Mesh(new THREE.TorusKnotGeometry(3, 1, 90, 12), new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0x553300, emissiveIntensity: 0.3 }));
      goal.position.set(120 * lvl.layoutScale, baseY + 40 * lvl.layoutScale, 6 * lvl.layoutScale); sc.add(goal);

      const playerRadius = 0.6;
      const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.8, 8, 12), playerMat);
      player.visible = true; player.position.set(-16, baseY + 6, 0); sc.add(player);
      if (ownerFlag) player.add(makeOwnerLabel());

      const vel = new THREE.Vector3(0, 0, 0);
      const gravity = 18, moveSpeed = lvl.moveSpeed, jumpVel = lvl.jumpVel;
      let onGround = false, run = true, won = false, yaw = 0, pitch = 0, jumpsLeft = 2;

      hudPrimary.textContent = `Sky Platforms — Level ${levelIndex+1}`;
      hudSecondary.textContent = 'Reach the glowing goal (Double jump)';

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x0a2030);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          platMat.color.set(0x355a35);
        } else {
          sc.background = new THREE.Color(0x87b3ff);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          platMat.color.set(0x6aa86a);
        }
      }
      applyMapVariant('day');
      function applySkin(newSkin) { playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) {
        const existing = player.children.find(ch => ch.isSprite);
        if (flag && !existing) player.add(makeOwnerLabel());
        if (!flag && existing) player.remove(existing);
      }

      function tryJump() {
        if (!run) return;
        if (onGround) { vel.y = jumpVel; jumpsLeft = 1; onGround = false; }
        else if (jumpsLeft > 0) { vel.y = jumpVel * 0.95; jumpsLeft = 0; }
      }
      jumpBtn.onclick = tryJump;
      window.addEventListener('keydown', e => { if (e.code === 'Space') tryJump(); });

      function collide() {
        onGround = false;
        for (const p of plats) {
          const top = p.position.y + p.geometry.parameters.height / 2;
          const halfW = p.geometry.parameters.width / 2;
          const halfD = p.geometry.parameters.depth / 2;
          const withinX = (player.position.x > p.position.x - halfW - playerRadius) && (player.position.x < p.position.x + halfW + playerRadius);
          const withinZ = (player.position.z > p.position.z - halfD - playerRadius) && (player.position.z < p.position.z + halfD + playerRadius);
          const nearTop = Math.abs(player.position.y - (top + playerRadius)) < 0.6 && vel.y <= 0;
          if (withinX && withinZ && nearTop) {
            player.position.y = top + playerRadius;
            vel.y = 0; onGround = true; jumpsLeft = 2;
          }
        }
        if (player.position.y < -30) {
          run = false;
          msgText.textContent = `You fell — Platformer (Lvl ${levelIndex+1})`;
          msg.style.display = 'block';
          addScore('platformer', shared.name || 'Guest', Math.max(1, 100 - levelIndex * 10));
        }
      }

      function restart() { player.position.set(-16, baseY + 6, 0); vel.set(0, 0, 0); yaw = 0; pitch = 0; won = false; run = true; msg.style.display = 'none'; jumpsLeft = 2; }

      return {
        scene: sc, camera: cam, restart, dispose() {},
        getCurrency: () => 0, setCurrency: () => {}, applyMapVariant, applySkin, applyOwner,
        applyWeaponUpgrade: () => {}, getLocalState: () => ({ pos: player.position, yaw }),
        update(dt) {
          if (!run || won) return;
          const { lx, ly } = getLookDelta(1.8); yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 7.0, 2.6);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, player.position);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (dir.lengthSq() > 0) dir.normalize();

          vel.x = THREE.MathUtils.lerp(vel.x, dir.x * moveSpeed, 8 * dt);
          vel.z = THREE.MathUtils.lerp(vel.z, dir.z * moveSpeed, 8 * dt);
          vel.y -= gravity * dt;

          player.position.addScaledVector(vel, dt);
          collide();

          if (player.position.distanceTo(goal.position) < 5) {
            won = true;
            addScore('platformer', shared.name || 'Guest', 1000 - levelIndex * 50);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          hudPrimary.textContent = `Sky Platforms — Level ${levelIndex+1}`;
          hudSecondary.textContent = onGround ? 'On platform (Double jump ready)' : (jumpsLeft > 0 ? 'Air (Double jump available)' : 'Air');

          broadcastState();
        }
      };
    }

    // GAME 3: Racer
    function setupRacerTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = racerLevels[levelIndex] || racerLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0xd0b38a);
      const cam = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1200);
      const lights = makeLights('day'); sc.add(lights);
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshStandardMaterial({ color: 0xb5894a, roughness: 0.8 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      const carMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const car = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 5), carMat);
      car.position.set(0, 0.6, 0); sc.add(car);
      if (ownerFlag) car.add(makeOwnerLabel());

      const gates = [];
      function gate(x, z) {
        const g = new THREE.Mesh(new THREE.TorusGeometry(4, 0.3, 12, 24), new THREE.MeshStandardMaterial({ color: 0xffee88 }));
        g.position.set(x, 2.5, z); sc.add(g); gates.push(g);
      }
      for (let i = 0; i < lvl.gates; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);

      let speed = 0, heading = 0, score = 0, run = true, yaw = 0, pitch = 0;

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x302018);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x8b6a3a);
        } else {
          sc.background = new THREE.Color(0xd0b38a);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0xb5894a);
        }
      }
      applyMapVariant('day');
      function applySkin(newSkin) { carMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) { const existing = car.children.find(ch => ch.isSprite); if (flag && !existing) car.add(makeOwnerLabel()); if (!flag && existing) car.remove(existing); }

      hudPrimary.textContent = `Desert Racer — Level ${levelIndex+1}`;
      hudSecondary.textContent = `Gates 0/${lvl.gates}`;

      function restart() {
        car.position.set(0, 0.6, 0);
        speed = 0; heading = 0; score = 0; run = true; msg.style.display = 'none';
        gates.forEach(g => sc.remove(g)); gates.length = 0;
        for (let i = 0; i < lvl.gates; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);
        hudSecondary.textContent = `Gates 0/${lvl.gates}`;
      }

      return {
        scene: sc, camera: cam, restart, dispose() {},
        getCurrency: () => score, setCurrency: v => { score = v; hudSecondary.textContent = `Gates ${score}/${lvl.gates}`; },
        applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: car.position, yaw: heading }),
        update(dt) {
          if (!run) return;
          const { lx, ly } = getLookDelta(0.8); yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.5, 0.5);

          const mv = moveStick.get();
          const steer = mv.x;
          const throttle = Math.max(0, -mv.y);
          const brake = Math.max(0, mv.y);

          speed += ((throttle * 22 * lvl.speedMul) - (brake * 28) - speed * 0.85) * dt;
          heading += steer * 1.8 * dt;

          const dir = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
          car.position.addScaledVector(dir, speed * dt);
          car.rotation.y = heading;

          updateThirdPersonCamera(cam, car.position, heading, pitch, 9.0, 3.2);

          for (let i = gates.length - 1; i >= 0; i--) {
            const g = gates[i];
            if (car.position.distanceTo(g.position) < 4) { score++; sc.remove(g); gates.splice(i, 1); hudSecondary.textContent = `Gates ${score}/${lvl.gates}`; }
          }

          if (gates.length === 0) {
            run = false;
            addScore('racer', shared.name || 'Guest', Math.round(speed*10));
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }
          hudPrimary.textContent = `Speed ${speed.toFixed(1)}`;

          broadcastState();
        }
      };
    }

    // GAME 4: Arena
    function setupArenaTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = arenaLevels[levelIndex] || arenaLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x080a12);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('space'); sc.add(lights);
      const arena = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 2, 40), new THREE.MeshStandardMaterial({ color: 0x1c2233, metalness: 0.2, roughness: 0.7 }));
      arena.position.y = -2; sc.add(arena);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(0, 1, 0); sc.add(rig);
      if (ownerFlag) rig.add(makeOwnerLabel());

      const drones = [];
      function drone() {
        const d = new THREE.Mesh(new THREE.TetrahedronGeometry(1.2), new THREE.MeshStandardMaterial({ color: 0xff6666 }));
        const a = Math.random() * Math.PI * 2, r = 40;
        d.position.set(Math.cos(a) * r, 1.2, Math.sin(a) * r);
        d.userData.vel = new THREE.Vector3((Math.random() - 0.5) * 4, 0, (Math.random() - 0.5) * 4);
        sc.add(d); drones.push(d);
      }
      for (let i = 0; i < lvl.drones; i++) drone();

      const bullets = [];
      const bulletSpeed = 40;
      function shoot() {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444400 }));
        const dir = new THREE.Vector3().subVectors(rig.position, cam.position);
        dir.y = 0; if (dir.lengthSq() < 1e-6) dir.set(0,0,-1); dir.normalize();
        b.position.copy(cam.position);
        b.userData.dir = dir.clone();
        sc.add(b); bullets.push(b);
      }
      actionBtn.onclick = shoot;

      let run = true, score = 0, yaw = 0, pitch = 0;

      hudPrimary.textContent = `Space Arena — Level ${levelIndex+1}`;
      hudSecondary.textContent = 'Score 0 | ACTION to shoot';

      function applyMapVariant(variant) { sc.background = (variant === 'night') ? new THREE.Color(0x04060c) : new THREE.Color(0x080a12); }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) { const existing = rig.children.find(ch => ch.isSprite); if (flag && !existing) rig.add(makeOwnerLabel()); if (!flag && existing) rig.remove(existing); }

      function restart() {
        drones.forEach(d => sc.remove(d)); drones.length = 0;
        bullets.forEach(b => sc.remove(b)); bullets.length = 0;
        for (let i = 0; i < lvl.drones; i++) drone();
        score = 0; hudSecondary.textContent = 'Score 0 | ACTION to shoot';
        rig.position.set(0, 1, 0); yaw = 0; pitch = 0; run = true; msg.style.display = 'none';
      }

      return {
        scene: sc, camera: cam, restart, dispose() {},
        getCurrency: () => score, setCurrency: v => { score = v; hudSecondary.textContent = `Score ${score} | ACTION to shoot`; },
        applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;
          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);
          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, rig.position);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (dir.lengthSq() > 0) dir.normalize();
          rig.position.addScaledVector(dir, 10 * dt);

          for (const d of drones) {
            d.position.addScaledVector(d.userData.vel, dt);
            if (d.position.length() > 78) d.userData.vel.multiplyScalar(-1);
          }

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.addScaledVector(b.userData.dir, bulletSpeed * dt);
            if (b.position.length() > 120) { sc.remove(b); bullets.splice(i, 1); continue; }
            for (let j = drones.length - 1; j >= 0; j--) {
              const d = drones[j];
              if (b.position.distanceTo(d.position) < 1.4) {
                sc.remove(d); drones.splice(j, 1);
                sc.remove(b); bullets.splice(i, 1);
                score++; hudSecondary.textContent = `Score ${score} | ACTION to shoot`;
                break;
              }
            }
          }

          if (drones.length === 0) {
            run = false;
            addScore('arena', shared.name || 'Guest', score);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          broadcastState();
        }
      };
    }

    // GAME 5: Runner
    function setupRunnerTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = runnerLevels[levelIndex] || runnerLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 60), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      ground.rotation.x = -Math.PI / 2; ground.position.z = -40; sc.add(ground);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(0, 1, 0); sc.add(rig);
      if (ownerFlag) rig.add(makeOwnerLabel());

      const obstacles = [];
      function makeObs(z) {
        const o = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x884444 }));
        o.position.set((Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2, 0.6, -z);
        sc.add(o); obstacles.push(o);
      }
      for (let i = 0; i < lvl.obstacles; i++) makeObs(6 + i * 6);

      let laneX = 0, speed = 8, time = 0, run = true, rings = 0, yaw = 0, pitch = 0;

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x102020);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x1c3a1c);
        } else {
          sc.background = new THREE.Color(0x87ceeb);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0x228B22);
        }
      }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) { const existing = rig.children.find(ch => ch.isSprite); if (flag && !existing) rig.add(makeOwnerLabel()); if (!flag && existing) rig.remove(existing); }

      hudPrimary.textContent = `Endless Runner — Level ${levelIndex+1}`;
      hudSecondary.textContent = 'Rings 0';

      return {
        scene: sc, camera: cam,
        restart() {
          obstacles.forEach(o => sc.remove(o)); obstacles.length = 0;
          for (let i = 0; i < lvl.obstacles; i++) makeObs(6 + i * 6);
          laneX = 0; speed = 8; time = 0; rings = 0; run = true; msg.style.display = 'none';
          rig.position.set(0, 1, 0);
          hudSecondary.textContent = 'Rings 0';
        },
        dispose() {},
        getCurrency: () => rings, setCurrency: v => { rings = v; hudSecondary.textContent = `Rings ${rings}`; },
        applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;
          time += dt;
          speed = 8 + time * (1.2 * lvl.accel);

          const { lx, ly } = getLookDelta(1.5);
          yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.4, 0.4);

          const mv = moveStick.get();
          if (mv.x < -0.3) laneX = -2;
          else if (mv.x > 0.3) laneX = 2;
          else laneX = 0;

          rig.position.x = THREE.MathUtils.lerp(rig.position.x, laneX, 6 * dt);

          for (const o of obstacles) {
            o.position.z += speed * dt;
            if (o.position.z > 4) {
              o.position.z = -180 - Math.random() * 40;
              o.position.x = (Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2;
              rings++; hudSecondary.textContent = `Rings ${rings}`;
            }
            const dist = new THREE.Vector3(o.position.x - rig.position.x, 0, o.position.z).length();
            if (dist < 1.0) {
              run = false;
              msgText.textContent = `Hit obstacle — Runner (Lvl ${levelIndex+1})`;
              msg.style.display = 'block';
              addScore('runner', shared.name || 'Guest', rings);
            }
          }

          // Level complete condition: collect N rings
          if (rings >= 10 + levelIndex * 5) {
            run = false;
            addScore('runner', shared.name || 'Guest', rings);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);
          hudPrimary.textContent = `Speed ${speed.toFixed(1)}`;

          broadcastState();
        }
      };
    }

    // GAME 6: Maze
    function setupMazeTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = mazeLevels[levelIndex] || mazeLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x101424);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('maze'); sc.add(lights);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(160, 160), new THREE.MeshStandardMaterial({ color: 0x222a44, roughness: 0.9 }));
      floor.rotation.x = -Math.PI / 2; sc.add(floor);

      const walls = [];
      function wall(x, y, z, sx, sy, sz) {
        const w = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), new THREE.MeshStandardMaterial({ color: 0x3a64a6, emissive: 0x0a1530, emissiveIntensity: 0.2 }));
        w.position.set(x, y, z); sc.add(w); walls.push(w);
      }
      for (let k = 0; k < lvl.walls; k++) {
        const wx = -70 + Math.floor(Math.random() * 8) * 20;
        const wz = -70 + Math.floor(Math.random() * 8) * 20;
        if (Math.random() < 0.5) wall(wx, 1.5, wz, 20, 3, 2);
        else wall(wx, 1.5, wz, 2, 3, 20);
      }

      const exit = new THREE.Mesh(new THREE.TorusGeometry(3, 0.3, 12, 32), new THREE.MeshStandardMaterial({ color: 0x88ffcc }));
      exit.position.set(60, 2.5, 60); sc.add(exit);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(-60, 0.9, -60); sc.add(rig);
      if (ownerFlag) rig.add(makeOwnerLabel());

      let yaw = 0, pitch = 0, run = true;

      hudPrimary.textContent = `Crystal Maze — Level ${levelIndex+1}`;
      hudSecondary.textContent = 'Find the exit ring';

      function applyMapVariant(variant) { sc.background = (variant === 'night') ? new THREE.Color(0x0a0d1a) : new THREE.Color(0x101424); }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) { const existing = rig.children.find(ch => ch.isSprite); if (flag && !existing) rig.add(makeOwnerLabel()); if (!flag && existing) rig.remove(existing); }

      function restart() { rig.position.set(-60, 0.9, -60); yaw = 0; pitch = 0; run = true; msg.style.display = 'none'; }

      return {
        scene: sc, camera: cam, restart, dispose() {},
        getCurrency: () => 0, setCurrency: () => {}, applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;
          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.4, 0.4);
          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, rig.position);
          const next = rig.position.clone().addScaledVector(right, inputX * 8 * dt).addScaledVector(forward, inputY * 8 * dt);

          let blocked = false;
          for (const w of walls) {
            const dx = Math.abs(next.x - w.position.x) - w.geometry.parameters.width / 2 - 0.5;
            const dz = Math.abs(next.z - w.position.z) - w.geometry.parameters.depth / 2 - 0.5;
            if (dx < 0 && dz < 0) { blocked = true; break; }
          }
          if (!blocked) rig.position.copy(next);

          if (rig.position.distanceTo(exit.position) < 5) {
            run = false;
            addScore('maze', shared.name || 'Guest', 1000 - levelIndex * 50);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          broadcastState();
        }
      };
    }

    // GAME 7: Range
    function setupRangeTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = rangeLevels[levelIndex] || rangeLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x223344);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 120), new THREE.MeshStandardMaterial({ color: 0x335577 }));
      floor.rotation.x = -Math.PI / 2; sc.add(floor);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(0, 1, 40); sc.add(rig);
      if (ownerFlag) rig.add(makeOwnerLabel());

      const targets = [];
      function spawnTarget() {
        const t = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.25, 10, 20), new THREE.MeshStandardMaterial({ color: 0xffcc55, emissive: 0x553300, emissiveIntensity: 0.2 }));
        t.position.set((Math.random() - 0.5) * 60, 2 + Math.random() * 6, -20 - Math.random() * 30);
        sc.add(t); targets.push(t);
      }
      for (let i = 0; i < lvl.targets; i++) spawnTarget();

      const bullets = [];
      const bulletSpeed = 40;
      function shoot() {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444400 }));
        const dir = new THREE.Vector3().subVectors(rig.position, cam.position);
        dir.y = 0; if (dir.lengthSq() < 1e-6) dir.set(0,0,-1); dir.normalize();
        b.position.copy(cam.position);
        b.userData.dir = dir.clone();
        sc.add(b); bullets.push(b);
      }
      actionBtn.onclick = shoot;

      let yaw = 0, pitch = 0, run = true, score = 0;

      hudPrimary.textContent = `Target Range — Level ${levelIndex+1}`;
      hudSecondary.textContent = 'Score 0 | ACTION to shoot';

      function applyMapVariant(variant) { sc.background = (variant === 'night') ? new THREE.Color(0x162238) : new THREE.Color(0x223344); }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) { const existing = rig.children.find(ch => ch.isSprite); if (flag && !existing) rig.add(makeOwnerLabel()); if (!flag && existing) rig.remove(existing); }

      function restart() {
        bullets.forEach(b => sc.remove(b)); bullets.length = 0;
        targets.forEach(t => sc.remove(t)); targets.length = 0;
        for (let i = 0; i < lvl.targets; i++) spawnTarget();
        rig.position.set(0, 1, 40);
        yaw = 0; pitch = 0; score = 0; hudSecondary.textContent = 'Score 0 | ACTION to shoot';
        run = true; msg.style.display = 'none';
      }

      return {
        scene: sc, camera: cam, restart, dispose() {},
        getCurrency: () => score, setCurrency: v => { score = v; hudSecondary.textContent = `Score ${score} | ACTION to shoot`; },
        applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;
          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);
          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          rig.position.x += mv.x * 6 * dt;
          rig.position.z += -mv.y * 6 * dt;

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.addScaledVector(b.userData.dir, bulletSpeed * dt);
            if (b.position.length() > 160) { sc.remove(b); bullets.splice(i, 1); continue; }
            for (let j = targets.length - 1; j >= 0; j--) {
              const t = targets[j];
              if (b.position.distanceTo(t.position) < 1.2) {
                sc.remove(t); targets.splice(j, 1);
                sc.remove(b); bullets.splice(i, 1);
                score++; hudSecondary.textContent = `Score ${score} | ACTION to shoot`;
                spawnTarget();
                break;
              }
            }
          }

          // Level complete condition: reach score threshold
          if (score >= 6 + levelIndex * 2) {
            run = false;
            addScore('range', shared.name || 'Guest', score);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          broadcastState();
        }
      };
    }

    // GAME 8: Voxel Builder (Minecraft-like, basic)
    function setupVoxelTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = voxelLevels[levelIndex] || voxelLevels[0];
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const lights = makeLights('day'); sc.add(lights);

      // Simple voxel grid
      const size = lvl.size; // width/depth
      const blockSize = 1;
      const groundY = 0;

      // Ground plane
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(size*blockSize, size*blockSize), new THREE.MeshStandardMaterial({ color: 0x88b36a }));
      ground.rotation.x = -Math.PI / 2; ground.position.set(0, groundY, 0); sc.add(ground);

      // Player
      const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 1), playerMat);
      player.position.set(0, 1, 0); sc.add(player);
      if (ownerFlag) player.add(makeOwnerLabel());

      // Block palette
      const palettes = [0x8B4513, 0xaaaaaa, 0x228B22, 0x3366ff, 0xffd84d]; // wood, stone, grass, waterish, sand
      let paletteIndex = 0;

      // Stored blocks
      const blocks = new Map(); // key "x,y,z" -> mesh

      // Seed some blocks
      function key(x,y,z){return `${x},${y},${z}`;}
      function addBlock(x,y,z,color=null){
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(blockSize, blockSize, blockSize), new THREE.MeshStandardMaterial({ color: color ?? palettes[paletteIndex] }));
        mesh.position.set(x, y, z); sc.add(mesh); blocks.set(key(x,y,z), mesh);
      }
      for (let i = 0; i < lvl.startBlocks; i++) {
        const x = Math.floor((Math.random()-0.5)*size), z = Math.floor((Math.random()-0.5)*size), y = 0.5;
        addBlock(x, y, z, 0x88b36a);
      }

      // Place/remove blocks with ACTION/JUMP
      function rayFromCamera() {
        const dir = new THREE.Vector3().subVectors(player.position, cam.position).normalize();
        const origin = cam.position.clone();
        return { origin, dir };
      }
      function findNearestGridHit(maxDist=8) {
        const { origin, dir } = rayFromCamera();
        let best = null, bestDist = Infinity;
        for (const [, mesh] of blocks) {
          const to = new THREE.Vector3().subVectors(mesh.position, origin);
          const proj = to.dot(dir);
          if (proj > 0 && proj < maxDist) {
            const closestPoint = origin.clone().addScaledVector(dir, proj);
            const d = closestPoint.distanceTo(mesh.position);
            if (d < 0.9 && proj < bestDist) { best = mesh; bestDist = proj; }
          }
        }
        return best;
      }
      actionBtn.onclick = () => {
        const hit = findNearestGridHit(8);
        const pos = hit ? hit.position.clone().add(new THREE.Vector3(0, blockSize, 0)) : player.position.clone().add(new THREE.Vector3(0, 0, -2)).round();
        const snap = new THREE.Vector3(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z));
        const k = key(snap.x, snap.y, snap.z);
        if (!blocks.has(k)) addBlock(snap.x, snap.y, snap.z);
      };
      jumpBtn.onclick = () => {
        const hit = findNearestGridHit(8);
        if (hit) { blocks.delete(key(hit.position.x, hit.position.y, hit.position.z)); sc.remove(hit); }
      };
      window.addEventListener('keydown', e => {
        if (e.code === 'KeyQ') { paletteIndex = (paletteIndex + 1) % palettes.length; }
        if (e.code === 'KeyE') { paletteIndex = (paletteIndex + palettes.length - 1) % palettes.length; }
      });

      let yaw = 0, pitch = 0;
      let speed = 6;

      hudPrimary.textContent = `Voxel Builder — Level ${levelIndex+1}`;
      hudSecondary.textContent = `Palette #${paletteIndex+1} (Q/E to cycle)`;

      function applyMapVariant(v) { sc.background = (v === 'night') ? new THREE.Color(0x10202a) : new THREE.Color(0x87ceeb); }
      applyMapVariant('day');
      function applySkin(newSkin) { playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag) { const existing = player.children.find(ch => ch.isSprite); if (flag && !existing) player.add(makeOwnerLabel()); if (!flag && existing) player.remove(existing); }

      function restart() {
        for (const [,mesh] of blocks) sc.remove(mesh);
        blocks.clear();
        for (let i = 0; i < lvl.startBlocks; i++) {
          const x = Math.floor((Math.random()-0.5)*size), z = Math.floor((Math.random()-0.5)*size), y = 0.5;
          addBlock(x, y, z, 0x88b36a);
        }
        player.position.set(0,1,0); yaw=0; pitch=0; msg.style.display='none';
      }

      return {
        scene: sc, camera: cam, restart, dispose() {},
        getCurrency: () => blocks.size, setCurrency: () => {},
        applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: player.position, yaw }),
        update(dt) {
          const { lx, ly } = getLookDelta(1.6);
          yaw += lx * dt; pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.7, 0.7);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, player.position);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (dir.lengthSq() > 0) dir.normalize();
          player.position.addScaledVector(dir, speed * dt);

          hudSecondary.textContent = `Blocks ${blocks.size} | Palette #${paletteIndex+1} (Q/E cycle)`;

          // Level complete condition: reach total block count
          if (blocks.size >= lvl.startBlocks + 10) {
            addScore('voxel', shared.name || 'Guest', blocks.size);
            msgText.textContent = `Level ${levelIndex+1} complete — advancing...`;
            msg.style.display = 'block';
            setTimeout(() => { msg.style.display = 'none'; if (cleanup.nextLevel) cleanup.nextLevel(); }, 1200);
          }

          broadcastState();
        }
      };
    }

    // MAIN LOOP
    let sceneLast = performance.now();
    function loop(now) {
      const dt = Math.min((now - sceneLast) / 1000, 1 / 30); sceneLast = now;
      if (running && cleanup && cleanup.update) cleanup.update(dt, now);
      if (scene && camera) renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Resize
    window.addEventListener('resize', () => {
      if (!camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Back/restart
    backBtn.onclick = () => showMenu();
    restartBtn.onclick = () => { if (cleanup && cleanup.restart) cleanup.restart(); };

    // Start on menu
    showMenu();

    // Tip: Run server.js on your LAN (same Wi‑Fi). Default server uses your local hostname. Enter code “ownercole” to unlock the OWNER cosmetic.
  </script>
</body>
</html>
