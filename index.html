<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>3D Mobile Platformer</title>
<style>
  html, body { margin:0; height:100%; background:#0c1326; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #game { position:fixed; inset:0; }

  #hud { position: fixed; left: 0; right: 0; top: 0; display: flex; gap: 8px; justify-content: space-between; padding: 10px; pointer-events: none; color:#e6e6e6; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
  .panel { background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 12px; }
  #msg { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; color:#fff; background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.15); border-radius: 10px; padding:8px 12px; pointer-events:none; }

  #controls { position: fixed; inset: 0; pointer-events: none; }
  .stick-wrap { position: absolute; width: 160px; height: 160px; pointer-events: auto; touch-action: none; }
  .stick-base, .stick-thumb { position: absolute; border-radius: 50%; }
  .stick-base { width: 160px; height: 160px; background: rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.18); backdrop-filter: blur(4px); }
  .stick-thumb { width: 80px; height: 80px; left: 40px; top: 40px; background: rgba(255,255,255,0.22); border:2px solid rgba(255,255,255,0.3); }
  .btn { position: absolute; right: 24px; bottom: 120px; width: 100px; height: 100px; border-radius: 50%; pointer-events: auto; touch-action: manipulation;
    background: radial-gradient(circle at 30% 30%, #fff 0%, #f6b73c 35%, #e36c1b 60%, #ad3a0a 100%);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 10px rgba(255,255,255,0.4); border: 2px solid rgba(255,255,255,0.5); }
  .btn:active { transform: scale(0.96); }

  #menu { position: fixed; left: 50%; transform: translateX(-50%); bottom: 70px; display: flex; flex-wrap: wrap; gap: 8px; pointer-events: auto; }
  #menu select, #menu button, #menu input {
    padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.35); color:#e6e6e6; backdrop-filter: blur(3px);
  }

  #pauseOverlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); color:#fff; font-size: 20px; font-weight:700; text-align:center; }
  #pauseOverlay .inner { background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.2); padding: 14px 18px; border-radius: 10px; }

  /* Main menu overlay */
  #mainMenu { position: fixed; inset: 0; display: none; background: rgba(0,0,0,0.7); color: #e6e6e6; }
  #mainMenu .wrap { position: absolute; left:50%; top:50%; transform: translate(-50%,-50%); width: min(820px, 92vw); max-height: 80vh; overflow:auto;
    background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 16px; }
  #mainMenu h2 { margin: 0 0 10px; font-weight: 700; }
  .tabs { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
  .tab { padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); cursor: pointer; }
  .tab.active { background: rgba(255,255,255,0.18); }
  .tabpane { display: none; }
  .tabpane.active { display: block; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; }
  .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 10px; }
  .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
  .swatch { width: 26px; height: 26px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.4); cursor: pointer; }
  .closeMenu { position: absolute; right: 12px; top: 12px; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="panel" id="score">Stars: 0 / 0</div>
  <div class="panel" id="level">Level 1</div>
  <div class="panel" id="mode">Mode: Classic</div>
  <div class="panel" id="timer" style="display:none;">Time: 60.0s</div>
  <div class="panel" id="lives" style="display:none;">Lives: 3</div>
</div>
<div id="msg">Collect stars and reach the glowing goal!</div>

<div id="controls">
  <!-- Movement joystick -->
  <div class="stick-wrap" id="moveStick" style="left:24px; bottom:24px;">
    <div class="stick-base"></div>
    <div class="stick-thumb" id="moveThumb"></div>
  </div>
  <!-- Jump button (camera deadzone underneath this area) -->
  <button class="btn" id="jumpBtn" aria-label="Jump"></button>
</div>

<div id="menu">
  <select id="sceneSelect"></select>
  <select id="levelSelect"></select>
  <select id="modeSelect">
    <option value="classic">Classic</option>
    <option value="time">Time Attack</option>
    <option value="survival">Survival</option>
  </select>
  <button id="restartBtn">Restart</button>
  <button id="pauseBtn">Pause</button>
  <button id="toggleViewBtn">Toggle View</button>
  <button id="openMenuBtn">Main Menu</button>
  <input id="codeInput" placeholder="Enter code" />
  <button id="codeApplyBtn">Apply</button>
</div>

<div id="pauseOverlay"><div class="inner">Paused<br/><small>(Tap or press P to resume)</small></div></div>

<!-- Main Menu Overlay -->
<div id="mainMenu">
  <div class="wrap">
    <button class="closeMenu" id="closeMenuBtn">Close</button>
    <h2>Main menu</h2>
    <div class="tabs">
      <div class="tab active" data-tab="levelsTab">Levels</div>
      <div class="tab" data-tab="customTab">Customize</div>
      <div class="tab" data-tab="optionsTab">Options</div>
    </div>
    <div id="levelsTab" class="tabpane active">
      <div class="grid" id="levelsGrid"></div>
    </div>
    <div id="customTab" class="tabpane">
      <div class="card">
        <h3>Character customization</h3>
        <div class="row">
          <div>Color:</div>
          <div class="swatch" data-color="#f0f3f8" style="background:#f0f3f8"></div>
          <div class="swatch" data-color="#ff9aa2" style="background:#ff9aa2"></div>
          <div class="swatch" data-color="#9ad1ff" style="background:#9ad1ff"></div>
          <div class="swatch" data-color="#a3ffb0" style="background:#a3ffb0"></div>
          <div class="swatch" data-color="#ffd54f" style="background:#ffd54f"></div>
        </div>
        <div class="row">
          <label><input type="checkbox" id="hatToggle"/> Hat accessory</label>
          <label><input type="checkbox" id="trailToggle"/> Sparkle trail</label>
        </div>
      </div>
    </div>
    <div id="optionsTab" class="tabpane">
      <div class="card">
        <h3>Gameplay</h3>
        <div class="row">
          <label><input type="checkbox" id="doubleJumpToggle" checked/> Enable double jump</label>
        </div>
        <div class="row">
          <label>Camera sensitivity
            <input type="range" id="camSens" min="1.0" max="6.0" step="0.1" value="3.5"/>
          </label>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
<script>
(() => {
  // Renderer, scene, camera
  const canvas = document.getElementById('game');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0c1326);
  scene.fog = new THREE.Fog(0x0c1326, 50, 140);

  const camera = new THREE.PerspectiveCamera(62, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 10);

  // Lighting
  const hemi = new THREE.HemisphereLight(0x9bd4ff, 0x12131a, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xfff1e4, 1.0);
  sun.position.set(12, 16, 10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  scene.add(sun);

  // Ground + props (visual richness)
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x182235, roughness: 0.95 });
  const ground = new THREE.Mesh(new THREE.CircleGeometry(80, 64), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  const pillarMat = new THREE.MeshStandardMaterial({ color: 0x283b5e, roughness: 0.8 });
  for (let i=0;i<12;i++){
    const h = 2 + Math.random()*4;
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,h,24), pillarMat);
    const r = 45 + Math.random()*20, a = Math.random()*Math.PI*2;
    p.position.set(Math.cos(a)*r, h/2, Math.sin(a)*r);
    p.castShadow = true; p.receiveShadow = true;
    scene.add(p);
  }

  // Materials (themes)
  const THEMES = {
    forest: {
      platform: new THREE.MeshStandardMaterial({ color: 0x2b5c4b, roughness: 0.78, metalness: 0.12 }),
      platformAlt: new THREE.MeshStandardMaterial({ color: 0x3a2b5c, roughness: 0.82, metalness: 0.12 }),
      sky: 0x0c1326, fog: [50,140], lightColor: 0xfff1e4
    },
    crystal: {
      platform: new THREE.MeshStandardMaterial({ color: 0x3dc8ff, roughness: 0.4, metalness: 0.6 }),
      platformAlt: new THREE.MeshStandardMaterial({ color: 0x7bd8ff, roughness: 0.45, metalness: 0.6 }),
      sky: 0x0a0f1f, fog: [40,120], lightColor: 0xcfe7ff
    },
    skyisles: {
      platform: new THREE.MeshStandardMaterial({ color: 0xe3d5a4, roughness: 0.7, metalness: 0.2 }),
      platformAlt: new THREE.MeshStandardMaterial({ color: 0xc8b68f, roughness: 0.75, metalness: 0.2 }),
      sky: 0x10172b, fog: [60,160], lightColor: 0xfff9d6
    }
  };
  const matStar = new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0xffa000, emissiveIntensity: 1.0, roughness: 0.2, metalness: 0.6 });
  const matGoal = new THREE.MeshStandardMaterial({ color: 0x5ce1e6, emissive: 0x29d5da, emissiveIntensity: 0.9, roughness: 0.4, metalness: 0.4 });

  // Player + customization
  const playerRadius = 0.5;
  const playerHeight = 1.2;
  let playerColor = 0xf0f3f8;
  const matPlayer = new THREE.MeshStandardMaterial({ color: playerColor, roughness: 0.35, metalness: 0.22, emissive: 0x141414, emissiveIntensity: 0.28 });
  const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, playerHeight, 8, 16), matPlayer);
  player.castShadow = true;
  scene.add(player);

  // Owner cosmetic label
  let ownerSprite = null;
  function makeOwnerSprite() {
    const c = document.createElement('canvas');
    c.width = 256; c.height = 128;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.font = 'bold 64px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff2b2b';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 6;
    ctx.strokeText('OWNER', c.width/2, c.height/2);
    ctx.fillText('OWNER', c.width/2, c.height/2);
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(2.8, 1.4, 1);
    scene.add(sprite);
    return sprite;
  }
  let ownerUnlocked = false;

  // Accessories
  const hat = new THREE.Mesh(new THREE.ConeGeometry(0.45, 0.6, 12), new THREE.MeshStandardMaterial({ color: 0xff6f61, roughness: 0.5 }));
  hat.rotation.x = Math.PI; hat.visible = false; scene.add(hat);

  const trailGeom = new THREE.TorusGeometry(0.25, 0.05, 8, 24);
  const trailMat = new THREE.MeshStandardMaterial({ color: 0x88aaff, emissive: 0x88aaff, emissiveIntensity: 0.7, roughness: 0.2, metalness: 0.2 });
  const trail = new THREE.Mesh(trailGeom, trailMat);
  trail.visible = false; scene.add(trail);

  // Camera rig + smoothing
  let cameraMode = 'third';
  let camYaw = 0;
  let camPitch = 0.25;
  const pitchMin = -0.3, pitchMax = 0.85;
  let camSensitivity = 3.5;
  const orbitRadius = 8.5;
  const camPosSmooth = new THREE.Vector3().copy(camera.position);
  const camLookSmooth = new THREE.Vector3();

  // Scenes with 20 levels each (procedural variety)
  function createSceneLevels(count, cfg) {
    const levels = [];
    for (let i=1; i<=count; i++) {
      const baseW = 20 + (i % 5) * 2;
      const baseD = 20 + ((i+2) % 5) * 2;
      const platforms = [{ x:0, y:0, z:0, w:baseW, d:baseD, alt:false }];
      const steps = 5 + (i % 4);
      for (let s=1; s<=steps; s++) {
        const alt = s % 2 === 0;
        const x = ((i * 3 + s * 4) % 2 === 0 ? s*3 : -s*3);
        const y = s * (1.8 + (i%3)*0.2);
        const z = -s * (6 + (i%4));
        const w = 4 + (s%3);
        const d = 4 + ((i+s)%3);
        platforms.push({ x, y, z, w, d, alt });
      }
      const stars = platforms.slice(1, Math.min(platforms.length, 7)).map(p => [p.x, p.y + 1.5, p.z]);
      const goalP = platforms[platforms.length - 1];
      const goal = [goalP.x, goalP.y + 1.5, goalP.z];
      const spawn = [0, 2.5, 6];
      levels.push({ name: `Level ${i}`, platforms, stars, goal, spawn, theme: cfg });
    }
    return levels;
  }

  const SCENES = [
    { name: "Forest Realm", theme: 'forest', levels: createSceneLevels(20, 'forest') },
    { name: "Crystal Caverns", theme: 'crystal', levels: createSceneLevels(20, 'crystal') },
    { name: "Sky Isles", theme: 'skyisles', levels: createSceneLevels(20, 'skyisles') }
  ];

  // Gameplay containers
  let platforms = [];
  let stars = [];
  let goal = null;

  // HUD elements
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const modeEl = document.getElementById('mode');
  const timerEl = document.getElementById('timer');
  const livesEl = document.getElementById('lives');
  const msgEl = document.getElementById('msg');
  const pauseOverlay = document.getElementById('pauseOverlay');

  // Menus
  const sceneSelect = document.getElementById('sceneSelect');
  const levelSelect = document.getElementById('levelSelect');
  const modeSelect = document.getElementById('modeSelect');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const toggleViewBtn = document.getElementById('toggleViewBtn');
  const openMenuBtn = document.getElementById('openMenuBtn');
  const codeInput = document.getElementById('codeInput');
  const codeApplyBtn = document.getElementById('codeApplyBtn');

  // Main menu overlay
  const mainMenu = document.getElementById('mainMenu');
  const closeMenuBtn = document.getElementById('closeMenuBtn');
  const tabs = Array.from(document.querySelectorAll('.tab'));
  const panes = {
    levelsTab: document.getElementById('levelsTab'),
    customTab: document.getElementById('customTab'),
    optionsTab: document.getElementById('optionsTab')
  };
  const levelsGrid = document.getElementById('levelsGrid');
  const hatToggle = document.getElementById('hatToggle');
  const trailToggle = document.getElementById('trailToggle');
  const doubleJumpToggle = document.getElementById('doubleJumpToggle');
  const camSensInput = document.getElementById('camSens');

  // Populate scene and level dropdowns + menu grid
  SCENES.forEach((s, si) => {
    const opt = document.createElement('option');
    opt.value = si; opt.textContent = `${si+1}. ${s.name}`;
    sceneSelect.appendChild(opt);
  });
  function populateLevelsDropdown(sceneIndex) {
    levelSelect.innerHTML = '';
    const lvls = SCENES[sceneIndex].levels;
    lvls.forEach((l, li) => {
      const opt = document.createElement('option');
      opt.value = li; opt.textContent = l.name;
      levelSelect.appendChild(opt);
    });
    levelsGrid.innerHTML = '';
    lvls.forEach((l, li) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `<strong>${SCENES[sceneIndex].name}</strong><br/>${l.name}<br/><button data-scene="${sceneIndex}" data-level="${li}">Play</button>`;
      levelsGrid.appendChild(card);
    });
  }
  sceneSelect.value = '0';
  populateLevelsDropdown(0);
  levelsGrid.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-level]');
    if (!btn) return;
    const si = parseInt(btn.getAttribute('data-scene'), 10);
    const li = parseInt(btn.getAttribute('data-level'), 10);
    loadLevel(si, li);
    mainMenu.style.display = 'none';
  });

  sceneSelect.addEventListener('change', (e) => {
    populateLevelsDropdown(parseInt(e.target.value, 10));
    loadLevel(parseInt(e.target.value, 10), 0);
  });
  levelSelect.addEventListener('change', (e) => {
    loadLevel(parseInt(sceneSelect.value, 10), parseInt(e.target.value, 10));
  });

  // Tab behavior
  tabs.forEach(t => t.addEventListener('click', () => {
    tabs.forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    Object.values(panes).forEach(p => p.classList.remove('active'));
    panes[t.getAttribute('data-tab')].classList.add('active');
  }));

  // Customization swatches
  Array.from(document.querySelectorAll('.swatch')).forEach(sw => {
    sw.addEventListener('click', () => {
      const hex = sw.getAttribute('data-color');
      playerColor = parseInt(hex.replace('#', ''), 16);
      matPlayer.color.setHex(playerColor);
    });
  });
  hatToggle.addEventListener('change', () => { hat.visible = hatToggle.checked; });
  trailToggle.addEventListener('change', () => { trail.visible = trailToggle.checked; });
  camSensInput.addEventListener('input', () => { camSensitivity = parseFloat(camSensInput.value); });

  // Owner code
  codeApplyBtn.addEventListener('click', () => {
    if (codeInput.value.trim().toLowerCase() === 'owner222') {
      ownerUnlocked = true;
      if (!ownerSprite) ownerSprite = makeOwnerSprite();
      msgEl.textContent = 'Owner cosmetic unlocked!';
    } else {
      msgEl.textContent = 'Invalid code.';
    }
    codeInput.value = '';
  });
  codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') codeApplyBtn.click(); });

  // Game mode state
  let gameMode = 'classic';
  let timeLeft = 60.0;
  let lives = 3;

  function updateHUD() {
    scoreEl.textContent = `Stars: ${score} / ${stars.length}`;
    levelEl.textContent = `${SCENES[currentScene].name} â€” ${SCENES[currentScene].levels[currentLevel].name}`;
    modeEl.textContent = `Mode: ${gameMode === 'classic' ? 'Classic' : gameMode === 'time' ? 'Time Attack' : 'Survival'}`;
    timerEl.style.display = gameMode === 'time' ? 'block' : 'none';
    livesEl.style.display = gameMode === 'survival' ? 'block' : 'none';
    if (gameMode === 'time') timerEl.textContent = `Time: ${timeLeft.toFixed(1)}s`;
    if (gameMode === 'survival') livesEl.textContent = `Lives: ${lives}`;
  }

  // Physics
  const velocity = new THREE.Vector3(0, 0, 0);
  const acceleration = new THREE.Vector3(0, 0, 0);
  const gravity = new THREE.Vector3(0, -24, 0);
  const friction = 8.5;
  const airControl = 0.6;
  let onGround = false;

  // Double jump
  let canDoubleJump = true;
  let doubleJumpEnabled = true;

  // Input state
  const keys = { left: false, right: false, up: false, down: false, jump: false };
  let moveDx = 0, moveDy = 0;
  let paused = false;
  let score = 0;
  const voidY = -20;

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
    if (e.code === 'Space') keys.jump = true;
    if (e.code === 'KeyP') togglePause();
    if (e.code === 'Escape') mainMenu.style.display = 'none';
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
    if (e.code === 'Space') keys.jump = false;
  });

  // Camera look with large deadzones around controls
  const moveStickEl = document.getElementById('moveStick');
  const jumpBtnEl = document.getElementById('jumpBtn');
  function inExpandedRect(e, rect, pad=60) {
    return e.clientX >= rect.left - pad && e.clientX <= rect.right + pad &&
           e.clientY >= rect.top - pad && e.clientY <= rect.bottom + pad;
  }
  let lastMouse = null;
  window.addEventListener('pointerdown', (e) => { lastMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('pointerup', () => { lastMouse = null; });
  window.addEventListener('pointermove', (e) => {
    if (!lastMouse) return;
    const moveRect = moveStickEl.getBoundingClientRect();
    const jumpRect = jumpBtnEl.getBoundingClientRect();
    const overMove = inExpandedRect(e, moveRect, 70);
    const overJump = inExpandedRect(e, jumpRect, 70);
    if (overMove || overJump) { lastMouse = { x: e.clientX, y: e.clientY }; return; }

    const dx = (e.clientX - lastMouse.x) / window.innerWidth;
    const dy = (e.clientY - lastMouse.y) / window.innerHeight;
    const jitterDeadzone = 0.02;
    if (Math.abs(dx) > jitterDeadzone) camYaw -= dx * camSensitivity;
    if (Math.abs(dy) > jitterDeadzone) {
      camPitch = THREE.MathUtils.clamp(
        camPitch + (cameraMode === 'third' ? dy * (camSensitivity * 0.66) : -dy * (camSensitivity * 0.66)),
        pitchMin, pitchMax
      );
    }
    lastMouse = { x: e.clientX, y: e.clientY };
  });

  // Virtual joystick setup
  function setupStick(stickId, thumbId, cb) {
    const stick = document.getElementById(stickId);
    const thumb = document.getElementById(thumbId);
    let active = false;
    const rect = () => stick.getBoundingClientRect();
    function setThumb(x, y) {
      const r = 80;
      const len = Math.hypot(x, y);
      const k = len > r ? r / len : 1;
      const tx = x * k, ty = y * k;
      thumb.style.transform = `translate(${tx}px,${ty}px)`;
      cb(tx / r, ty / r);
    }
    function reset() { thumb.style.transform = `translate(0px,0px)`; cb(0, 0); }
    stick.addEventListener('pointerdown', (e) => {
      active = true; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
      stick.setPointerCapture(e.pointerId);
    });
    stick.addEventListener('pointermove', (e) => {
      if (!active) return; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
    });
    stick.addEventListener('pointerup', () => { active = false; reset(); });
    stick.addEventListener('pointercancel', () => { active = false; reset(); });
  }
  setupStick('moveStick', 'moveThumb', (dx, dy) => { moveDx = -dx; moveDy = -dy; });

  // Jump button
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.addEventListener('pointerdown', () => keys.jump = true);
  jumpBtn.addEventListener('pointerup', () => keys.jump = false);

  // Pause/resume
  function togglePause() { paused = !paused; pauseOverlay.style.display = paused ? 'flex' : 'none'; }
  pauseOverlay.addEventListener('click', togglePause);
  pauseBtn.addEventListener('click', togglePause);

  // Prevent touch scrolling on mobile during joystick use
  document.body.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive:false });

  // Toggle first/third person
  toggleViewBtn.addEventListener('click', () => {
    cameraMode = cameraMode === 'third' ? 'first' : 'third';
    player.visible = cameraMode !== 'first';
  });

  // Open/close main menu
  openMenuBtn.addEventListener('click', () => { mainMenu.style.display = 'block'; });
  closeMenuBtn.addEventListener('click', () => { mainMenu.style.display = 'none'; });
  doubleJumpToggle.addEventListener('change', (e) => { doubleJumpEnabled = e.target.checked; });

  // Geometry helpers
  function makePlatform(x, y, z, w, d, alt, themeKey) {
    const theme = THEMES[themeKey] || THEMES.forest;
    const mat = alt ? theme.platformAlt : theme.platform;
    const geo = new THREE.BoxGeometry(w, 0.6, d);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true; mesh.receiveShadow = true;
    const rim = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, 0.05, d+0.2), new THREE.MeshStandardMaterial({ color: 0x1b2a45, roughness: 0.9 }));
    rim.position.set(0, 0.325, 0);
    mesh.add(rim);
    scene.add(mesh);
    platforms.push(mesh);
    return mesh;
  }
  function makeStar(x, y, z) {
    const s = new THREE.Mesh(new THREE.IcosahedronGeometry(0.38, 0), matStar);
    s.position.set(x, y, z);
    s.castShadow = true;
    scene.add(s);
    const pl = new THREE.PointLight(0xffa000, 0.5, 6);
    pl.position.copy(s.position).add(new THREE.Vector3(0,0.2,0));
    scene.add(pl);
    s.userData.light = pl;
    stars.push(s);
    return s;
  }
  function aabbSphereCollision(box, spherePos, sphereR) {
    const bPos = box.position;
    box.geometry.computeBoundingBox();
    const bb = box.geometry.boundingBox;
    const halfX = (bb.max.x - bb.min.x)/2, halfY = (bb.max.y - bb.min.y)/2, halfZ = (bb.max.z - bb.min.z)/2;
    const minX = bPos.x - halfX, minY = bPos.y - halfY, minZ = bPos.z - halfZ;
    const maxX = bPos.x + halfX, maxY = bPos.y + halfY, maxZ = bPos.z + halfZ;
    const cx = Math.max(minX, Math.min(spherePos.x, maxX));
    const cy = Math.max(minY, Math.min(spherePos.y, maxY));
    const cz = Math.max(minZ, Math.min(spherePos.z, maxZ));
    const dx = spherePos.x - cx, dy = spherePos.y - cy, dz = spherePos.z - cz;
    const dist2 = dx*dx + dy*dy + dz*dz;
    if (dist2 <= sphereR*sphereR) return new THREE.Vector3(dx, dy, dz);
    return null;
  }

  // Level management
  let currentScene = 0;
  let currentLevel = 0;

  function applyTheme(themeKey) {
    const theme = THEMES[themeKey] || THEMES.forest;
    scene.background = new THREE.Color(theme.sky);
    scene.fog.color = new THREE.Color(theme.sky);
    scene.fog.near = theme.fog[0];
    scene.fog.far = theme.fog[1];
    sun.color = new THREE.Color(theme.lightColor);
  }

  function clearLevel() {
    platforms.forEach(m => scene.remove(m));
    stars.forEach(s => { scene.remove(s); if (s.userData.light) scene.remove(s.userData.light); });
    platforms = []; stars = [];
    if (goal) { scene.remove(goal); goal = null; }
  }

  function loadLevel(sceneIndex, levelIndex) {
    clearLevel();
    currentScene = sceneIndex;
    currentLevel = levelIndex;
    const lvl = SCENES[sceneIndex].levels[levelIndex];
    applyTheme(lvl.theme);

    lvl.platforms.forEach(p => makePlatform(p.x, p.y, p.z, p.w, p.d, p.alt, lvl.theme));
    lvl.stars.forEach(([x,y,z]) => makeStar(x, y, z));
    goal = new THREE.Mesh(new THREE.TorusGeometry(1.4, 0.28, 16, 64), matGoal);
    goal.position.set(lvl.goal[0], lvl.goal[1], lvl.goal[2]);
    goal.castShadow = true;
    scene.add(goal);

    score = 0;
    player.position.set(lvl.spawn[0], lvl.spawn[1], lvl.spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    canDoubleJump = true;
    msgEl.textContent = 'Collect stars and reach the glowing goal!';
    updateHUD();
  }

  function applyMode(mode) {
    gameMode = mode;
    timeLeft = gameMode === 'time' ? 75.0 : 60.0;
    lives = 3;
    updateHUD();
  }

  modeSelect.addEventListener('change', (e) => applyMode(e.target.value));
  restartBtn.addEventListener('click', () => loadLevel(currentScene, currentLevel));

  // Respawn
  function respawn(penalize = true) {
    const spawn = SCENES[currentScene].levels[currentLevel].spawn;
    player.position.set(spawn[0], spawn[1], spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    canDoubleJump = true;
    if (gameMode === 'survival' && penalize) {
      lives -= 1;
      msgEl.textContent = lives > 0 ? `Oops! Lives left: ${lives}` : 'Game over. Restart or change level.';
      if (lives <= 0) paused = true;
    } else {
      msgEl.textContent = 'Try again! Reach the glowing goal.';
    }
    updateHUD();
  }

  // Ambient particles
  const dustGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const dustMat = new THREE.MeshBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.25 });
  const dusts = [];
  for (let i=0;i<120;i++){
    const d = new THREE.Mesh(dustGeo, dustMat);
    d.position.set((Math.random()-0.5)*90, 2+Math.random()*14, (Math.random()-0.5)*140);
    scene.add(d); dusts.push(d);
  }

  // Init
  loadLevel(0, 0);
  applyMode('classic');

  // Main loop
  const clock = new THREE.Clock();
  let tGoal = 0;

  function animate() {
    requestAnimationFrame(animate);
    if (paused) return;

    const dt = Math.min(0.033, clock.getDelta());

    // Accessories & owner label
    hat.position.set(player.position.x, player.position.y + playerHeight * 0.5 + 0.4, player.position.z);
    trail.position.set(player.position.x, player.position.y + 0.2, player.position.z);
    trail.rotation.y += dt * 2.0;
    if (ownerUnlocked && ownerSprite) {
      ownerSprite.position.set(player.position.x, player.position.y + playerHeight * 0.5 + 1.8, player.position.z);
    }

    // Time attack
    if (gameMode === 'time') {
      timeLeft -= dt;
      if (timeLeft <= 0) { timeLeft = 0; msgEl.textContent = 'Time up! Restart or switch mode.'; paused = true; }
    }
    updateHUD();

    // Input vector: keyboard + movement joystick
    const ix = (keys.right ? 1 : 0) - (keys.left ? 1 : 0) + moveDx;
    const iz = (keys.down ? 1 : 0) - (keys.up ? 1 : 0) + moveDy;
    const input = new THREE.Vector3(ix, 0, iz);
    if (input.lengthSq() > 1) input.normalize();

    // Camera forward/right
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

    // Movement relative to camera
    const moveVec = new THREE.Vector3().addScaledVector(forward, input.z).addScaledVector(right, input.x);

    // Movement params
    const accelMag = onGround ? 17 : 17 * airControl;
    acceleration.set(moveVec.x * accelMag, 0, moveVec.z * accelMag);
    acceleration.add(gravity);
    velocity.addScaledVector(acceleration, dt);

    // Ground friction when idle
    if (onGround && moveVec.lengthSq() < 1e-4) {
      velocity.x = THREE.MathUtils.damp(velocity.x, 0, friction, dt);
      velocity.z = THREE.MathUtils.damp(velocity.z, 0, friction, dt);
    }

    // Jump handling: stronger + double jump
    if (keys.jump) {
      if (onGround) {
        velocity.y = 14.5;
        onGround = false;
        canDoubleJump = true;
        keys.jump = false;
      } else if (doubleJumpEnabled && canDoubleJump) {
        velocity.y = 11.8;
        canDoubleJump = false;
        msgEl.textContent = 'Double jump!';
        keys.jump = false;
      }
    }

    // Integrate
    player.position.addScaledVector(velocity, dt);

    // Collisions
    const wasGrounded = onGround;
    onGround = false;
    for (const box of platforms) {
      const hit = aabbSphereCollision(box, player.position, playerRadius);
      if (hit) {
        const len = Math.hypot(hit.x, hit.y, hit.z) || 1;
        const nx = hit.x / len, ny = hit.y / len, nz = hit.z / len;
        const push = (playerRadius - len);
        player.position.x += nx * push;
        player.position.y += ny * push;
        player.position.z += nz * push;

        if (ny > 0.5) {
          onGround = true;
          if (velocity.y < 0) velocity.y = 0;
        } else {
          velocity.x *= 0.82;
          velocity.z *= 0.82;
        }
      }
    }
    if (!wasGrounded && onGround) canDoubleJump = true;

    // Stars
    for (const s of stars) {
      if (!s.visible) continue;
      const d = s.position.distanceTo(player.position);
      if (d < playerRadius + 0.6) {
        s.visible = false;
        if (s.userData.light) s.userData.light.visible = false;
        score += 1;
        msgEl.textContent = score === stars.length ? 'All stars collected! Head to the goal.' : 'Star collected!';
        updateHUD();
      } else {
        s.rotation.y += dt * 1.6;
      }
    }

    // Goal
    tGoal += dt;
    if (goal) {
      goal.rotation.x = Math.sin(tGoal * 1.2) * 0.2;
      goal.rotation.y += dt * 0.8;
      if (player.position.distanceTo(goal.position) < 1.6) {
        if (score === stars.length) {
          msgEl.textContent = 'Level complete! Loading next...';
          const nextLevel = (currentLevel + 1) % SCENES[currentScene].levels.length;
          setTimeout(() => { loadLevel(currentScene, nextLevel); }, 900);
        } else {
          msgEl.textContent = 'Collect all stars first!';
        }
      }
    }

    // Void fall
    if (player.position.y < voidY) respawn(gameMode === 'survival');

    // Smooth camera
    if (cameraMode === 'third') {
      const y = Math.sin(camPitch) * orbitRadius;
      const h = Math.cos(camPitch) * orbitRadius;
      const desiredPos = new THREE.Vector3(
        player.position.x + Math.sin(camYaw) * h,
        player.position.y + y + 1.6,
        player.position.z + Math.cos(camYaw) * h
      );
      camPosSmooth.lerp(desiredPos, 0.12); // smoothing factor
      camera.position.copy(camPosSmooth);

      const lookTarget = new THREE.Vector3(player.position.x, player.position.y + 0.9, player.position.z);
      camLookSmooth.lerp(lookTarget, 0.18);
      camera.lookAt(camLookSmooth);
    } else {
      const head = new THREE.Vector3(player.position.x, player.position.y + playerHeight * 0.5 + 0.5, player.position.z);
      const dir = new THREE.Vector3(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      );
      const desiredPos = head.clone();
      camPosSmooth.lerp(desiredPos, 0.15);
      camera.position.copy(camPosSmooth);
      const lookTarget = head.clone().add(dir);
      camLookSmooth.lerp(lookTarget, 0.18);
      camera.lookAt(camLookSmooth);
    }

    // Ambient particles drift
    for (const d of dusts) {
      d.position.x += Math.sin(tGoal + d.id) * 0.003;
      d.position.y += Math.cos(tGoal + d.id) * 0.002;
    }

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
})();
</script>
</body>
</html>
