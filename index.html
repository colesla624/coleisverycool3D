<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini 3D Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#111; }
    #ui {
      position:fixed; top:12px; left:12px; color:#fff; font-family:system-ui, sans-serif; z-index:10;
      background:rgba(0,0,0,0.4); padding:8px 10px; border-radius:6px; font-size:14px;
    }
    #crosshair {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      width:12px; height:12px; pointer-events:none; z-index:9;
    }
    #crosshair::before, #crosshair::after {
      content:""; position:absolute; background:#fff; border-radius:1px;
    }
    #crosshair::before { left:5px; top:0; width:2px; height:12px; }
    #crosshair::after { left:0; top:5px; width:12px; height:2px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="ui">
    <div><b>Controls:</b> Click to lock mouse | WASD move | Space jump | Left click shoot</div>
    <div id="stats"></div>
  </div>
  <div id="crosshair"></div>
  <canvas id="game"></canvas>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

  <script>
  // Basic 3D shooter scaffold â€” single-file, no bundler
  const canvas = document.getElementById('game');
  const statsEl = document.getElementById('stats');

  // Renderer
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Scene and camera
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0e0e12);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.8, 5);

  // Lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5, 10, 2);
  scene.add(dir);

  // Floor
  const floorGeo = new THREE.PlaneGeometry(200, 200);
  const floorMat = new THREE.MeshStandardMaterial({ color:0x1a1f27, roughness:0.9, metalness:0.0 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Simple structures
  const makeBox = (x,y,z,c=0x3a6ea5) => {
    const m = new THREE.Mesh(
      new THREE.BoxGeometry(2,2,2),
      new THREE.MeshStandardMaterial({ color:c, roughness:0.7 })
    );
    m.position.set(x,y,z);
    m.castShadow = true;
    m.receiveShadow = true;
    scene.add(m);
    return m;
  };
  for (let i=0;i<20;i++){
    makeBox((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60, 0x2e8b57);
  }

  // Enemy cubes
  const enemies = [];
  const enemyGeo = new THREE.BoxGeometry(1.2,1.2,1.2);
  const enemyMat = new THREE.MeshStandardMaterial({ color:0xcc3344, emissive:0x220008, emissiveIntensity:0.2 });

  function spawnEnemy() {
    const e = new THREE.Mesh(enemyGeo, enemyMat.clone());
    const r = 30 + Math.random()*20;
    const a = Math.random()*Math.PI*2;
    e.position.set(Math.cos(a)*r, 0.6, Math.sin(a)*r);
    e.userData.hp = 3;
    enemies.push(e);
    scene.add(e);
  }
  for (let i=0; i<12; i++) spawnEnemy();

  // Player state
  const player = {
    pos: new THREE.Vector3().copy(camera.position),
    vel: new THREE.Vector3(),
    yaw: 0, pitch: 0,
    onGround: false,
    speed: 6.0,
    jumpVel: 6.5
  };

  // Pointer lock
  const havePointerLock = 'pointerLockElement' in document;
  const lock = () => canvas.requestPointerLock && canvas.requestPointerLock();
  canvas.addEventListener('click', lock);
  document.addEventListener('pointerlockchange', () => {
    // no-op
  });

  // Mouse look
  window.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement !== canvas) return;
    const sensitivity = 0.0025;
    player.yaw -= e.movementX * sensitivity;
    player.pitch -= e.movementY * sensitivity;
    player.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, player.pitch));
    updateCameraRot();
  });

  function updateCameraRot(){
    const q = new THREE.Quaternion();
    q.setFromEuler(new THREE.Euler(player.pitch, player.yaw, 0, 'YXZ'));
    camera.quaternion.copy(q);
  }
  updateCameraRot();

  // Keyboard input
  const keys = {};
  window.addEventListener('keydown', (e) => keys[e.code] = true);
  window.addEventListener('keyup',   (e) => keys[e.code] = false);

  function getMoveDir(){
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
    fwd.y = 0; right.y = 0;
    fwd.normalize(); right.normalize();
    const dir = new THREE.Vector3();
    if (keys['KeyW']) dir.add(fwd);
    if (keys['KeyS']) dir.add(fwd.clone().multiplyScalar(-1));
    if (keys['KeyA']) dir.add(right.clone().multiplyScalar(-1));
    if (keys['KeyD']) dir.add(right);
    return dir.normalize();
  }

  // Physics params
  const GRAVITY = 18.0;
  const FRICTION = 10.0;

  // Bullets
  const bullets = [];
  const bulletGeo = new THREE.SphereGeometry(0.08, 12, 12);
  const bulletMat = new THREE.MeshStandardMaterial({ color:0x88c9ff, emissive:0x084d7a, emissiveIntensity:0.4 });

  function shoot(){
    if (document.pointerLockElement !== canvas) return;
    const b = new THREE.Mesh(bulletGeo, bulletMat);
    const muzzle = new THREE.Vector3().copy(camera.position);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
    b.position.copy(muzzle).add(dir.clone().multiplyScalar(0.3));
    b.userData.vel = dir.clone().multiplyScalar(35);
    b.userData.life = 2.0;
    bullets.push(b);
    scene.add(b);
  }
  window.addEventListener('mousedown', (e) => { if (e.button===0) shoot(); });

  // Simple ground collision
  function applyPhysics(dt){
    // horizontal input
    const move = getMoveDir();
    const targetVel = move.multiplyScalar(player.speed);
    const accel = 30;
    player.vel.x = THREE.MathUtils.damp(player.vel.x, targetVel.x, accel, dt);
    player.vel.z = THREE.MathUtils.damp(player.vel.z, targetVel.z, accel, dt);

    // gravity
    player.vel.y -= GRAVITY * dt;

    // jump
    if (player.onGround && keys['Space']) {
      player.vel.y = player.jumpVel;
      player.onGround = false;
    }

    // integrate
    player.pos.addScaledVector(player.vel, dt);

    // ground plane at y=1.8 - player height (camera at head)
    const groundY = 1.6; // slightly below camera to feel right
    if (player.pos.y <= groundY) {
      player.pos.y = groundY;
      player.vel.y = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }

    // clamp world bounds
    player.pos.x = THREE.MathUtils.clamp(player.pos.x, -95, 95);
    player.pos.z = THREE.MathUtils.clamp(player.pos.z, -95, 95);

    camera.position.copy(player.pos);
  }

  // Bullet and enemy updates
  function updateBullets(dt){
    for (let i=bullets.length-1; i>=0; i--){
      const b = bullets[i];
      b.position.addScaledVector(b.userData.vel, dt);
      b.userData.life -= dt;
      // lifetime
      if (b.userData.life <= 0) {
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }
      // floor bounce disabled; remove if hits floor
      if (b.position.y < 0) {
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }
      // collision with enemies (AABB check)
      for (let j=enemies.length-1; j>=0; j--){
        const e = enemies[j];
        const d = b.position.clone().sub(e.position);
        if (Math.abs(d.x) < 0.7 && Math.abs(d.y) < 0.9 && Math.abs(d.z) < 0.7) {
          e.userData.hp -= 1;
          flash(e);
          scene.remove(b);
          bullets.splice(i,1);
          if (e.userData.hp <= 0) {
            pop(e);
            scene.remove(e);
            enemies.splice(j,1);
            spawnEnemy();
          }
          break;
        }
      }
    }
  }

  function flash(e){
    e.material.emissiveIntensity = 0.9;
    setTimeout(()=> e.material.emissiveIntensity = 0.2, 60);
  }

  function pop(e){
    // simple explode effect (scale + fade)
    const start = performance.now();
    const mat = e.material;
    const mesh = e;
    const dur = 250;
    function step(){
      const t = (performance.now() - start)/dur;
      if (t>=1) return;
      mesh.scale.setScalar(1 + t*1.5);
      mat.opacity = 1 - t;
      mat.transparent = true;
      requestAnimationFrame(step);
    }
    step();
  }

  // Enemy AI: drift toward player
  function updateEnemies(dt){
    for (const e of enemies){
      const toPlayer = player.pos.clone().sub(e.position);
      toPlayer.y = 0;
      const dist = toPlayer.length();
      if (dist > 0.001){
        toPlayer.normalize();
        const speed = THREE.MathUtils.mapLinear(dist, 0, 40, 0.5, 2.2);
        e.position.addScaledVector(toPlayer, speed * dt);
      }
      // idle bob
      e.position.y = 0.6 + Math.sin(performance.now()*0.002 + e.id) * 0.05;
    }
  }

  // HUD
  let fps = 0, lastFps = performance.now();
  function updateHUD(dt){
    const now = performance.now();
    fps = 1000 / (now - lastFps);
    lastFps = now;
    statsEl.textContent =
      `Enemies: ${enemies.length} | Bullets: ${bullets.length} | ` +
      `On ground: ${player.onGround ? 'yes' : 'no'} | ` +
      `FPS: ${fps.toFixed(0)}`;
  }

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Main loop
  let prev = performance.now();
  function loop(){
    const now = performance.now();
    let dt = (now - prev) / 1000;
    prev = now;
    dt = Math.min(dt, 0.05); // avoid big steps

    applyPhysics(dt);
    updateEnemies(dt);
    updateBullets(dt);
    updateHUD(dt);

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  loop();

  // Optional: press R to reset position
  window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyR') {
      player.pos.set(0, 1.8, 5);
      player.vel.set(0,0,0);
    }
  });
  </script>
</body>
</html>
