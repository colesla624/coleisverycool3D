<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>3D Mobile Platformer</title>
<style>
  html, body { margin:0; height:100%; background:#101318; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #game { position:fixed; inset:0; }
  #hud {
    position: fixed; left: 0; right: 0; top: 0; display: flex; justify-content: space-between; padding: 10px; pointer-events: none;
    color:#e6e6e6; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.7);
  }
  .panel { background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 12px; }
  #msg { position: fixed; left: 50%; transform: translateX(-50%); bottom: 20px; color:#fff; background: rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.15); border-radius: 10px; padding:8px 12px; pointer-events:none; }
  /* Virtual joystick */
  #controls { position: fixed; inset: 0; pointer-events: none; }
  .stick-wrap { position: absolute; left: 20px; bottom: 20px; width: 140px; height: 140px; pointer-events: auto; touch-action: none; }
  .stick-base, .stick-thumb {
    position: absolute; border-radius: 50%; backdrop-filter: blur(4px);
  }
  .stick-base { width: 140px; height: 140px; background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.2); }
  .stick-thumb { width: 70px; height: 70px; left: 35px; top: 35px; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); }
  /* Jump button */
  .btn { position: absolute; right: 20px; bottom: 30px; width: 90px; height: 90px; border-radius: 50%; pointer-events: auto; touch-action: manipulation;
    background: radial-gradient(circle at 30% 30%, #fff 0%, #f6b73c 35%, #e36c1b 60%, #ad3a0a 100%); box-shadow: 0 10px 25px rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.5); }
  .btn:active { transform: scale(0.96); }
  /* Desktop help */
  #help { position: fixed; left: 50%; transform: translateX(-50%); top: 10px; color:#a7b0c0; font-size: 13px; }
  /* Pause overlay */
  #pauseOverlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); color:#fff; font-size: 20px; font-weight:700; text-align:center; }
  #pauseOverlay .inner { background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.2); padding: 14px 18px; border-radius: 10px; }
  /* Prevent long-press selection */
  * { -webkit-tap-highlight-color: transparent; user-select: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="panel" id="score">Stars: 0 / 10</div>
  <div class="panel" id="level">Level 1</div>
</div>
<div id="help">Desktop: WASD/Arrows to move, Space to jump, P to pause</div>
<div id="msg">Reach the glowing goal. Collect stars!</div>

<div id="controls">
  <div class="stick-wrap" id="stick">
    <div class="stick-base"></div>
    <div class="stick-thumb" id="thumb"></div>
  </div>
  <button class="btn" id="jumpBtn" aria-label="Jump"></button>
</div>

<div id="pauseOverlay"><div class="inner">Paused<br/><small>(Tap or press P to resume)</small></div></div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.157.0/examples/js/controls/OrbitControls.js"></script>
<script>
(() => {
  const canvas = document.getElementById('game');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1220);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 10);

  // Lighting
  const hemi = new THREE.HemisphereLight(0x88aaff, 0x111122, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.9);
  sun.position.set(8, 12, 6);
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024, 1024);
  scene.add(sun);

  // Sky glow
  const fogColor = new THREE.Color(0x0f1220);
  scene.fog = new THREE.Fog(fogColor, 40, 120);

  // Materials
  const matPlatform = new THREE.MeshStandardMaterial({ color: 0x2b5c4b, roughness: 0.8, metalness: 0.1 });
  const matPlatformAlt = new THREE.MeshStandardMaterial({ color: 0x3a2b5c, roughness: 0.85, metalness: 0.1 });
  const matPlayer = new THREE.MeshStandardMaterial({ color: 0xf0f3f8, roughness: 0.3, metalness: 0.2, emissive: 0x111111, emissiveIntensity: 0.25 });
  const matStar = new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0xffc107, emissiveIntensity: 0.9, roughness: 0.2, metalness: 0.6 });
  const matGoal = new THREE.MeshStandardMaterial({ color: 0x5ce1e6, emissive: 0x29d5da, emissiveIntensity: 0.8, roughness: 0.4, metalness: 0.4 });

  // Player
  const playerRadius = 0.5;
  const playerGeo = new THREE.SphereGeometry(playerRadius, 24, 16);
  const player = new THREE.Mesh(playerGeo, matPlayer);
  player.castShadow = true;
  player.receiveShadow = false;
  scene.add(player);

  // Ground / platforms
  const platforms = [];
  const platformGeo = new THREE.BoxGeometry(6, 0.5, 6);
  function makePlatform(x, y, z, w = 6, d = 6, mat = matPlatform) {
    const geo = new THREE.BoxGeometry(w, 0.5, d);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    platforms.push(mesh);
    return mesh;
  }

  // Level layout
  const base = makePlatform(0, 0, 0, 20, 20, matPlatform);
  const p1 = makePlatform(8, 2, -6, 6, 6, matPlatformAlt);
  const p2 = makePlatform(16, 4, -12, 6, 6);
  const p3 = makePlatform(24, 6, -18, 6, 6, matPlatformAlt);
  const p4 = makePlatform(18, 8, -26, 8, 6);
  const p5 = makePlatform(10, 10, -34, 6, 6, matPlatformAlt);
  const p6 = makePlatform(0, 12, -42, 10, 6);
  const p7 = makePlatform(-10, 14, -52, 10, 6, matPlatformAlt);
  const p8 = makePlatform(-18, 16, -62, 8, 6);
  const p9 = makePlatform(-26, 18, -72, 6, 6, matPlatformAlt);

  // Collectibles
  const stars = [];
  const starGeo = new THREE.IcosahedronGeometry(0.35, 0);
  function makeStar(x, y, z) {
    const s = new THREE.Mesh(starGeo, matStar);
    s.position.set(x, y, z);
    s.castShadow = true;
    scene.add(s);
    stars.push(s);
  }
  const starPositions = [
    [4, 1.5, -3], [8, 3.5, -6], [16, 5.5, -12], [24, 7.3, -18], [18, 9.5, -26],
    [10, 11.8, -34], [0, 13.5, -42], [-10, 15.4, -52], [-18, 17.2, -62], [-26, 19.0, -72]
  ];
  starPositions.forEach(([x,y,z]) => makeStar(x,y,z));

  // Goal
  const goalGeo = new THREE.TorusGeometry(1.2, 0.25, 16, 64);
  const goal = new THREE.Mesh(goalGeo, matGoal);
  goal.position.copy(p9.position).add(new THREE.Vector3(0, 1.5, 0));
  goal.castShadow = true;
  scene.add(goal);

  // Simple bounds (void)
  const voidY = -20;

  // Camera follow rig
  const camTarget = new THREE.Vector3();
  const camOffset = new THREE.Vector3(0, 4.5, 7.5);

  // Physics
  const velocity = new THREE.Vector3(0, 0, 0);
  const acceleration = new THREE.Vector3(0, 0, 0);
  const gravity = new THREE.Vector3(0, -24, 0);
  const friction = 7.5; // ground horizontal damping
  const airControl = 0.7;

  let onGround = false;
  let paused = false;
  let score = 0;
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const msgEl = document.getElementById('msg');
  const pauseOverlay = document.getElementById('pauseOverlay');

  function updateScore() {
    scoreEl.textContent = `Stars: ${score} / ${stars.length}`;
  }
  updateScore();

  // Controls: keyboard
  const keys = { left: false, right: false, up: false, down: false, jump: false };
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
    if (e.code === 'Space') keys.jump = true;
    if (e.code === 'KeyP') togglePause();
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
    if (e.code === 'Space') keys.jump = false;
  });

  // Controls: virtual joystick
  const stick = document.getElementById('stick');
  const thumb = document.getElementById('thumb');
  const stickRect = () => stick.getBoundingClientRect();
  let stickActive = false, stickDx = 0, stickDy = 0;

  function setThumb(x, y) {
    const r = 70; // radius to limit thumb travel
    const len = Math.hypot(x, y);
    const k = len > r ? r / len : 1;
    const tx = x * k, ty = y * k;
    thumb.style.transform = `translate(${tx}px, ${ty}px)`;
    stickDx = tx / r;
    stickDy = ty / r;
  }

  function resetThumb() {
    thumb.style.transform = `translate(0px,0px)`;
    stickDx = 0; stickDy = 0;
  }

  stick.addEventListener('pointerdown', (e) => {
    stickActive = true;
    const rect = stickRect();
    setThumb(e.clientX - (rect.left + rect.width/2), e.clientY - (rect.top + rect.height/2));
    stick.setPointerCapture(e.pointerId);
  });
  stick.addEventListener('pointermove', (e) => {
    if (!stickActive) return;
    const rect = stickRect();
    setThumb(e.clientX - (rect.left + rect.width/2), e.clientY - (rect.top + rect.height/2));
  });
  stick.addEventListener('pointerup', (e) => { stickActive = false; resetThumb(); });
  stick.addEventListener('pointercancel', () => { stickActive = false; resetThumb(); });

  // Jump button
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.addEventListener('pointerdown', () => keys.jump = true);
  jumpBtn.addEventListener('pointerup', () => keys.jump = false);

  // Pause overlay click to resume
  pauseOverlay.addEventListener('click', togglePause);
  function togglePause() {
    paused = !paused;
    pauseOverlay.style.display = paused ? 'flex' : 'none';
  }

  // Helpers
  function aabbSphereCollision(box, spherePos, sphereR) {
    // Clamp sphere center to box bounds
    const bPos = box.position;
    const half = new THREE.Vector3();
    box.geometry.computeBoundingBox();
    const bb = box.geometry.boundingBox;
    half.set((bb.max.x - bb.min.x)/2, (bb.max.y - bb.min.y)/2, (bb.max.z - bb.min.z)/2);
    const min = new THREE.Vector3(bPos.x - half.x, bPos.y - half.y, bPos.z - half.z);
    const max = new THREE.Vector3(bPos.x + half.x, bPos.y + half.y, bPos.z + half.z);
    const cx = Math.max(min.x, Math.min(spherePos.x, max.x));
    const cy = Math.max(min.y, Math.min(spherePos.y, max.y));
    const cz = Math.max(min.z, Math.min(spherePos.z, max.z));
    const dx = spherePos.x - cx, dy = spherePos.y - cy, dz = spherePos.z - cz;
    const dist2 = dx*dx + dy*dy + dz*dz;
    if (dist2 <= sphereR*sphereR) {
      return new THREE.Vector3(dx, dy, dz);
    }
    return null;
  }

  function respawn() {
    velocity.set(0,0,0);
    player.position.set(0, 2.5, 5);
    score = 0;
    stars.forEach(s => s.visible = true);
    updateScore();
    msgEl.textContent = 'Try again! Reach the glowing goal.';
  }

  // Init player position
  respawn();

  // Decorative ambient particles
  const dustGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const dustMat = new THREE.MeshBasicMaterial({ color: 0x88aaff });
  const dusts = [];
  for (let i=0;i<80;i++){
    const d = new THREE.Mesh(dustGeo, dustMat);
    d.position.set((Math.random()-0.5)*60, 2+Math.random()*12, (Math.random()-0.5)*100);
    d.material.opacity = 0.25; d.material.transparent = true;
    scene.add(d); dusts.push(d);
  }

  // Goal pulse
  let tGoal = 0;

  // Main loop
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    if (paused) return;

    const dt = Math.min(0.033, clock.getDelta()); // clamp delta for stability

    // Input vector: keyboard + joystick
    const ix = (keys.right ? 1 : 0) - (keys.left ? 1 : 0) + stickDx;
    const iz = (keys.down ? 1 : 0) - (keys.up ? 1 : 0) + stickDy; // joystick is y-down, map to forward
    const input = new THREE.Vector3(ix, 0, iz);
    if (input.lengthSq() > 1) input.normalize();

    // Rotate input by camera yaw so movement is relative to camera
    const camYaw = Math.atan2(camera.position.x - player.position.x, camera.position.z - player.position.z);
    const sin = Math.sin(camYaw), cos = Math.cos(camYaw);
    const move = new THREE.Vector3(
      input.x * cos - input.z * sin,
      0,
      input.x * sin + input.z * cos
    );

    // Acceleration
    const accelMag = onGround ? 28 : 28 * airControl;
    acceleration.set(move.x * accelMag, 0, move.z * accelMag);

    // Gravity
    acceleration.add(gravity);

    // Integrate velocity
    velocity.addScaledVector(acceleration, dt);

    // Ground friction damping (horizontal)
    if (onGround && move.lengthSq() < 0.0001) {
      velocity.x = THREE.MathUtils.damp(velocity.x, 0, friction, dt);
      velocity.z = THREE.MathUtils.damp(velocity.z, 0, friction, dt);
    }

    // Jump
    if (keys.jump && onGround) {
      velocity.y = 10.8;
      onGround = false;
      keys.jump = false;
    }

    // Integrate position
    player.position.addScaledVector(velocity, dt);

    // Collisions with platforms (simple sphere-box)
    onGround = false;
    for (const box of platforms) {
      const hit = aabbSphereCollision(box, player.position, playerRadius);
      if (hit) {
        // Push sphere out along collision normal approximation
        const len = Math.hypot(hit.x, hit.y, hit.z) || 1;
        const nx = hit.x / len, ny = hit.y / len, nz = hit.z / len;
        player.position.x += nx * (playerRadius - len);
        player.position.y += ny * (playerRadius - len);
        player.position.z += nz * (playerRadius - len);

        // If normal indicates top face contact, mark onGround and zero Y velocity downward
        if (ny > 0.5) {
          onGround = true;
          if (velocity.y < 0) velocity.y = 0;
        } else {
          // Wall/edge collision: damp horizontal a bit
          velocity.x *= 0.8;
          velocity.z *= 0.8;
        }
      }
    }

    // Collect stars
    for (const s of stars) {
      if (!s.visible) continue;
      const d = s.position.distanceTo(player.position);
      if (d < playerRadius + 0.6) {
        s.visible = false;
        score += 1;
        updateScore();
        msgEl.textContent = score === stars.length ? 'All stars collected! Head to the goal.' : 'Star collected!';
      } else {
        // idle spin
        s.rotation.y += dt * 1.6;
      }
    }

    // Goal check
    tGoal += dt;
    goal.rotation.x = Math.sin(tGoal * 1.2) * 0.2;
    goal.rotation.y += dt * 0.8;

    if (player.position.distanceTo(goal.position) < 1.5) {
      if (score === stars.length) {
        msgEl.textContent = 'You win! Tap to replay.';
        // Tiny celebration pulse
        velocity.multiplyScalar(0.5);
        // Auto respawn on tap
        window.onclick = () => { respawn(); window.onclick = null; };
      } else {
        msgEl.textContent = 'Reach all stars first!';
      }
    }

    // Void fall respawn
    if (player.position.y < voidY) respawn();

    // Camera follow
    camTarget.copy(player.position);
    const desired = camTarget.clone().add(camOffset);
    camera.position.lerp(desired, 0.12);
    camera.lookAt(camTarget);

    // Ambient particles drift
    for (const d of dusts) {
      d.position.x += Math.sin(tGoal + d.id) * 0.003;
      d.position.y += Math.cos(tGoal + d.id) * 0.002;
    }

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // Prevent scrolling on mobile during gameplay
  document.body.addEventListener('touchmove', (e) => { if (stickActive) e.preventDefault(); }, { passive:false });

  // First-time hint auto fade
  setTimeout(() => { msgEl.style.opacity = '0.85'; }, 4000);
})();
</script>
</body>
</html>
