<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini 3D Shooter â€” Health, Medkits & Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#111; }
    canvas { display:block; }
    #ui {
      position:fixed; top:12px; left:12px; color:#fff; font-family:system-ui, sans-serif; z-index:10;
      background:rgba(0,0,0,0.45); padding:10px 12px; border-radius:8px; font-size:14px; line-height:1.35;
      box-shadow:0 6px 18px rgba(0,0,0,0.35);
    }
    #crosshair {
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:12px; height:12px; pointer-events:none; z-index:9;
    }
    #crosshair::before, #crosshair::after { content:""; position:absolute; background:#fff; border-radius:1px; }
    #crosshair::before { left:5px; top:0; width:2px; height:12px; }
    #crosshair::after { left:0; top:5px; width:12px; height:2px; }

    #healthbar {
      margin-top:8px; width:220px; height:14px; background:#2a2a2a; border-radius:7px; overflow:hidden;
      box-shadow: inset 0 0 6px rgba(0,0,0,0.6);
    }
    #healthfill {
      height:100%; width:100%; background: linear-gradient(90deg, #2ecc71, #27ae60);
      transition: width 0.15s ease;
    }
    #levelBanner {
      position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
      color:#fff; font-family:system-ui, sans-serif; font-weight:600; font-size:28px; letter-spacing:0.5px;
      background:rgba(0,0,0,0.55); padding:12px 18px; border-radius:10px; box-shadow:0 10px 28px rgba(0,0,0,0.45);
      z-index:12; display:none;
    }
    #gameOver {
      position:fixed; inset:0; background:rgba(0,0,0,0.75); display:none; align-items:center; justify-content:center; z-index:20;
    }
    #gameOver .panel {
      color:#fff; font-family:system-ui, sans-serif; text-align:center; padding:22px 26px; background:rgba(20,20,24,0.9);
      border-radius:12px; box-shadow:0 16px 36px rgba(0,0,0,0.5); width:340px;
    }
    #gameOver h1 { margin:0 0 8px; font-size:26px; }
    #gameOver p { margin:6px 0 12px; font-size:14px; color:#cbd5e1; }
    #restartBtn {
      border:none; padding:10px 14px; border-radius:8px; font-weight:600; font-size:14px; cursor:pointer;
      background:#3b82f6; color:#fff; box-shadow:0 6px 16px rgba(59,130,246,0.35);
    }
    #tips { font-size:12px; color:#cbd5e1; margin-top:6px; }
  </style>
</head>
<body>
  <div id="ui">
    <div><b>Controls:</b> Click to lock | WASD move | Space jump | Left click shoot | R reset</div>
    <div id="stats"></div>
    <div id="healthbar"><div id="healthfill"></div></div>
    <div id="tips">Pick up medkits to heal. Clear enemies to advance levels.</div>
  </div>
  <div id="crosshair"></div>
  <div id="levelBanner"></div>
  <div id="gameOver">
    <div class="panel">
      <h1>Game Over</h1>
      <p>You were overwhelmed. Want to try again?</p>
      <button id="restartBtn">Restart</button>
    </div>
  </div>
  <canvas id="game"></canvas>

  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

  <script>
  const canvas = document.getElementById('game');
  const statsEl = document.getElementById('stats');
  const healthFillEl = document.getElementById('healthfill');
  const bannerEl = document.getElementById('levelBanner');
  const gameOverEl = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');

  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0e0e12);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1200);
  camera.position.set(0, 1.8, 5);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.6);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5, 10, 2);
  scene.add(hemi, dir);

  const floorGeo = new THREE.PlaneGeometry(240, 240);
  const floorMat = new THREE.MeshStandardMaterial({ color:0x1a1f27, roughness:0.92, metalness:0.0 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  const makeBox = (x,y,z,c=0x3a6ea5) => {
    const m = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({ color:c, roughness:0.7 }));
    m.position.set(x,y,z); m.castShadow = true; m.receiveShadow = true; scene.add(m); return m;
  };
  for (let i=0;i<26;i++){
    makeBox((Math.random()-0.5)*100, 1, (Math.random()-0.5)*100, 0x2e8b57);
  }

  const state = {
    level: 1,
    enemiesTarget: 10,
    enemiesKilled: 0,
    gameOver: false
  };

  const player = {
    pos: new THREE.Vector3().copy(camera.position),
    vel: new THREE.Vector3(),
    yaw: 0, pitch: 0,
    onGround: false,
    speed: 6.2,
    jumpVel: 6.5,
    health: 100,
    maxHealth: 100,
    invulnTime: 0
  };

  const lock = () => canvas.requestPointerLock && canvas.requestPointerLock();
  canvas.addEventListener('click', lock);
  window.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement !== canvas || state.gameOver) return;
    const sensitivity = 0.0025;
    player.yaw -= e.movementX * sensitivity;
    player.pitch -= e.movementY * sensitivity;
    player.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, player.pitch));
    const q = new THREE.Quaternion();
    q.setFromEuler(new THREE.Euler(player.pitch, player.yaw, 0, 'YXZ'));
    camera.quaternion.copy(q);
  });
  const keys = {};
  window.addEventListener('keydown', (e) => keys[e.code] = true);
  window.addEventListener('keyup',   (e) => keys[e.code] = false);

  function getMoveDir(){
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
    fwd.y = 0; right.y = 0; fwd.normalize(); right.normalize();
    const dir = new THREE.Vector3();
    if (keys['KeyW']) dir.add(fwd);
    if (keys['KeyS']) dir.add(fwd.clone().multiplyScalar(-1));
    if (keys['KeyA']) dir.add(right.clone().multiplyScalar(-1));
    if (keys['KeyD']) dir.add(right);
    return dir.lengthSq() ? dir.normalize() : dir;
  }

  const GRAVITY = 18.0;

  function applyPhysics(dt){
    const move = getMoveDir();
    const targetVel = move.multiplyScalar(player.speed);
    const accel = 30;
    player.vel.x = THREE.MathUtils.damp(player.vel.x, targetVel.x, accel, dt);
    player.vel.z = THREE.MathUtils.damp(player.vel.z, targetVel.z, accel, dt);
    player.vel.y -= GRAVITY * dt;

    if (player.onGround && keys['Space']) {
      player.vel.y = player.jumpVel;
      player.onGround = false;
    }

    player.pos.addScaledVector(player.vel, dt);

    const groundY = 1.6;
    if (player.pos.y <= groundY) {
      player.pos.y = groundY;
      player.vel.y = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }

    player.pos.x = THREE.MathUtils.clamp(player.pos.x, -115, 115);
    player.pos.z = THREE.MathUtils.clamp(player.pos.z, -115, 115);

    camera.position.copy(player.pos);
  }

  const bullets = [];
  const bulletGeo = new THREE.SphereGeometry(0.08, 12, 12);
  const bulletMat = new THREE.MeshStandardMaterial({ color:0x88c9ff, emissive:0x084d7a, emissiveIntensity:0.4 });

  function shoot(){
    if (document.pointerLockElement !== canvas || state.gameOver) return;
    const b = new THREE.Mesh(bulletGeo, bulletMat);
    const muzzle = new THREE.Vector3().copy(camera.position);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
    b.position.copy(muzzle).add(dir.clone().multiplyScalar(0.3));
    b.userData.vel = dir.clone().multiplyScalar(35);
    b.userData.life = 2.0;
    bullets.push(b);
    scene.add(b);
  }
  window.addEventListener('mousedown', (e) => { if (e.button===0) shoot(); });

  function updateBullets(dt){
    for (let i=bullets.length-1; i>=0; i--){
      const b = bullets[i];
      b.position.addScaledVector(b.userData.vel, dt);
      b.userData.life -= dt;
      if (b.userData.life <= 0 || b.position.y < 0) {
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }
      for (let j=enemies.length-1; j>=0; j--){
        const e = enemies[j];
        const d = b.position.clone().sub(e.position);
        if (Math.abs(d.x) < 0.7 && Math.abs(d.y) < 0.9 && Math.abs(d.z) < 0.7) {
          e.userData.hp -= 1;
          flash(e);
          scene.remove(b);
          bullets.splice(i,1);
          if (e.userData.hp <= 0) {
            pop(e);
            scene.remove(e);
            enemies.splice(j,1);
            state.enemiesKilled += 1;
            if (enemies.length < currentWaveCount) spawnEnemy();
            checkLevelProgress();
          }
          break;
        }
      }
    }
  }

  const enemies = [];
  const enemyGeo = new THREE.BoxGeometry(1.2,1.2,1.2);
  const enemyBaseMat = new THREE.MeshStandardMaterial({ color:0xcc3344, emissive:0x220008, emissiveIntensity:0.2 });

  let currentEnemySpeedBase = 1.6;
  let currentWaveCount = state.enemiesTarget;

  function spawnEnemy() {
    const e = new THREE.Mesh(enemyGeo, enemyBaseMat.clone());
    const r = 40 + Math.random()*30;
    const a = Math.random()*Math.PI*2;
    e.position.set(Math.cos(a)*r, 0.6, Math.sin(a)*r);
    e.userData.hp = 3;
    enemies.push(e);
    scene.add(e);
  }

  function flash(e){
    e.material.emissiveIntensity = 0.9;
    setTimeout(()=> e.material.emissiveIntensity = 0.2, 80);
  }

  function pop(e){
    const start = performance.now();
    const mat = e.material; const mesh = e; const dur = 250;
    function step(){
      const t = (performance.now() - start)/dur;
      if (t>=1) return;
      mesh.scale.setScalar(1 + t*1.5);
      mat.opacity = 1 - t; mat.transparent = true;
      requestAnimationFrame(step);
    }
    step();
  }

  function updateEnemies(dt){
    for (const e of enemies){
      const toPlayer = player.pos.clone().sub(e.position);
      const dist = Math.sqrt(toPlayer.x*toPlayer.x + toPlayer.z*toPlayer.z);
      if (dist > 0.001){
        toPlayer.y = 0; toPlayer.normalize();
        const speed = currentEnemySpeedBase + THREE.MathUtils.mapLinear(dist, 0, 60, 0.2, 0.8);
        e.position.addScaledVector(toPlayer, speed * dt);
      }
      e.position.y = 0.6 + Math.sin(performance.now()*0.002) * 0.05;

      if (!state.gameOver) {
        const d = player.pos.clone().sub(e.position);
        if (Math.abs(d.x) < 0.7 && Math.abs(d.z) < 0.7) {
          applyDamage(9 * dt);
          const n = new THREE.Vector3(d.x, 0, d.z).normalize();
          player.pos.addScaledVector(n, 0.6 * dt);
        }
      }
    }
  }

  const medkits = [];
  const medkitGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.15, 18);
  const medkitTopGeo = new THREE.BoxGeometry(0.5, 0.2, 0.5);

  function createMedkit(x, z){
    const group = new THREE.Group();
    const base = new THREE.Mesh(medkitGeo, new THREE.MeshStandardMaterial({ color:0xeeeeee, roughness:0.6 }));
    base.position.y = 0.1; group.add(base);
    const top = new THREE.Mesh(medkitTopGeo, new THREE.MeshStandardMaterial({ color:0xd62839, emissive:0x3b0006, emissiveIntensity:0.15 }));
    top.position.y = 0.25; group.add(top);
    const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.22, 0.06), new THREE.MeshStandardMaterial({ color:0xffffff }));
    const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.06, 0.06), new THREE.MeshStandardMaterial({ color:0xffffff }));
    crossV.position.y = 0.28; crossH.position.y = 0.28; group.add(crossV, crossH);
    group.position.set(x, 0, z);
    group.userData.active = true;
    medkits.push(group);
    scene.add(group);
  }

  function scatterMedkits(count=6){
    for (const m of medkits) scene.remove(m);
    medkits.length = 0;
    for (let i=0;i<count;i++){
      const r = 20 + Math.random()*90;
      const a = Math.random()*Math.PI*2;
      createMedkit(Math.cos(a)*r, Math.sin(a)*r);
    }
  }

  function updateMedkits(dt){
    const t = performance.now()*0.002;
    for (const m of medkits){
      m.rotation.y = t;
      if (m.userData.active){
        const d = player.pos.clone().sub(new THREE.Vector3(m.position.x, player.pos.y, m.position.z));
        if (Math.abs(d.x) < 0.9 && Math.abs(d.z) < 0.9){
          heal(25);
          m.userData.active = false;
          const start = performance.now(); const dur = 220;
          function fade(){
            const k = (performance.now() - start)/dur;
            if (k >= 1) { scene.remove(m); return; }
            m.scale.setScalar(1 - 0.6*k);
            requestAnimationFrame(fade);
          }
          fade();
        }
      }
    }
  }

  function applyDamage(amount){
    if (player.invulnTime > 0) return;
    player.health = Math.max(0, player.health - amount);
    player.invulnTime = 0.25;
    updateHealthUI();
    if (player.health <= 0) triggerGameOver();
  }

  function heal(amount){
    if (player.health <= 0) return;
    player.health = Math.min(player.maxHealth, player.health + amount);
    updateHealthUI();
  }

  function updateHealthUI(){
    const pct = Math.max(0, Math.min(100, player.health)) / player.maxHealth;
    healthFillEl.style.width = `${Math.round(pct*100)}%`;
    const g = pct > 0.6 ? '#2ecc71,#27ae60' : pct > 0.3 ? '#f1c40f,#d4ac0f' : '#e74c3c,#c0392b';
    const parts = g.split(',');
    healthFillEl.style.background = `linear-gradient(90deg, ${parts[0]}, ${parts[1]})`;
  }
  updateHealthUI();

  function showBanner(text, ms=1200){
    bannerEl.textContent = text;
    bannerEl.style.display = 'block';
    setTimeout(()=> bannerEl.style.display = 'none', ms);
  }

  function triggerGameOver(){
    state.gameOver = true;
    gameOverEl.style.display = 'flex';
  }

  restartBtn.addEventListener('click', () => restartGame());

  function restartGame(){
    for (const e of enemies) scene.remove(e);
    enemies.length = 0;
    for (const b of bullets) scene.remove(b);
    bullets.length = 0;
    for (const m of medkits) scene.remove(m);
    medkits.length = 0;

    player.pos.set(0, 1.8, 5);
    player.vel.set(0,0,0);
    player.health = player.maxHealth;
    player.invulnTime = 0;
    updateHealthUI();

    state.level = 1;
    state.enemiesKilled = 0;
    state.enemiesTarget = 10;
    currentWaveCount = state.enemiesTarget;
    currentEnemySpeedBase = 1.6;
    state.gameOver = false;

    gameOverEl.style.display = 'none';
    startLevel();
  }

  function startLevel(){
    showBanner(`Level ${state.level}`);
    currentEnemySpeedBase = 1.4 + state.level * 0.25;
    state.enemiesTarget = 8 + Math.floor(state.level * 2.5);
    currentWaveCount = state.enemiesTarget;

    for (const e of enemies) scene.remove(e);
    enemies.length = 0;
    for (let i=0; i<currentWaveCount; i++) spawnEnemy();

    const medkitCount = Math.max(3, 6 - Math.floor(state.level/2));
    scatterMedkits(medkitCount);
  }

  function checkLevelProgress(){
    if (state.enemiesKilled >= totalKillsNeededForLevel()){
      advanceLevel();
    }
  }

  function totalKillsNeededForLevel(){
    return state.enemiesTarget;
  }

  function advanceLevel(){
    state.level += 1;
    state.enemiesKilled = 0;
    showBanner(`Level ${state.level}`);
    startLevel();
  }

  let fps = 0, lastFpsTime = performance.now();
  function updateHUD(dt){
    const now = performance.now();
    fps = 1000 / (now - lastFpsTime);
    lastFpsTime = now;
    statsEl.textContent =
      `Level: ${state.level} | Enemies: ${enemies.length}/${state.enemiesTarget} | Kills: ${state.enemiesKilled} | Bullets: ${bullets.length} | On ground: ${player.onGround ? 'yes' : 'no'} | FPS: ${fps.toFixed(0)}`;
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  let prev = performance.now();
  function loop(){
    const now = performance.now();
    let dt = (now - prev) / 1000;
    prev = now;
    dt = Math.min(dt, 0.05);

    if (!state.gameOver){
      applyPhysics(dt);
      updateEnemies(dt);
      updateBullets(dt);
      updateMedkits(dt);
      if (player.invulnTime > 0) player.invulnTime = Math.max(0, player.invulnTime - dt);
    }
    updateHUD(dt);

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyR') {
      player.pos.set(0, 1.8, 5);
      player.vel.set(0,0,0);
    }
  });

  startLevel();
  loop();
  </script>
</body>
</html>
