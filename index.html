<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Game Hub — Mobile First‑Person (5 Games)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, sans-serif; }
    canvas { display:block; }

    /* Top bar, HUD, menu */
    #topbar { position:absolute; top:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; user-select:none; }
    #topbar .small { font-size:12px; opacity:0.85; font-weight:500; }
    #hud { position:absolute; bottom:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; display:none; }
    #hud .line { margin-top:6px; font-weight:600; }
    #menu { position:absolute; inset:0; display:grid; place-items:center; z-index:11; }
    #menuPanel { width:680px; max-width:92vw; background:#111a; backdrop-filter: blur(6px); border:1px solid #fff2; border-radius:16px; padding:20px; color:#fff; }
    #menuPanel h1 { margin:0 0 8px; font-size:28px; }
    #menuGrid { display:grid; grid-template-columns:repeat(2, minmax(200px, 1fr)); gap:12px; margin-top:10px; }
    .menuBtn { padding:14px; background:#222a; border:1px solid #fff2; color:#fff; border-radius:12px; cursor:pointer; text-align:left; }
    .menuBtn:hover { background:#2a2f; }
    .row { display:flex; gap:8px; align-items:center; margin-top:12px; }
    .pill { padding:8px 12px; border-radius:999px; background:#fff1; border:1px solid #fff2; cursor:pointer; }

    /* Back button and message */
    #backBtn { position:absolute; top:10px; right:10px; z-index:12; padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; display:none; cursor:pointer; }
    #msg { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#fff; z-index:12; text-align:center; font-weight:800; font-size:22px; display:none; }
    #msg button { margin-top:12px; background:#ff6a00; border:none; color:#fff; font-weight:800; padding:10px 16px; border-radius:10px; cursor:pointer; }

    /* Mobile joysticks and buttons */
    #controls { position:absolute; bottom:16px; left:16px; right:16px; z-index:12; display:flex; justify-content:space-between; align-items:flex-end; pointer-events:none; }
    .stick { width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); position:relative; pointer-events:auto; touch-action:none; }
    .knob { position:absolute; width:64px; height:64px; border-radius:50%; background:rgba(255,255,255,0.25); left:calc(50% - 32px); top:calc(50% - 32px); }
    #rightPanel { display:flex; flex-direction:column; align-items:center; gap:12px; pointer-events:auto; }
    .btn { pointer-events:auto; touch-action:none; width:84px; height:84px; border-radius:16px; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); color:#fff; display:grid; place-items:center; font-weight:800; }

    /* Prevent browser gestures on mobile */
    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="title">3D Game Hub — Mobile First‑Person</div>
    <div class="small" id="hint">Left stick: move. Right stick: look. Jump/Action buttons on the right. Esc/Back to menu.</div>
  </div>

  <button id="backBtn">Back to menu</button>

  <div id="menu">
    <div id="menuPanel">
      <h1>Pick a game</h1>
      <div id="menuGrid">
        <button class="menuBtn" data-game="jungle">
          <div style="font-weight:800">Lava Monkey Jungle</div>
          <div class="small">Survive monkeys, rising lava. Collect coins & medkits. First‑person.</div>
        </button>
        <button class="menuBtn" data-game="platformer">
          <div style="font-weight:800">Sky Platforms (Platformer)</div>
          <div class="small">Jump across floating platforms in first‑person to reach the goal.</div>
        </button>
        <button class="menuBtn" data-game="racer">
          <div style="font-weight:800">Desert Ridge Racer</div>
          <div class="small">Drive from the cockpit. Pass gates and finish the course.</div>
        </button>
        <button class="menuBtn" data-game="arena">
          <div style="font-weight:800">Space Drone Arena</div>
          <div class="small">Shoot drones in zero‑g from a first‑person rig.</div>
        </button>
        <button class="menuBtn" data-game="runner">
          <div style="font-weight:800">Forest Endless Runner</div>
          <div class="small">First‑person dodge along lanes. Speed ramps up.</div>
        </button>
      </div>
      <div class="row">
        <div class="pill" id="graphicsLow">Graphics: Low</div>
        <div class="pill" id="graphicsHigh">Graphics: High</div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudPrimary">—</div>
    <div class="line" id="hudSecondary"></div>
  </div>

  <div id="msg">
    <div id="msgText">—</div>
    <button id="restart">Restart</button>
  </div>

  <!-- Mobile controls shared across all games -->
  <div id="controls" style="display:none">
    <div id="leftStick" class="stick"><div class="knob" id="leftKnob"></div></div>
    <div id="rightPanel">
      <div id="rightStick" class="stick"><div class="knob" id="rightKnob"></div></div>
      <div style="display:flex; gap:12px;">
        <div id="jumpBtn" class="btn">JUMP</div>
        <div id="actionBtn" class="btn">ACTION</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Shared renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Shared UI elements
    const menu = document.getElementById('menu');
    const backBtn = document.getElementById('backBtn');
    const hud = document.getElementById('hud');
    const hudPrimary = document.getElementById('hudPrimary');
    const hudSecondary = document.getElementById('hudSecondary');
    const msg = document.getElementById('msg');
    const msgText = document.getElementById('msgText');
    const restartBtn = document.getElementById('restart');
    const graphicsLow = document.getElementById('graphicsLow');
    const graphicsHigh = document.getElementById('graphicsHigh');
    const controls = document.getElementById('controls');
    const jumpBtn = document.getElementById('jumpBtn');
    const actionBtn = document.getElementById('actionBtn');

    // Joystick setup (shared)
    function setupStick(stickId, knobId) {
      const stick = document.getElementById(stickId), knob = document.getElementById(knobId);
      let vec = { x: 0, y: 0 }, active = false;
      function setKnob(x, y) { const r = stick.getBoundingClientRect(); knob.style.left = `${x - r.left - 32}px`; knob.style.top = `${y - r.top - 32}px`; }
      function handle(e, a) {
        const r = stick.getBoundingClientRect(), cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let x = e.clientX, y = e.clientY; if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
        const dx = x - cx, dy = y - cy, len = Math.min(Math.hypot(dx, dy), r.width * 0.45);
        const nx = len ? dx / len : 0, ny = len ? dy / len : 0;
        active = a;
        if (a) { setKnob(cx + nx * len, cy + ny * len); vec = { x: nx * (len / (r.width * 0.45)), y: ny * (len / (r.width * 0.45)) }; }
        else { setKnob(cx, cy); vec = { x: 0, y: 0 }; }
      }
      stick.addEventListener('pointerdown', e => { stick.setPointerCapture(e.pointerId); handle(e, true); });
      stick.addEventListener('pointermove', e => { if (active) handle(e, true); });
      stick.addEventListener('pointerup', e => { stick.releasePointerCapture(e.pointerId); handle(e, false); });
      stick.addEventListener('touchstart', e => handle(e, true), { passive: false });
      stick.addEventListener('touchmove', e => handle(e, true), { passive: false });
      stick.addEventListener('touchend', e => handle(e, false), { passive: false });
      return { get: () => vec };
    }
    const moveStick = setupStick('leftStick', 'leftKnob');
    const lookStick = setupStick('rightStick', 'rightKnob');

    // Prevent iOS pinch/zoom gesture
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Graphics quality
    let quality = 'high';
    graphicsLow.onclick = () => { quality = 'low'; graphicsLow.style.background = '#44aa44'; graphicsHigh.style.background = '#fff1'; };
    graphicsHigh.onclick = () => { quality = 'high'; graphicsHigh.style.background = '#44aa44'; graphicsLow.style.background = '#fff1'; };
    graphicsHigh.click();

    // Shared state
    let scene = null, camera = null, cleanup = null, running = false;
    let keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Escape') showMenu(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    backBtn.onclick = () => showMenu();
    restartBtn.onclick = () => { if (cleanup && cleanup.restart) cleanup.restart(); };

    function showMenu() {
      running = false;
      hud.style.display = 'none';
      backBtn.style.display = 'none';
      controls.style.display = 'none';
      msg.style.display = 'none';
      menu.style.display = 'grid';
      if (cleanup && cleanup.dispose) cleanup.dispose();
      cleanup = null;
      scene = null;
      camera = null;
    }

    function startGame(setup) {
      if (cleanup && cleanup.dispose) cleanup.dispose();
      cleanup = setup(quality);
      scene = cleanup.scene;
      camera = cleanup.camera;
      running = true;
      hud.style.display = 'block';
      backBtn.style.display = 'inline-block';
      controls.style.display = 'flex';
      menu.style.display = 'none';
    }

    // Menu button routing
    document.querySelectorAll('.menuBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const game = btn.dataset.game;
        switch (game) {
          case 'jungle': startGame(setupJungleFP); break;
          case 'platformer': startGame(setupPlatformerFP); break;
          case 'racer': startGame(setupRacerFP); break;
          case 'arena': startGame(setupArenaFP); break;
          case 'runner': startGame(setupRunnerFP); break;
        }
      });
    });

    // Common helpers
    function makeLights(env) {
      const group = new THREE.Group();
      if (env === 'day') {
        const hemi = new THREE.HemisphereLight(0xffffff, 0x228822, 1.0);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(20, 40, 10);
        group.add(hemi, sun);
      } else if (env === 'space') {
        const amb = new THREE.AmbientLight(0x8888aa, 0.9);
        const key = new THREE.DirectionalLight(0xffffff, 0.7);
        key.position.set(15, 25, -10);
        group.add(amb, key);
      }
      return group;
    }

    // Shared first-person camera update for character at "eye" offset
    function updateFirstPersonCamera(cam, playerPos, yaw, pitch, eyeHeight=1.1) {
      cam.position.set(playerPos.x, playerPos.y + eyeHeight, playerPos.z);
      cam.rotation.set(0, 0, 0);
      cam.rotateX(pitch);
      cam.rotateY(yaw);
    }

    // Shared look input from right stick (yaw/pitch clamp)
    function applyLook(yawPitch, dt, sensitivity=1.8) {
      const ls = lookStick.get();
      yawPitch.yaw += ls.x * sensitivity * dt;
      yawPitch.pitch = THREE.MathUtils.clamp(yawPitch.pitch + ls.y * sensitivity * dt, -1.2, 1.2);
    }

    // GAME 1: Jungle (First-Person, Mobile)
    function setupJungleFP(quality) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      sc.add(makeLights('day'));

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(140, 140), new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      function addTree(x, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 2.2, 10), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
        trunk.position.set(x, 1.1, z);
        const foliage = new THREE.Mesh(new THREE.SphereGeometry(1.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0x006400 }));
        foliage.position.set(x, 2.6, z);
        sc.add(trunk, foliage);
      }
      for (let i = 0; i < (quality === 'high' ? 28 : 16); i++) {
        const a = Math.random() * Math.PI * 2, d = 12 + Math.random() * 55;
        addTree(Math.cos(a) * d, Math.sin(a) * d);
      }

      const playerRadius = 0.5;
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.6, 8, 16), new THREE.MeshStandardMaterial({ color: 0x66aaff }));
      player.position.set(0, playerRadius + 0.3, 0); sc.add(player);

      const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.12), new THREE.MeshStandardMaterial({ color: 0x885000 }));
      weapon.position.set(0.45, 0.35, 0.0); player.add(weapon);

      const lava = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 0.3, 32, 1, true),
        new THREE.MeshStandardMaterial({ color: 0xff3c00, emissive: 0xff2200, emissiveIntensity: 0.95 }));
      lava.position.y = -2.5; sc.add(lava);

      const enemies = [];
      function createMonkey() {
        const g = new THREE.Group();
        const m = new THREE.MeshStandardMaterial({ color: 0x7a4b2a });
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.45, 12, 12), m);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 12), m); head.position.set(0, 0.52, 0.02);
        const earL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), m); earL.position.set(-0.22, 0.58, 0.02);
        const earR = earL.clone(); earR.position.x = 0.22;
        g.add(body, head, earL, earR); return g;
      }
      function spawnEnemy() {
        const e = createMonkey();
        const a = Math.random() * Math.PI * 2, d = 16 + Math.random() * 14;
        e.position.set(Math.cos(a) * d, 0.45, Math.sin(a) * d);
        e.userData.speed = 5.9 + Math.random() * 0.8;
        enemies.push(e); sc.add(e);
      }
      let spawnTimer = setInterval(() => { if (run) spawnEnemy(); }, 1000);

      // Collectibles
      const coins = [], medkits = []; let coinsCount = 0;
      function coin() {
        const c = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 20), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
        c.rotation.x = Math.PI / 2;
        c.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110);
        coins.push(c); sc.add(c);
      }
      function medkit() {
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.5), new THREE.MeshStandardMaterial({ color: 0xFF0000 }));
        m.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110);
        medkits.push(m); sc.add(m);
      }
      for (let i = 0; i < (quality === 'high' ? 14 : 8); i++) coin();
      for (let i = 0; i < (quality === 'high' ? 6 : 3); i++) medkit();

      // State
      let run = true, health = 100, start = performance.now();
      const velocity = new THREE.Vector3();
      const accelGround = 16, accelAir = 6, friction = 12, maxSpeed = 7.2, gravity = 18, jumpStrength = 10.8;
      let onGround = true, yaw = 0, pitch = 0;

      hudPrimary.textContent = 'Jungle — Survive';
      hudSecondary.textContent = 'Health 100 | Coins 0';

      // Action binding
      function attack() {
        if (!run) return;
        const forward = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
        const p = player.position.clone();
        const attackRange = 1.6, attackArcCos = Math.cos(Math.PI / 3);
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const to = new THREE.Vector3().subVectors(e.position, p);
          const dist = to.length(); if (dist > attackRange) continue;
          to.normalize(); const dot = to.dot(forward);
          if (dot >= attackArcCos) { sc.remove(e); enemies.splice(i, 1); }
        }
      }
      actionBtn.onclick = attack;

      // Jump binding
      jumpBtn.onclick = () => { if (onGround && run) velocity.y = jumpStrength; };

      function restart() {
        health = 100; coinsCount = 0; start = performance.now();
        velocity.set(0, 0, 0); player.position.set(0, playerRadius + 0.3, 0);
        yaw = 0; pitch = 0; lava.position.y = -2.5;
        enemies.forEach(e => sc.remove(e)); enemies.length = 0;
        coins.forEach(c => sc.remove(c)); coins.length = 0;
        medkits.forEach(m => sc.remove(m)); medkits.length = 0;
        for (let i = 0; i < (quality === 'high' ? 14 : 8); i++) coin();
        for (let i = 0; i < (quality === 'high' ? 6 : 3); i++) medkit();
        hudSecondary.textContent = 'Health 100 | Coins 0';
        run = true; msg.style.display = 'none';
      }

      function dispose() { clearInterval(spawnTimer); }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        update(dt, now) {
          if (!run) return;

          // Look input
          applyLook({ yaw, pitch }, dt);
          // Reassign updated yaw/pitch back (applyLook uses a new object)
          const ls = lookStick.get();
          yaw += ls.x * 1.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ls.y * 1.8 * dt, -1.2, 1.2);

          // Movement input (left stick)
          const mv = moveStick.get();
          let inputX = mv.x, inputY = -mv.y; // stick up is negative y
          const mag = Math.hypot(inputX, inputY);
          if (mag > 1) { inputX /= mag; inputY /= mag; }

          // Direction from yaw
          const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
          const fwd = new THREE.Vector3(sinY, 0, -cosY);
          const right = new THREE.Vector3(cosY, 0, sinY);
          const wishdir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(fwd, inputY);
          if (wishdir.lengthSq() > 0) wishdir.normalize();

          // Accelerate
          const accel = onGround ? accelGround : accelAir;
          velocity.addScaledVector(wishdir, accel * dt);

          // Friction when idle
          if (onGround && mag < 0.05) {
            const horiz = new THREE.Vector2(velocity.x, velocity.z);
            const speed = horiz.length();
            const drop = friction * dt;
            const newSpeed = Math.max(speed - drop, 0);
            if (speed > 0) {
              horiz.multiplyScalar(newSpeed / speed);
              velocity.x = horiz.x; velocity.z = horiz.y;
            }
          }

          // Speed cap
          {
            const horiz = new THREE.Vector2(velocity.x, velocity.z);
            const speed = horiz.length();
            if (speed > maxSpeed) {
              horiz.multiplyScalar(maxSpeed / speed);
              velocity.x = horiz.x; velocity.z = horiz.y;
            }
          }

          // Gravity/integration
          velocity.y -= gravity * dt;
          player.position.addScaledVector(velocity, dt);

          // Ground collision
          const groundY = playerRadius + 0.3;
          if (player.position.y < groundY) { player.position.y = groundY; velocity.y = 0; onGround = true; }
          else onGround = false;

          // Camera
          updateFirstPersonCamera(cam, player.position, yaw, pitch, 1.1);

          // Lava rise
          lava.position.y += 0.018 * dt;

          // Enemies AI + damage
          const bob = Math.sin(now * 0.004) * 0.02;
          for (let i = 0; i < enemies.length; i++) {
            const e = enemies[i];
            e.position.y = 0.45 + bob;
            const toP = new THREE.Vector3().subVectors(player.position, e.position);
            const d = toP.length();
            if (d > 0.0001) toP.normalize();
            e.position.addScaledVector(toP, e.userData.speed * dt);
            if (d < 0.85) { health -= 18 * dt; if (health < 0) health = 0; }
          }

          // Collectibles
          for (let i = coins.length - 1; i >= 0; i--) {
            const c = coins[i];
            if (c.position.distanceTo(player.position) < 0.8) {
              coinsCount += 1; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinsCount}`;
              sc.remove(c); coins.splice(i, 1);
            }
          }
          for (let i = medkits.length - 1; i >= 0; i--) {
            const m = medkits[i];
            if (m.position.distanceTo(player.position) < 0.9) {
              health = Math.min(100, health + 25);
              hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinsCount}`;
              sc.remove(m); medkits.splice(i, 1);
            }
          }

          // Lose conditions
          const feet = player.position.y - groundY;
          const lavaTop = lava.position.y + 0.15;
          if (feet <= lavaTop || health <= 0) {
            run = false; msgText.textContent = 'Game Over — Jungle'; msg.style.display = 'block';
          }

          // HUD time
          const time = ((performance.now() - start) / 1000).toFixed(1);
          hudPrimary.textContent = `Jungle — ${time}s`;
        }
      };
    }

    // GAME 2: Platformer (First-Person)
    function setupPlatformerFP(quality) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87b3ff);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      sc.add(makeLights('day'));

      const platMat = new THREE.MeshStandardMaterial({ color: 0x6aa86a, roughness: 0.8 });
      const plats = [];
      function platform(w, h, d, x, y, z) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), platMat);
        p.position.set(x, y, z);
        sc.add(p); plats.push(p);
      }
      const baseY = 0;
      platform(40, 2, 12, 0, baseY, 0);
      platform(12, 2, 12, 28, baseY + 8, -6);
      platform(16, 2, 12, 48, baseY + 16, 8);
      platform(10, 2, 10, 66, baseY + 24, 0);
      platform(14, 2, 12, 86, baseY + 30, -10);
      platform(20, 2, 12, 110, baseY + 34, 6);

      const goal = new THREE.Mesh(new THREE.TorusKnotGeometry(3, 1, 90, 12), new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0x553300, emissiveIntensity: 0.3 }));
      goal.position.set(120, baseY + 40, 6); sc.add(goal);

      // Player collider (capsule)
      const playerRadius = 0.6;
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.8, 8, 12), new THREE.MeshStandardMaterial({ color: 0x44aaff }));
      player.visible = false; // collider only, FP view
      player.position.set(-16, baseY + 6, 0); sc.add(player);

      const vel = new THREE.Vector3(0, 0, 0);
      const gravity = 18, moveSpeed = 10, jumpVel = 12.5;
      let onGround = false, run = true, won = false;
      let yaw = 0, pitch = 0;

      hudPrimary.textContent = 'Sky Platforms';
      hudSecondary.textContent = 'Reach the glowing goal';

      jumpBtn.onclick = () => { if (onGround && run) vel.y = jumpVel; };
      actionBtn.onclick = () => {}; // no action needed here

      function collide() {
        onGround = false;
        for (const p of plats) {
          const top = p.position.y + p.geometry.parameters.height / 2;
          const halfW = p.geometry.parameters.width / 2;
          const halfD = p.geometry.parameters.depth / 2;
          const withinX = (player.position.x > p.position.x - halfW - playerRadius) && (player.position.x < p.position.x + halfW + playerRadius);
          const withinZ = (player.position.z > p.position.z - halfD - playerRadius) && (player.position.z < p.position.z + halfD + playerRadius);
          const nearTop = Math.abs(player.position.y - (top + playerRadius)) < 0.6 && vel.y <= 0;
          if (withinX && withinZ && nearTop) {
            player.position.y = top + playerRadius;
            vel.y = 0;
            onGround = true;
          }
        }
        if (player.position.y < -30) { run = false; msgText.textContent = 'You fell — Platformer'; msg.style.display = 'block'; }
      }

      function restart() {
        player.position.set(-16, baseY + 6, 0);
        vel.set(0, 0, 0);
        yaw = 0; pitch = 0;
        won = false; run = true; msg.style.display = 'none';
      }
      function dispose() {}

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        update(dt) {
          if (!run || won) return;

          // Look input
          const ls = lookStick.get();
          yaw += ls.x * 1.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ls.y * 1.8 * dt, -1.2, 1.2);

          // Move input
          const mv = moveStick.get();
          let inputX = mv.x, inputY = -mv.y;
          const mag = Math.hypot(inputX, inputY);
          if (mag > 1) { inputX /= mag; inputY /= mag; }

          const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
          const fwd = new THREE.Vector3(sinY, 0, -cosY);
          const right = new THREE.Vector3(cosY, 0, sinY);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(fwd, inputY);
          if (dir.lengthSq() > 0) dir.normalize();

          vel.x = THREE.MathUtils.lerp(vel.x, dir.x * moveSpeed, 8 * dt);
          vel.z = THREE.MathUtils.lerp(vel.z, dir.z * moveSpeed, 8 * dt);

          vel.y -= gravity * dt;
          player.position.addScaledVector(vel, dt);

          collide();

          // Camera FP
          updateFirstPersonCamera(cam, player.position, yaw, pitch, 1.1);

          // Win check
          if (player.position.distanceTo(goal.position) < 5) {
            won = true; msgText.textContent = 'Goal reached! — Platformer'; msg.style.display = 'block';
          }
        }
      };
    }

    // GAME 3: Racer (First-Person cockpit)
    function setupRacerFP(quality) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0xd0b38a);
      const cam = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1200);
      sc.add(makeLights('day'));

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshStandardMaterial({ color: 0xb5894a, roughness: 0.8 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      const car = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 5), new THREE.MeshStandardMaterial({ color: 0x3366ff }));
      car.position.set(0, 0.6, 0); sc.add(car);

      const gates = [];
      function gate(x, z) {
        const g = new THREE.Mesh(new THREE.TorusGeometry(4, 0.3, 12, 24), new THREE.MeshStandardMaterial({ color: 0xffee88 }));
        g.position.set(x, 2.5, z);
        sc.add(g); gates.push(g);
      }
      for (let i = 0; i < 12; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);

      let speed = 0, heading = 0, score = 0, run = true;
      let yaw = 0, pitch = 0; // cockpit look

      hudPrimary.textContent = 'Desert Racer';
      hudSecondary.textContent = 'Gates 0/12';

      // Controls: move stick for throttle/steer, look stick for cockpit look (minor)
      // Action button unused; Jump unused
      actionBtn.onclick = () => {};
      jumpBtn.onclick = () => {};

      function restart() {
        car.position.set(0, 0.6, 0);
        speed = 0; heading = 0; score = 0; run = true; msg.style.display = 'none';
        gates.forEach(g => sc.remove(g)); gates.length = 0;
        for (let i = 0; i < 12; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);
        hudSecondary.textContent = 'Gates 0/12';
      }
      function dispose() {}

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        update(dt) {
          if (!run) return;

          // Look in cockpit (subtle tilt)
          const ls = lookStick.get();
          yaw += ls.x * 0.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ls.y * 0.8 * dt, -0.5, 0.5);

          // Drive inputs
          const mv = moveStick.get();
          const steer = mv.x;              // left/right
          const throttle = Math.max(0, -mv.y); // up on rightStick is negative y; here using left stick forward as throttle
          const brake = Math.max(0, mv.y);     // down as brake

          speed += (throttle * 22 - brake * 28 - speed * 0.85) * dt;
          heading += steer * 1.8 * dt;

          const dir = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
          car.position.addScaledVector(dir, speed * dt);
          car.rotation.y = heading;

          // Camera FP: driver seat (front of car, slight offset)
          const eye = new THREE.Vector3(0, 0.9, 1.2).applyEuler(new THREE.Euler(0, heading, 0));
          const eyePos = new THREE.Vector3().copy(car.position).add(eye);
          cam.position.copy(eyePos);
          cam.rotation.set(0, heading, 0);
          cam.rotateX(pitch);
          cam.rotateY(yaw * 0.2); // minor yaw camera offset

          // Gates
          for (let i = gates.length - 1; i >= 0; i--) {
            const g = gates[i];
            if (car.position.distanceTo(g.position) < 4) {
              score++; sc.remove(g); gates.splice(i, 1);
              hudSecondary.textContent = `Gates ${score}/12`;
            }
          }

          if (gates.length === 0) { run = false; msgText.textContent = 'Finish! — Racer'; msg.style.display = 'block'; }
        }
      };
    }

    // GAME 4: Space Drone Arena (First-Person shooter)
    function setupArenaFP(quality) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x080a12);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      sc.add(makeLights('space'));

      const arena = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 2, 40), new THREE.MeshStandardMaterial({ color: 0x1c2233, metalness: 0.2, roughness: 0.7 }));
      arena.position.y = -2; sc.add(arena);

      const rig = new THREE.Object3D(); // FP rig position
      rig.position.set(0, 1, 0); sc.add(rig);

      const drones = [];
      function drone() {
        const d = new THREE.Mesh(new THREE.TetrahedronGeometry(1.2), new THREE.MeshStandardMaterial({ color: 0xff6666 }));
        const a = Math.random() * Math.PI * 2, r = 40;
        d.position.set(Math.cos(a) * r, 1.2, Math.sin(a) * r);
        d.userData.vel = new THREE.Vector3((Math.random() - 0.5) * 4, 0, (Math.random() - 0.5) * 4);
        sc.add(d); drones.push(d);
      }
      for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) drone();

      const bullets = [];
      function shoot() {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444400 }));
        const dir = new THREE.Vector3(0, 0, -1).applyEuler(cam.rotation);
        b.position.copy(cam.position);
        b.userData.dir = dir.clone();
        sc.add(b); bullets.push(b);
      }
      actionBtn.onclick = shoot;
      jumpBtn.onclick = () => {}; // no jump (zero-g walk), keep free

      let run = true, score = 0;
      let yaw = 0, pitch = 0;

      hudPrimary.textContent = 'Space Arena';
      hudSecondary.textContent = 'Score 0 | ACTION to shoot';

      function restart() {
        drones.forEach(d => sc.remove(d)); drones.length = 0;
        bullets.forEach(b => sc.remove(b)); bullets.length = 0;
        for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) drone();
        score = 0; hudSecondary.textContent = 'Score 0 | ACTION to shoot';
        rig.position.set(0, 1, 0); yaw = 0; pitch = 0; run = true; msg.style.display = 'none';
      }
      function dispose() {}

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        update(dt) {
          if (!run) return;

          // Look input
          const ls = lookStick.get();
          yaw += ls.x * 1.8 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ls.y * 1.8 * dt, -1.2, 1.2);

          // Move input
          const mv = moveStick.get();
          let inputX = mv.x, inputY = -mv.y;
          const mag = Math.hypot(inputX, inputY);
          if (mag > 1) { inputX /= mag; inputY /= mag; }
          const sinY = Math.sin(yaw), cosY = Math.cos(yaw);
          const fwd = new THREE.Vector3(sinY, 0, -cosY);
          const right = new THREE.Vector3(cosY, 0, sinY);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(fwd, inputY);
          if (dir.lengthSq() > 0) dir.normalize();

          rig.position.addScaledVector(dir, 10 * dt);

          // FP camera
          updateFirstPersonCamera(cam, rig.position, yaw, pitch, 0.9);

          // Drones wander, bounce at arena edge
          for (const d of drones) {
            d.position.addScaledVector(d.userData.vel, dt);
            if (d.position.length() > 78) d.userData.vel.multiplyScalar(-1);
          }

          // Bullets
          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.addScaledVector(b.userData.dir, 40 * dt);
            if (b.position.length() > 120) { sc.remove(b); bullets.splice(i, 1); continue; }
            // hits
            for (let j = drones.length - 1; j >= 0; j--) {
              const d = drones[j];
              if (b.position.distanceTo(d.position) < 1.4) {
                sc.remove(d); drones.splice(j, 1);
                sc.remove(b); bullets.splice(i, 1);
                score++; hudSecondary.textContent = `Score ${score} | ACTION to shoot`;
                break;
              }
            }
          }

          if (drones.length === 0) { run = false; msgText.textContent = 'All drones cleared! — Arena'; msg.style.display = 'block'; }
        }
      };
    }

    // GAME 5: Runner (First-Person lanes)
    function setupRunnerFP(quality) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      sc.add(makeLights('day'));

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 60), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      ground.rotation.x = -Math.PI / 2; ground.position.z = -40; sc.add(ground);

      const rig = new THREE.Object3D();
      rig.position.set(0, 1, 0); sc.add(rig);

      const obstacles = [];
      function makeObs(z) {
        const o = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x884444 }));
        o.position.set((Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2, 0.6, -z);
        sc.add(o); obstacles.push(o);
      }
      for (let i = 0; i < (quality === 'high' ? 30 : 18); i++) makeObs(6 + i * 6);

      let laneX = 0, speed = 8, time = 0, run = true, rings = 0;
      let yaw = 0, pitch = 0;

      hudPrimary.textContent = 'Endless Runner';
      hudSecondary.textContent = 'Rings 0';

      jumpBtn.onclick = () => {}; // no jump; runner is lane-based FP
      actionBtn.onclick = () => {}; // no action

      function restart() {
        obstacles.forEach(o => sc.remove(o)); obstacles.length = 0;
        for (let i = 0; i < (quality === 'high' ? 30 : 18); i++) makeObs(6 + i * 6);
        laneX = 0; speed = 8; time = 0; rings = 0; run = true; msg.style.display = 'none';
        rig.position.set(0, 1, 0);
        hudSecondary.textContent = 'Rings 0';
      }
      function dispose() {}

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        update(dt) {
          if (!run) return;
          time += dt;
          speed = 8 + time * 1.2;

          // Look
          const ls = lookStick.get();
          yaw += ls.x * 1.5 * dt;
          pitch = THREE.MathUtils.clamp(pitch + ls.y * 1.0 * dt, -0.4, 0.4);

          // Lane from move stick (left/right)
          const mv = moveStick.get();
          if (mv.x < -0.3) laneX = -2;
          else if (mv.x > 0.3) laneX = 2;
          else laneX = 0;

          rig.position.x = THREE.MathUtils.lerp(rig.position.x, laneX, 6 * dt);

          // Move obstacles forward (towards player)
          for (const o of obstacles) {
            o.position.z += speed * dt;
            if (o.position.z > 4) {
              o.position.z = -180 - Math.random() * 40;
              o.position.x = (Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2;
              rings++; hudSecondary.textContent = `Rings ${rings}`;
            }
            const dist = new THREE.Vector3(o.position.x - rig.position.x, 0.6 - rig.position.y, o.position.z - 0).length();
            if (dist < 1.0) { run = false; msgText.textContent = 'You hit an obstacle — Runner'; msg.style.display = 'block'; }
          }

          // Camera FP
          updateFirstPersonCamera(cam, rig.position, yaw, pitch, 0.9);
        }
      };
    }

    // MAIN LOOP
    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 1000, 1 / 30); last = now;
      if (running && cleanup && cleanup.update) cleanup.update(dt, now);
      if (scene && camera) renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Resize
    window.addEventListener('resize', () => {
      if (!camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start on menu
    showMenu();
  </script>
</body>
</html>
