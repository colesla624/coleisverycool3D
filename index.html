<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mini Fortnite-like 3D Game (Three.js)</title>
  <style>
    body { margin:0; overflow:hidden; background:#87CEEB; }
    #info { position:absolute; top:10px; left:10px; color:white; font-family:Arial; background:rgba(0,0,0,0.5); padding:10px; border-radius:5px; }
    #crosshair { position:absolute; top:50%; left:50%; width:20px; height:20px; margin:-10px 0 0 -10px; pointer-events:none; }
    #crosshair::before, #crosshair::after {
      content:''; position:absolute; background:white;
    }
    #crosshair::before { width:20px; height:2px; top:9px; left:0; }
    #crosshair::after { width:2px; height:20px; top:0; left:9px; }
  </style>
</head>
<body>
  <div id="info">WASD = Move | SPACE = Jump | MOUSE = Look | LEFT CLICK = Shoot</div>
  <div id="crosshair"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://unpkg.com/cannon@0.6.2/build/cannon.min.js"></script>

  <script>
    // ---------- BASIC SETUP ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0005);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Pointer lock controls (first-person style but we'll offset camera for third-person feel)
    const controls = new THREE.PointerLockControls(camera, document.body);
    document.addEventListener('click', () => controls.lock());

    controls.addEventListener('lock', () => document.getElementById('info').style.display = 'none');
    controls.addEventListener('unlock', () => document.getElementById('info').style.display = 'block');

    // ---------- PHYSICS WORLD ----------
    const world = new CANNON.World();
    world.gravity.set(0, -20, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;

    // Ground
    const groundGeo = new THREE.PlaneGeometry(500, 500);
    const groundMat = new THREE.MeshStandardMaterial({color:0x3d9140});
    const groundMesh = new THREE.Mesh(groundGeo, groundMat);
    groundMesh.rotation.x = -Math.PI/2;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    const groundShape = new CANNON.Plane();
    const groundBody = new CANNON.Body({mass:0});
    groundBody.addShape(groundShape);
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
    world.addBody(groundBody);

    // ---------- PLAYER ----------
    const playerRadius = 1.5;
    const playerShape = new CANNON.Sphere(playerRadius);
    const playerBody = new CANNON.Body({mass: 80});
    playerBody.addShape(playerShape);
    playerBody.position.set(0, 5, 0);
    playerBody.linearDamping = 0.9;
    world.addBody(playerBody);

    // Simple player visual (capsule-like)
    const playerGeo = new THREE.CylinderGeometry(0.8, 1, 3, 16);
    const playerMat = new THREE.MeshStandardMaterial({color:0x00aaff});
    const playerMesh = new THREE.Mesh(playerGeo, playerMat);
    playerMesh.castShadow = true;
    scene.add(playerMesh);

    // Third-person offset
    const cameraOffset = new THREE.Vector3(0, 8, 15);

    // ---------- LIGHTING ----------
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    // ---------- SOME BUILDINGS ----------
    function createBuilding(x, z, width=10, depth=10, height=15) {
      const geo = new THREE.BoxGeometry(width, height, depth);
      const mat = new THREE.MeshStandardMaterial({color: Math.random()*0xffffff});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, height/2, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
      const body = new CANNON.Body({mass:0});
      body.addShape(shape);
      body.position.set(x, height/2, z);
      world.addBody(body);
    }

    for(let i=0; i<30; i++) {
      const x = Math.random()*400 - 200;
      const z = Math.random()*400 - 200;
      createBuilding(x, z, 8+Math.random()*12, 8+Math.random()*12, 10+Math.random()*20);
    }

    // ---------- SHOOTING ----------
    const bullets = [];
    const bulletSpeed = 100;
    const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 6);
    const bulletMaterial = new THREE.MeshBasicMaterial({color:0xffff00});

    function shoot() {
      const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
      scene.add(bulletMesh);

      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);

      const bullet = {
        mesh: bulletMesh,
        velocity: direction.multiplyScalar(bulletSpeed),
        life: 100
      };

      // Start from camera position
      bulletMesh.position.copy(camera.position);
      bullets.push(bullet);
    }

    document.addEventListener('mousedown', (e) => {
      if (e.button === 0 && controls.isLocked) shoot();
    });

    // ---------- INPUT ----------
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    // ---------- GAME LOOP ----------
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Player movement
      if (controls.isLocked) {
        const direction = new THREE.Vector3();
        const frontVector = new THREE.Vector3(0,0,-1);
        const sideVector = new THREE.Vector3(1,0,0);
        frontVector.applyQuaternion(camera.quaternion);
        sideVector.applyQuaternion(camera.quaternion);
        frontVector.y = 0; frontVector.normalize();
        sideVector.y = 0; sideVector.normalize();

        const moveSpeed = 20;
        let moveX = 0, moveZ = 0;
        if (keys['KeyW']) moveZ -= moveSpeed * delta;
        if (keys['KeyS']) moveZ += moveSpeed * delta;
        if (keys['KeyA']) moveX -= moveSpeed * delta;
        if (keys['KeyD']) moveX += moveSpeed * delta;

        playerBody.velocity.x = moveX * sideVector.x + moveZ * frontVector.x;
        playerBody.velocity.z = moveX * sideVector.z + moveZ * frontVector.z;

        // Jump
        if (keys['Space'] && Math.abs(playerBody.velocity.y) < 0.1) {
          playerBody.velocity.y = 12;
        }
      }

      // Update physics
      world.step(1/60, delta, 3);

      // Sync player mesh
      playerMesh.position.copy(playerBody.position);
      playerMesh.quaternion.copy(playerBody.quaternion);

      // Third-person camera
      const idealCameraPos = new THREE.Vector3().copy(playerBody.position).add(cameraOffset);
      camera.position.lerp(idealCameraPos, 0.1);
      camera.lookAt(playerBody.position.x, playerBody.position.y + 2, playerBody.position.z);

      // Update bullets
      for(let i = bullets.length-1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.velocity.clone().multiplyScalar(delta));
        b.life--;
        if (b.life <= 0) {
          scene.remove(b.mesh);
          bullets.splice(i,1);
        }
      }

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
