<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Fortnite-Style 3D Game - Fully Working (Copy & Paste)</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:Arial, sans-serif; }
  #info { position:absolute; top:10px; left:10px; color:white; background:rgba(0,0,0,0.6); padding:12px; border-radius:8px; z-index:100; }
  #crosshair { position:absolute; top:50%; left:50%; font-size:32px; color:white; pointer-events:none; transform:translate(-50%,-50%); z-index:100; }
</style>
</head>
<body>

<div id="info">Score: <span id="score">0</span><br>
WASD = Move • SPACE = Jump • Click = Shoot • B = Build Mode (Wheel to switch piece)</div>
<div id="crosshair">+</div>

<!-- Three.js from CDN (latest working version) -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>

<script>
// ================ SCENE SETUP ================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.FogExp2(0x87CEEB, 0.0015);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// ================ POINTER LOCK ================
const controls = new THREE.PointerLockControls(camera, document.body);
document.body.addEventListener('click', () => controls.lock());

// ================ LIGHTS ================
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(100, 150, 100);
sun.castShadow = true;
scene.add(sun);

// ================ GROUND ================
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(1000, 1000),
  new THREE.MeshStandardMaterial({ color: 0x3d8f3e })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ================ PLAYER VARIABLES ================
camera.position.set(0, 1.8, 10);
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let move = { forward: false, backward: false, left: false, right: false };
let canJump = true;
const gravity = -50;

// ================ INPUT ================
document.addEventListener('keydown', e => {
  switch (e.code) {
    case 'KeyW': move.forward = true; break;
    case 'KeyS': move.backward = true; break;
    case 'KeyA': move.left = true; break;
    case 'KeyD': move.right = true; break;
    case 'Space': if (canJump) velocity.y = 15; canJump = false; break;
    case 'KeyB': buildMode = !buildMode; updateUI(); createPreview(); break;
  }
});
document.addEventListener('keyup', e => {
  switch (e.code) {
    case 'KeyW': move.forward = false; break;
    case 'KeyS': move.backward = false; break;
    case 'KeyA': move.left = false; break;
    case 'KeyD': move.right = false; break;
  }
});

// ================ SHOOTING ================
const bullets = [];
function shoot() {
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.15),
    new THREE.MeshBasicMaterial({ color: 0xffff00 })
  );
  bullet.position.copy(camera.position);
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  bullet.velocity = dir.multiplyScalar(120);
  scene.add(bullet);
  bullets.push(bullet);
}

// ================ BUILDING SYSTEM ================
let buildMode = false;
let previewMesh = null;
let currentBuildType = 0;
const buildTypes = ['wall', 'floor', 'ramp'];

function createPreview() {
  if (previewMesh) scene.remove(previewMesh);
  let geo;
  if (buildTypes[currentBuildType] === 'wall') geo = new THREE.BoxGeometry(4, 4, 0.3);
  if (buildTypes[currentBuildType] === 'floor') geo = new THREE.BoxGeometry(4, 0.3, 4);
  if (buildTypes[currentBuildType] === 'ramp') geo = new THREE.BoxGeometry(4, 4, 4);

  previewMesh = new THREE.Mesh(
    geo,
    new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.6 })
  );
  scene.add(previewMesh);
}

function placeStructure() {
  const mat = new THREE.MeshStandardMaterial({ color: 0x8888ff, metalness: 0.2, roughness: 0.8 });
  let mesh;

  if (buildTypes[currentBuildType] === 'wall')
    mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.3), mat);
  if (buildTypes[currentBuildType] === 'floor')
    mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 0.3, 4), mat);
  if (buildTypes[currentBuildType] === 'ramp') {
    mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), mat);
    mesh.rotation.x = -Math.PI / 4;
    mesh.position.y += 2;
  }

  mesh.position.copy(previewMesh.position);
  if (buildTypes[currentBuildType] === 'floor') mesh.position.y = 0.15;
  scene.add(mesh);
  score += 10;
  updateScore();
}

// ================ TARGETS ================
let score = 0;
const targets = [];
function spawnTargets(n) {
  for (let i = 0; i < n; i++) {
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(2, 2, 2),
      new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
    );
    cube.position.set(
      (Math.random() - 0.5) * 300,
      1,
      (Math.random() - 0.5) * 300
    );
    scene.add(cube);
    targets.push(cube);
  }
}
spawnTargets(50);

// ================ UI ================
function updateUI() {
  document.getElementById('info').innerHTML = `
    Score: <b>${score}</b><br>
    WASD Move • SPACE Jump • Click Shoot • B = Build Mode ${buildMode ? '<b>ON</b>' : 'OFF'}
  `;
}
function updateScore() { document.getElementById('score').textContent = score; }
updateUI();

// ================ INPUT HANDLING ================
document.addEventListener('click', () => {
  if (!controls.isLocked) return;
  if (buildMode) placeStructure();
  else shoot();
});

document.addEventListener('wheel', e => {
  if (!buildMode) return;
  currentBuildType = (currentBuildType + (e.deltaY > 0 ? 1 : -1) + 3) % 3;
  createPreview();
});

// ================ MAIN LOOP ================
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  if (controls.isLocked) {
    // Movement
    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    if (move.forward || move.backward) velocity.z = direction.z * 20 * delta;
    else velocity.z *= 0.9;
    if (move.left || move.right) velocity.x = direction.x * 20 * delta;
    else velocity.x *= 0.9;

    // Gravity
    velocity.y += gravity * delta;

    controls.moveRight(velocity.x);
    controls.moveForward(velocity.z);
    controls.getObject().position.y += velocity.y;

    // Floor collision
    if (controls.getObject().position.y < 1.8) {
      velocity.y = 0;
      controls.getObject().position.y = 1.8;
      canJump = true;
    }

    // Build preview
    if (buildMode && previewMesh) {
      const raycaster = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersect = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersect);
      if (intersect) {
        previewMesh.position.copy(intersect);
        previewMesh.position.x = Math.round(previewMesh.position.x / 4) * 4;
        previewMesh.position.z = Math.round(previewMesh.position.z / 4) * 4;
        previewMesh.position.y = (buildTypes[currentBuildType] === 'floor') ? 0.15 : 2;
      }
    }
  }

  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.position.add(b.velocity.clone().multiplyScalar(delta));
    if (b.position.length() > 500) { scene.remove(b); bullets.splice(i, 1); continue; }

    for (let j = targets.length - 1; j >= 0; j--) {
      if (b.position.distanceTo(targets[j].position) < 2) {
        scene.remove(targets[j]);
        targets.splice(j, 1);
        scene.remove(b);
        bullets.splice(i, 1);
        score += 50;
        updateScore();
        break;
      }
    }
  }

  renderer.render(scene, camera);
}
animate();

// Start building preview
createPreview();

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
