<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Game Hub — 18 Games</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui;}
    canvas{display:block;}
    #topbar{position:absolute;top:10px;left:10px;z-index:12;color:#fff;font-weight:700;text-shadow:0 1px 2px #000;}
    #backBtn{position:absolute;top:10px;right:10px;z-index:12;padding:10px 14px;border-radius:12px;border:1px solid #fff2;background:#111a;color:#fff;display:none;cursor:pointer;}
    #menu{position:absolute;inset:0;display:grid;place-items:center;z-index:11;}
    #menuPanel{width:1100px;max-width:96vw;background:#111a;backdrop-filter:blur(8px);border:1px solid #fff2;border-radius:16px;padding:20px;color:#fff;}
    #menuGrid{display:grid;grid-template-columns:repeat(3,minmax(260px,1fr));gap:10px;margin-top:10px;}
    .menuBtn{padding:12px;background:#222a;border:1px solid #fff2;color:#fff;border-radius:12px;cursor:pointer;text-align:left;}
    .menuBtn:hover{background:#2a2f;}
    .row{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap;}
    .pill{padding:8px 12px;border-radius:999px;background:#fff1;border:1px solid #fff2;cursor:pointer;}
    .levelBtn{padding:8px 12px;border-radius:999px;background:#222a;border:1px solid #fff2;color:#fff;cursor:pointer;}
    #hud{position:absolute;bottom:10px;left:10px;z-index:12;color:#fff;font-weight:700;text-shadow:0 1px 2px #000;display:none;}
    #settingsBar{position:absolute;top:56px;right:10px;z-index:12;display:none;gap:8px;}
    .settingsBtn{padding:10px 14px;border-radius:12px;border:1px solid #fff2;background:#111a;color:#fff;cursor:pointer;}
    #skins,#shop,#leaderboard{position:absolute;left:50%;transform:translateX(-50%);background:#1e1e1e;color:#fff;padding:20px;border-radius:12px;display:none;z-index:13;border:1px solid #fff2;}
    #skins{top:16%;width:460px;}
    #shop{top:18%;width:380px;}
    #leaderboard{top:22%;width:520px;}
    #skins .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;}
    .swatch{height:40px;border-radius:10px;border:1px solid #fff3;cursor:pointer;}
    #leaderboard table{width:100%;border-collapse:collapse;}
    #leaderboard th,#leaderboard td{border-bottom:1px solid #444;padding:6px 8px;text-align:left;}
    #msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;z-index:12;text-align:center;font-weight:800;font-size:22px;display:none;}
    #msg button{margin-top:12px;background:#ff6a00;border:none;color:#fff;font-weight:800;padding:10px 16px;border-radius:10px;cursor:pointer;}
    #controls{position:absolute;bottom:16px;left:16px;right:16px;z-index:12;display:flex;justify-content:space-between;align-items:flex-end;pointer-events:none;}
    .stick{width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.08);border:2px solid rgba(255,255,255,0.2);position:relative;pointer-events:auto;touch-action:none;}
    .knob{position:absolute;width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,0.25);left:calc(50% - 32px);top:calc(50% - 32px);}
    #rightPanel{display:flex;flex-direction:column;align-items:center;gap:12px;pointer-events:auto;}
    .btn{pointer-events:auto;touch-action:none;width:84px;height:84px;border-radius:16px;background:rgba(255,255,255,0.08);border:2px solid rgba(255,255,255,0.2);color:#fff;display:grid;place-items:center;font-weight:800;}
    *{-webkit-tap-highlight-color:transparent;}
  </style>
</head>
<body>
  <div id="topbar">
    <div id="title">3D Game Hub — 18 Games</div>
    <div class="small" id="hint">Left: move. Right: look. Jump/Action. Esc returns to menu.</div>
  </div>

  <button id="backBtn">Back to menu</button>

  <div id="menu">
    <div id="menuPanel">
      <h1>Pick a game</h1>
      <div id="menuGrid">
        <button class="menuBtn" data-game="jungle">Jungle</button>
        <button class="menuBtn" data-game="platformer">Sky Platforms</button>
        <button class="menuBtn" data-game="racer">Racer</button>
        <button class="menuBtn" data-game="arena">Arena</button>
        <button class="menuBtn" data-game="runner">Runner</button>
        <button class="menuBtn" data-game="maze">Maze</button>
        <button class="menuBtn" data-game="range">Range</button>
        <button class="menuBtn" data-game="voxel">Voxel</button>
        <button class="menuBtn" data-game="icecavern">Ice Cavern</button>
        <button class="menuBtn" data-game="volcano">Volcano Dash</button>
        <button class="menuBtn" data-game="asteroids">Asteroid Field</button>
        <button class="menuBtn" data-game="underwater">Underwater</button>
        <button class="menuBtn" data-game="haunted">Haunted Mansion</button>
        <button class="menuBtn" data-game="factory">Robot Factory</button>
        <button class="menuBtn" data-game="glider">Sky Glider</button>
        <button class="menuBtn" data-game="sandstorm">Sandstorm Survival</button>
        <button class="menuBtn" data-game="crystal">Crystal Collector</button>
        <button class="menuBtn" data-game="tower">Tower Climb</button>
      </div>

      <div class="row">
        <div class="pill" id="graphicsLow">Graphics: Low</div>
        <div class="pill" id="graphicsHigh">Graphics: High</div>
        <div class="pill" id="skinsBtn">Player skins</div>
        <div class="pill" id="leaderboardBtn">Leaderboard</div>
        <div class="pill" id="exitBtn">Exit</div>
      </div>

      <!-- OWNER CODE BOX (replaces prompt) -->
      <div class="row">
        <input id="ownerInput" placeholder="Enter owner code" style="padding:6px;border-radius:8px;border:1px solid #fff2;background:#222;color:#fff;">
        <button id="ownerBtn" class="pill">Unlock Owner</button>
        <span id="ownerBadge" style="font-weight:700; color:#ff3b3b; display:none;">OWNER MODE ENABLED</span>
      </div>

      <div class="row" id="levelBar">
        <span class="small" style="opacity:0.8">Start level:</span>
        <button class="levelBtn" data-level="0">Level 1</button>
        <button class="levelBtn" data-level="1">Level 2</button>
        <button class="levelBtn" data-level="2">Level 3</button>
        <button class="levelBtn" data-level="3">Level 4</button>
        <button class="levelBtn" data-level="4">Level 5</button>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudPrimary">—</div>
    <div class="line" id="hudSecondary">—</div>
  </div>

  <div id="settingsBar" style="display:none">
    <button id="shopBtn" class="settingsBtn">SHOP</button>
  </div>

  <div id="skins" style="display:none">
    <h2>Choose your player skin</h2>
    <div class="grid">
      <div class="swatch" data-skin="blue" style="background:#4da3ff"></div>
      <div class="swatch" data-skin="red" style="background:#ff4d4d"></div>
      <div class="swatch" data-skin="green" style="background:#43c86b"></div>
      <div class="swatch" data-skin="purple" style="background:#aa66ff"></div>
      <div class="swatch" data-skin="orange" style="background:#ff9a3c"></div>
      <div class="swatch" data-skin="white" style="background:#f0f0f0"></div>
      <div class="swatch" data-skin="black" style="background:#222"></div>
      <div class="swatch" data-skin="yellow" style="background:#ffd84d"></div>
    </div>
    <div class="row"><span style="opacity:0.8">Applies to all games.</span></div>
    <button id="closeSkins">Close</button>
  </div>

  <div id="shop" style="display:none">
    <h2>Shop</h2>
    <div class="row"><span>Weapon upgrade</span><button data-cost="10" data-type="weapon">Buy (10)</button></div>
    <div class="row"><span>Map: Night</span><button data-cost="20" data-type="mapNight">Buy (20)</button></div>
    <div class="row"><span>Map: Day</span><button data-cost="0" data-type="mapDay">Use</button></div>
    <button id="closeShop">Close</button>
  </div>

  <div id="leaderboard" style="display:none">
    <h2>Leaderboard</h2>
    <div class="row">
      <label>Game:
        <select id="lbGame">
          <option value="jungle">Jungle</option>
          <option value="platformer">Platformer</option>
          <option value="racer">Racer</option>
          <option value="arena">Arena</option>
          <option value="runner">Runner</option>
          <option value="maze">Maze</option>
          <option value="range">Range</option>
          <option value="voxel">Voxel</option>
          <option value="icecavern">Ice Cavern</option>
          <option value="volcano">Volcano Dash</option>
          <option value="asteroids">Asteroids</option>
          <option value="underwater">Underwater</option>
          <option value="haunted">Haunted</option>
          <option value="factory">Factory</option>
          <option value="glider">Glider</option>
          <option value="sandstorm">Sandstorm</option>
          <option value="crystal">Crystal Collector</option>
          <option value="tower">Tower Climb</option>
        </select>
      </label>
    </div>
    <table id="lbTable">
      <thead><tr><th>Rank</th><th>Name</th><th>Score</th><th>Date</th></tr></thead>
      <tbody></tbody>
    </table>
    <button id="closeLeaderboard">Close</button>
    <button id="resetLeaderboard">Reset</button>
  </div>

  <div id="msg">
    <div id="msgText">—</div>
    <button id="restart">Restart</button>
  </div>

  <div id="controls" style="display:none">
    <div id="leftStick" class="stick"><div class="knob" id="leftKnob"></div></div>
    <div id="rightPanel">
      <div id="rightStick" class="stick"><div class="knob" id="rightKnob"></div></div>
      <div style="display:flex; gap:12px;">
        <div id="jumpBtn" class="btn">JUMP</div>
        <div id="actionBtn" class="btn">ACTION</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // UI refs
    const menu = document.getElementById('menu');
    const backBtn = document.getElementById('backBtn');
    const hud = document.getElementById('hud');
    const hudPrimary = document.getElementById('hudPrimary');
    const hudSecondary = document.getElementById('hudSecondary');
    const msg = document.getElementById('msg');
    const msgText = document.getElementById('msgText');
    const restartBtn = document.getElementById('restart');
    const graphicsLow = document.getElementById('graphicsLow');
    const graphicsHigh = document.getElementById('graphicsHigh');
    const controls = document.getElementById('controls');
    const jumpBtn = document.getElementById('jumpBtn');
    const actionBtn = document.getElementById('actionBtn');
    const settingsBar = document.getElementById('settingsBar');
    const shopBtn = document.getElementById('shopBtn');
    const shopEl = document.getElementById('shop');
    const closeShopBtn = document.getElementById('closeShop');
    const skinsBtn = document.getElementById('skinsBtn');
    const skinsEl = document.getElementById('skins');
    const closeSkinsBtn = document.getElementById('closeSkins');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const leaderboardEl = document.getElementById('leaderboard');
    const lbGame = document.getElementById('lbGame');
    const lbTable = document.getElementById('lbTable').querySelector('tbody');
    const closeLeaderboardBtn = document.getElementById('closeLeaderboard');
    const resetLeaderboardBtn = document.getElementById('resetLeaderboard');
    const exitBtn = document.getElementById('exitBtn');
    const ownerBadge = document.getElementById('ownerBadge');
    const ownerInput = document.getElementById('ownerInput');
    const ownerBtn = document.getElementById('ownerBtn');

    // Joysticks
    function setupStick(stickId, knobId) {
      const stick = document.getElementById(stickId), knob = document.getElementById(knobId);
      let vec = { x: 0, y: 0 }, active = false;
      function setKnob(x, y) { const r = stick.getBoundingClientRect(); knob.style.left = `${x - r.left - 32}px`; knob.style.top = `${y - r.top - 32}px`; }
      function handle(e, a) {
        const r = stick.getBoundingClientRect(), cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let x = e.clientX, y = e.clientY; if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
        const dx = x - cx, dy = y - cy, len = Math.min(Math.hypot(dx, dy), r.width * 0.45);
        const nx = len ? dx / len : 0, ny = len ? dy / len : 0;
        active = a;
        if (a) { setKnob(cx + nx * len, cy + ny * len); vec = { x: nx * (len / (r.width * 0.45)), y: ny * (len / (r.width * 0.45)) }; }
        else { setKnob(cx, cy); vec = { x: 0, y: 0 }; }
      }
      stick.addEventListener('pointerdown', e => { stick.setPointerCapture(e.pointerId); handle(e, true); });
      stick.addEventListener('pointermove', e => { if (active) handle(e, true); });
      stick.addEventListener('pointerup', e => { stick.releasePointerCapture(e.pointerId); handle(e, false); });
      stick.addEventListener('touchstart', e => handle(e, true), { passive: false });
      stick.addEventListener('touchmove', e => handle(e, true), { passive: false });
      stick.addEventListener('touchend', e => handle(e, false), { passive: false });
      return { get: () => vec };
    }
    const moveStick = setupStick('leftStick', 'leftKnob');
    const lookStick = setupStick('rightStick', 'rightKnob');

    // Graphics
    let quality = 'high';
    graphicsLow.onclick = () => { quality = 'low'; graphicsLow.style.background = '#44aa44'; graphicsHigh.style.background = '#fff1'; };
    graphicsHigh.onclick = () => { quality = 'high'; graphicsHigh.style.background = '#44aa44'; graphicsLow.style.background = '#fff1'; };
    graphicsHigh.click();

    // Owner unlock via input (no prompt)
    const OWNER_CODE = "12345";
    let ownerUnlocked = false;
    if (localStorage.getItem("ownerUnlocked") === "true") {
      ownerUnlocked = true; ownerBadge.style.display = 'inline';
    }
    ownerBtn.onclick = () => {
      const val = ownerInput.value.trim();
      if (val === OWNER_CODE) {
        ownerUnlocked = true; localStorage.setItem("ownerUnlocked","true");
        ownerBadge.style.display = 'inline';
        if (cleanup && cleanup.applyOwner) cleanup.applyOwner(true);
      }
    };

    // Hub state
    let scene = null, camera = null, cleanup = null, running = false, selectedLevel = 0;
    const gameOrder = [
      'jungle','platformer','racer','arena','runner','maze','range','voxel',
      'icecavern','volcano','asteroids','underwater','haunted','factory','glider','sandstorm','crystal','tower'
    ];
    const maxLevels = 5;

    let keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Escape') showMenu(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // Skin color
    function skinToColor(skin) {
      switch (skin) {
        case 'red': return 0xff4d4d;
        case 'green': return 0x43c86b;
        case 'purple': return 0xaa66ff;
        case 'orange': return 0xff9a3c;
        case 'white': return 0xf0f0f0;
        case 'black': return 0x222222;
        case 'yellow': return 0xffd84d;
        default: return 0x4da3ff;
      }
    }
    const shared = {
      skin: localStorage.getItem('skin') || 'blue',
      name: localStorage.getItem('name') || '',
      currentGame: null,
      owner: ownerUnlocked
    };

    // Owner label cosmetic
    function makeOwnerLabel() {
      const canvas = document.createElement('canvas');
      canvas.width = 256; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ff3b3b'; ctx.font = 'bold 60px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('OWNER', canvas.width/2, canvas.height/2);
      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.4, 1.2, 1);
      sprite.position.set(0, 1.9, 0);
      return sprite;
    }

    // Skins
    const skinsBtn = document.getElementById('skinsBtn');
    const skinsEl = document.getElementById('skins');
    const closeSkinsBtn = document.getElementById('closeSkins');
    skinsBtn.onclick = () => { skinsEl.style.display = 'block'; };
    closeSkinsBtn.onclick = () => { skinsEl.style.display = 'none'; };
    skinsEl.addEventListener('click', (e) => {
      if (e.target.classList.contains('swatch')) {
        shared.skin = e.target.dataset.skin;
        localStorage.setItem('skin', shared.skin);
        if (cleanup && cleanup.applySkin) cleanup.applySkin(shared.skin);
      }
    });

    // Exit
    exitBtn.onclick = () => { window.location.href = 'about:blank'; };

    // Levels select
    document.querySelectorAll('.levelBtn').forEach(b => {
      b.onclick = () => {
        selectedLevel = parseInt(b.dataset.level,10) || 0;
        b.style.background = '#44aa44';
        document.querySelectorAll('.levelBtn').forEach(o => { if (o !== b) o.style.background = '#222a'; });
      };
    });

    // Leaderboard (localStorage)
    function getLB() { const raw = localStorage.getItem('leaderboard'); return raw ? JSON.parse(raw) : {}; }
    function setLB(data) { localStorage.setItem('leaderboard', JSON.stringify(data)); }
    function addScore(game, name, score) {
      const lb = getLB();
      if (!lb[game]) lb[game] = [];
      lb[game].push({ name: name || 'Player', score, date: new Date().toISOString() });
      lb[game].sort((a,b)=>b.score-a.score);
      lb[game] = lb[game].slice(0, 20);
      setLB(lb);
    }
    function refreshLeaderboard(game) {
      const lb = getLB()[game] || [];
      lbTable.innerHTML = '';
      lb.forEach((row, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${row.name}</td><td>${row.score}</td><td>${new Date(row.date).toLocaleString()}</td>`;
        lbTable.appendChild(tr);
      });
    }
    leaderboardBtn.onclick = () => { leaderboardEl.style.display = 'block'; refreshLeaderboard(lbGame.value); };
    closeLeaderboardBtn.onclick = () => { leaderboardEl.style.display = 'none'; };
    lbGame.onchange = () => refreshLeaderboard(lbGame.value);
    resetLeaderboardBtn.onclick = () => { localStorage.removeItem('leaderboard'); refreshLeaderboard(lbGame.value); };

    // Shop
    const shopBtn = document.getElementById('shopBtn');
    const shopEl = document.getElementById('shop');
    const closeShopBtn = document.getElementById('closeShop');
    shopBtn.onclick = () => { shopEl.style.display = 'block'; };
    closeShopBtn.onclick = () => { shopEl.style.display = 'none'; };
    shopEl.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON' || e.target.id === 'closeShop') return;
      const cost = parseInt(e.target.dataset.cost || '0', 10);
      if (cleanup && cleanup.getCurrency && cleanup.setCurrency) {
        const coins = cleanup.getCurrency();
        if (cost > coins) { alert('Not enough currency'); return; }
        if (cost > 0) cleanup.setCurrency(coins - cost);
      }
      const type = e.target.dataset.type;
      if (type === 'weapon' && cleanup.applyWeaponUpgrade) cleanup.applyWeaponUpgrade();
      if (type === 'mapNight' && cleanup.applyMapVariant) cleanup.applyMapVariant('night');
      if (type === 'mapDay' && cleanup.applyMapVariant) cleanup.applyMapVariant('day');
    });

    // Camera helpers
    function updateThirdPersonCamera(cam, playerPos, yaw, pitch=0, dist=6.8, height=2.6) {
      const h = height + Math.sin(pitch) * 0.5;
      const offset = new THREE.Vector3(Math.sin(yaw) * dist, h, -Math.cos(yaw) * dist);
      cam.position.copy(playerPos).add(offset);
      cam.lookAt(playerPos.x, playerPos.y + 1.0, playerPos.z);
    }
    function getCameraBasisXZ(cam, center) {
      const forward = new THREE.Vector3().subVectors(center, cam.position);
      forward.y = 0; if (forward.lengthSq() < 1e-6) forward.set(0,0,-1);
      forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
      return { forward, right };
    }
    function getLookDelta(mult=1.8) { const ls = lookStick.get(); return { lx: ls.x * mult, ly: ls.y * mult }; }
    function getMoveInput(keys, mv) {
      let inputX = mv.x, inputY = -mv.y;
      const kForward = (keys.KeyW || keys.ArrowUp) ? 1 : 0;
      const kBack = (keys.KeyS || keys.ArrowDown) ? 1 : 0;
      const kLeft = (keys.KeyA || keys.ArrowLeft) ? 1 : 0;
      const kRight = (keys.KeyD || keys.ArrowRight) ? 1 : 0;
      inputX += (kRight - kLeft); inputY += (kForward - kBack);
      const mag = Math.hypot(inputX, inputY); if (mag > 1) { inputX /= mag; inputY /= mag; }
      return { inputX, inputY };
    }

    // Lights
    function makeLights(env) {
      const group = new THREE.Group();
      if (env === 'day') {
        const hemi = new THREE.HemisphereLight(0xffffff, 0x228822, 1.0);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5); sun.position.set(20, 40, 10);
        group.add(hemi, sun);
      } else if (env === 'space') {
        const amb = new THREE.AmbientLight(0x8888aa, 0.9);
        const key = new THREE.DirectionalLight(0xffffff, 0.7); key.position.set(15, 25, -10);
        group.add(amb, key);
      } else if (env === 'maze') {
        const amb = new THREE.AmbientLight(0x6666ff, 0.6);
        const key = new THREE.PointLight(0x88aaff, 1.0, 200); key.position.set(0, 20, 0);
        group.add(amb, key);
      } else if (env === 'ice') {
        const hemi = new THREE.HemisphereLight(0xccffff, 0x113355, 1.0);
        const sun = new THREE.DirectionalLight(0xddeeff, 1.2); sun.position.set(10, 30, -10);
        group.add(hemi, sun);
      } else if (env === 'volcano') {
        const amb = new THREE.AmbientLight(0x442200, 0.6);
        const key = new THREE.DirectionalLight(0xffaa00, 1.2); key.position.set(10, 30, 10);
        group.add(amb, key);
      } else if (env === 'underwater') {
        const amb = new THREE.AmbientLight(0x224466, 0.9);
        const key = new THREE.DirectionalLight(0xaadfff, 0.8); key.position.set(-10, 20, 10);
        group.add(amb, key);
      } else if (env === 'haunted') {
        const amb = new THREE.AmbientLight(0x333344, 0.7);
        const key = new THREE.DirectionalLight(0xffffff, 0.5); key.position.set(0, 20, 0);
        group.add(amb, key);
      } else if (env === 'factory') {
        const amb = new THREE.AmbientLight(0x666666, 0.8);
        const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(15, 25, 15);
        group.add(amb, key);
      } else if (env === 'sand') {
        const amb = new THREE.AmbientLight(0xffe0a0, 0.8);
        const sun = new THREE.DirectionalLight(0xffdd99, 1.0); sun.position.set(30, 50, -20);
        group.add(amb, sun);
      }
      return group;
    }

    // PRNG
    function makeRand(seed) { let s = seed >>> 0; return () => { s = (s * 1664525 + 1013904223) >>> 0; return (s & 0xffffffff) / 0x100000000; }; }

    // Level configs
    const jungleLevels = [
      { size: 160, trees: 24, coins: 12, kits: 4, lavaSpeed: 0.015, enemyRate: 1.2, seed: 101 },
      { size: 200, trees: 32, coins: 16, kits: 5, lavaSpeed: 0.020, enemyRate: 1.0, seed: 202 },
      { size: 240, trees: 40, coins: 20, kits: 6, lavaSpeed: 0.022, enemyRate: 0.9, seed: 303 },
      { size: 280, trees: 50, coins: 26, kits: 6, lavaSpeed: 0.025, enemyRate: 0.85, seed: 404 },
      { size: 320, trees: 60, coins: 32, kits: 7, lavaSpeed: 0.028, enemyRate: 0.8, seed: 505 },
    ];
    const platformerLevels = [
      { len: 14, segment: 32, heightStep: 12, layoutVar: 1.6, moveSpeed: 13, jumpVel: 17.8, seed: 55 },
      { len: 16, segment: 34, heightStep: 12, layoutVar: 1.6, moveSpeed: 13.5, jumpVel: 18.0, seed: 66 },
      { len: 18, segment: 36, heightStep: 12, layoutVar: 1.6, moveSpeed: 14, jumpVel: 18.2, seed: 77 },
      { len: 20, segment: 38, heightStep: 12, layoutVar: 1.6, moveSpeed: 14.5, jumpVel: 18.4, seed: 88 },
      { len: 22, segment: 40, heightStep: 12, layoutVar: 1.6, moveSpeed: 15, jumpVel: 18.6, seed: 99 },
    ];
    const racerLevels = [
      { gates: 22, amp: 55, freq: 0.8, turn: 2.0, seed: 88 },
      { gates: 26, amp: 70, freq: 0.9, turn: 2.2, seed: 99 },
      { gates: 30, amp: 85, freq: 1.0, turn: 2.4, seed: 111 },
      { gates: 34, amp: 100, freq: 1.1, turn: 2.6, seed: 123 },
      { gates: 38, amp: 120, freq: 1.2, turn: 2.8, seed: 135 },
    ];
    const arenaLevels = [
      { drones: 12, waveSpeed: 4, seed: 9 }, { drones: 16, waveSpeed: 4.5, seed: 19 }, { drones: 20, waveSpeed: 5, seed: 29 }, { drones: 26, waveSpeed: 5.5, seed: 39 }, { drones: 32, waveSpeed: 6, seed: 49 }
    ];
    const runnerLevels = [
      { length: 340, obstacles: 36, accel: 1.10, seed: 23 },
      { length: 420, obstacles: 44, accel: 1.15, seed: 33 },
      { length: 520, obstacles: 56, accel: 1.20, seed: 43 },
      { length: 640, obstacles: 68, accel: 1.25, seed: 53 },
      { length: 760, obstacles: 80, accel: 1.30, seed: 63 },
    ];
    const mazeLevels = [ { cells: 11, seed: 12 }, { cells: 13, seed: 18 }, { cells: 15, seed: 24 }, { cells: 17, seed: 30 }, { cells: 19, seed: 36 } ];
    const rangeLevels = [ { targets: 16, respawn: 0.9, spread: 80, seed: 81 }, { targets: 20, respawn: 0.85, spread: 90, seed: 91 }, { targets: 24, respawn: 0.8, spread: 100, seed: 101 }, { targets: 28, respawn: 0.75, spread: 110, seed: 111 }, { targets: 32, respawn: 0.7, spread: 120, seed: 121 } ];
    const voxelLevels = [ { size: 28, startBlocks: 140, goalDelta: 24, seed: 202 }, { size: 32, startBlocks: 180, goalDelta: 28, seed: 203 }, { size: 36, startBlocks: 220, goalDelta: 32, seed: 204 }, { size: 40, startBlocks: 260, goalDelta: 36, seed: 205 }, { size: 44, startBlocks: 300, goalDelta: 40, seed: 206 } ];
    const simpleLevels = (seedBase) => Array.from({length:5}, (_,i)=>({seed: seedBase+i, count: 24+ i*6}));

    // Registry
    const gameSetups = {};

    // ————— Game 1 — Jungle —————
    function setupJungleTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = jungleLevels[levelIndex] || jungleLevels[0]; const rand = makeRand(lvl.seed);
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1200);
      const lights = makeLights('day'); sc.add(lights);
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(lvl.size, lvl.size), new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);
      function addTree(x, z) { const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 2.2, 10), new THREE.MeshStandardMaterial({ color: 0x8B4513 })); trunk.position.set(x, 1.1, z); const foliage = new THREE.Mesh(new THREE.SphereGeometry(1.3, 18, 18), new THREE.MeshStandardMaterial({ color: 0x006400 })); foliage.position.set(x, 2.6, z); sc.add(trunk, foliage); }
      for (let i = 0; i < lvl.trees; i++) { const a = rand() * Math.PI * 2, d = 18 + rand() * (lvl.size * 0.45); addTree(Math.cos(a) * d, Math.sin(a) * d); }
      const playerRadius = 0.5; const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.6, 8, 16), playerMat); player.position.set(0, playerRadius + 0.3, 0); sc.add(player); if (ownerFlag) player.add(makeOwnerLabel());
      const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.12), new THREE.MeshStandardMaterial({ color: 0x885000 })); weapon.position.set(0.45, 0.35, 0.0); player.add(weapon);
      const lava = new THREE.Mesh(new THREE.CylinderGeometry(lvl.size*0.6, lvl.size*0.6, 0.3, 64, 1, true), new THREE.MeshStandardMaterial({ color: 0xff3c00, emissive: 0xff2200, emissiveIntensity: 0.95 })); lava.position.y = -2.5; sc.add(lava);
      const enemies = []; function createMonkey(){const g=new THREE.Group(); const m=new THREE.MeshStandardMaterial({color:0x7a4b2a}); const body=new THREE.Mesh(new THREE.SphereGeometry(0.45,16,16),m); const head=new THREE.Mesh(new THREE.SphereGeometry(0.28,16,16),m); head.position.set(0,0.52,0.02); const earL=new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8),m); earL.position.set(-0.22,0.58,0.02); const earR=earL.clone(); earR.position.x=0.22; g.add(body,head,earL,earR); return g;}
      function spawnEnemy(){const e=createMonkey(); const a=rand()*Math.PI*2, d=16+rand()*22+levelIndex*3; e.position.set(Math.cos(a)*d,0.45,Math.sin(a)*d); e.userData.speed=5.8+rand()*1.2+levelIndex*0.2; enemies.push(e); sc.add(e);}
      let run = true; let spawnTimer = setInterval(() => { if (run) spawnEnemy(); }, 1000 * lvl.enemyRate);
      const coins = [], medkits = []; let coinCount = 0;
      function coin(){const c=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,0.1,24), new THREE.MeshStandardMaterial({color:0xFFD700})); c.rotation.x=Math.PI/2; const a=rand()*Math.PI*2, r=30+rand()*(lvl.size*0.35); c.position.set(Math.cos(a)*r,0.15,Math.sin(a)*r); coins.push(c); sc.add(c);}
      function medkit(){const m=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.5), new THREE.MeshStandardMaterial({color:0xFF0000})); const a=rand()*Math.PI*2, r=30+rand()*(lvl.size*0.35); m.position.set(Math.cos(a)*r,0.15,Math.sin(a)*r); medkits.push(m); sc.add(m);}
      for (let i=0;i<lvl.coins;i++) coin(); for (let i=0;i<lvl.kits;i++) medkit();
      let health=100; const velocity=new THREE.Vector3(); const accelGround=16, accelAir=6, friction=12, maxSpeed=7.4+levelIndex*0.2, gravity=18, jumpStrength=14.5; let onGround=true; let yaw=0, pitch=0;
      hudPrimary.textContent = `Jungle — Level ${levelIndex+1}`; hudSecondary.textContent = 'Health 100 | Coins 0';
      let attacking=false; const attackDuration=200; let attackRange=1.4; const attackArcCos=Math.cos(Math.PI/3);
      function startAttack(){ if(attacking) return; attacking=true; weapon.rotation.z=-Math.PI*0.35; const forward=new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw)); const p=player.position.clone();
        for(let i=enemies.length-1;i>=0;i--){const e=enemies[i]; const to=new THREE.Vector3().subVectors(e.position,p); const dist=to.length(); if(dist>attackRange) continue; to.normalize(); const dot=to.dot(forward); if(dot>=attackArcCos){ sc.remove(e); enemies.splice(i,1);} }
        setTimeout(()=>{attacking=false; weapon.rotation.z=0;}, attackDuration);
      }
      actionBtn.onclick = startAttack;
      jumpBtn.onclick = () => { if (onGround) velocity.y = jumpStrength; };
      window.addEventListener('keydown', e => { if (e.code === 'Space') { if (onGround) velocity.y = jumpStrength; } });
      function applyMapVariant(variant){ const hemi=lights.children.find(l=>l.isHemisphereLight); const sun=lights.children.find(l=>l.isDirectionalLight);
        if(variant==='night'){ sc.background=new THREE.Color(0x0a1020); if(hemi) hemi.color.set(0xaaccff); if(sun){sun.color.set(0x88aaff); sun.intensity=0.8;} ground.material.color.set(0x1c3a1c);}
        else{ sc.background=new THREE.Color(0x87ceeb); if(hemi) hemi.color.set(0xffffff); if(sun){sun.color.set(0xffffff); sun.intensity=1.5;} ground.material.color.set(0x228B22);}
      }
      applyMapVariant('day');
      function applySkin(newSkin){ playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const existing=player.children.find(ch=>ch.isSprite); if(flag && !existing) player.add(makeOwnerLabel()); if(!flag && existing) player.remove(existing); }
      function restart(){ health=100; coinCount=0; velocity.set(0,0,0); player.position.set(0, playerRadius+0.3, 0); yaw=0; pitch=0; lava.position.y=-2.5; enemies.forEach(e=>sc.remove(e)); enemies.length=0; coins.forEach(c=>sc.remove(c)); coins.length=0; medkits.forEach(m=>sc.remove(m)); medkits.length=0; for(let i=0;i<lvl.coins;i++) coin(); for(let i=0;i<lvl.kits;i++) medkit(); run=true; msg.style.display='none'; hudSecondary.textContent='Health 100 | Coins 0'; }
      function dispose(){ clearInterval(spawnTimer); }
      return {
        scene: sc, camera: cam, restart, dispose,
        getCurrency: () => coinCount, setCurrency: v => { coinCount = v; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`; },
        applyMapVariant, applySkin, applyOwner, applyWeaponUpgrade: () => { attackRange=1.8; weapon.scale.set(1.1,1.3,1.1); },
        update(dt, now){
          if(!run) return;
          const {lx,ly} = getLookDelta(1.8); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.8,0.8);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 7.4, 2.6);
          const mv = moveStick.get(); const { inputX, inputY } = getMoveInput(keys, mv); const {forward, right} = getCameraBasisXZ(cam, player.position);
          const wishdir = new THREE.Vector3().addScaledVector(right,inputX).addScaledVector(forward,inputY); if(wishdir.lengthSq()>0) wishdir.normalize();
          const accel = onGround ? accelGround : accelAir; velocity.addScaledVector(wishdir, accel*dt);
          if(onGround && Math.hypot(inputX,inputY)<0.05){ const horiz=new THREE.Vector2(velocity.x, velocity.z); const speed=horiz.length(); const drop=friction*dt; const newSpeed=Math.max(speed-drop,0); if(speed>0){ horiz.multiplyScalar(newSpeed/speed); velocity.x=horiz.x; velocity.z=horiz.y; } }
          const horiz=new THREE.Vector2(velocity.x, velocity.z); const speed=horiz.length(); if(speed>maxSpeed){ horiz.multiplyScalar(maxSpeed/speed); velocity.x=horiz.x; velocity.z=horiz.y; }
          velocity.y -= gravity * dt; player.position.addScaledVector(velocity, dt); const groundY=playerRadius+0.3; if(player.position.y < groundY){ player.position.y=groundY; velocity.y=0; onGround=true; } else onGround=false;
          lava.position.y += lvl.lavaSpeed * dt;
          const bob = Math.sin(now * 0.004) * 0.02; for(const e of enemies){ e.position.y = 0.45 + bob; const toP = new THREE.Vector3().subVectors(player.position, e.position); const d = toP.length(); if(d>0.0001) toP.normalize(); e.position.addScaledVector(toP, e.userData.speed * dt); if(d < 0.85){ health -= 18 * dt; if(health < 0) health = 0; } }
          for(let i=coins.length-1;i>=0;i--){ const c=coins[i]; if(c.position.distanceTo(player.position)<0.8){ coinCount += 1; hudSecondary.textContent=`Health ${Math.round(health)} | Coins ${coinCount}`; sc.remove(c); coins.splice(i,1);} }
          for(let i=medkits.length-1;i>=0;i--){ const m=medkits[i]; if(m.position.distanceTo(player.position)<0.9){ health=Math.min(100, health+25); hudSecondary.textContent=`Health ${Math.round(health)} | Coins ${coinCount}`; sc.remove(m); medkits.splice(i,1);} }
          const feet = player.position.y - groundY; const lavaTop = lava.position.y + 0.15;
          if(feet <= lavaTop || health <= 0){ run=false; msgText.textContent = `Game Over — Jungle (Lvl ${levelIndex+1})`; msg.style.display='block'; addScore('jungle', shared.name||'Player', Math.round(coinCount)); }
          if(coinCount >= lvl.coins){ run=false; addScore('jungle', shared.name||'Player', coinCount); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
          hudPrimary.textContent = `Jungle — Level ${levelIndex+1}`; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;
        }
      };
    }

    // ————— Game 2 — Platformer (solid floor) —————
    function setupPlatformerTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = platformerLevels[levelIndex] || platformerLevels[0]; const rand = makeRand(lvl.seed);
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87b3ff);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      const lights = makeLights('day'); sc.add(lights);
      // Solid floor under platforms
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({ color: 0x333333 }));
      floor.rotation.x = -Math.PI/2; floor.position.y = 0; sc.add(floor);
      const platMat = new THREE.MeshStandardMaterial({ color: 0x6aa86a, roughness: 0.8 });
      const plats = []; function platform(w,h,d,x,y,z){ const p=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), platMat); p.position.set(x,y,z); sc.add(p); plats.push(p); }
      let x=0,y=4,z=0; for(let i=0;i<lvl.len;i++){ const w=lvl.segment+rand()*8; const d=12+rand()*6; platform(w,2,d,x,y,z); x+=w*1.2; y+=(rand()<0.5?1:-1)*lvl.heightStep*(0.6+rand()*lvl.layoutVar); z+=(rand()-0.5)*12; }
      const goal=new THREE.Mesh(new THREE.TorusKnotGeometry(3,1,120,16), new THREE.MeshStandardMaterial({ color: 0xffd54f })); goal.position.set(x+40,y+10,z+6); sc.add(goal);
      const playerRadius = 0.6; const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.8, 8, 12), playerMat);
      const firstPlat = plats[0];
      const topY = firstPlat.position.y + (firstPlat.geometry.parameters.height || 2) / 2;
      player.position.set(firstPlat.position.x, topY + playerRadius, firstPlat.position.z);
      sc.add(player); if (ownerFlag) player.add(makeOwnerLabel());
      const vel = new THREE.Vector3(0,0,0); const gravity=18, moveSpeed=lvl.moveSpeed, jumpVel=lvl.jumpVel;
      let onGround=false, run=true, won=false, yaw=0, pitch=0, jumpsLeft=3;
      hudPrimary.textContent = `Sky Platforms — Level ${levelIndex+1}`; hudSecondary.textContent = 'Reach the goal (Triple jump)';
      function applySkin(newSkin){ playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=player.children.find(ch=>ch.isSprite); if(flag && !s) player.add(makeOwnerLabel()); if(!flag && s) player.remove(s); }
      function tryJump(){ if(!run) return; if(onGround){ vel.y=jumpVel; jumpsLeft=2; onGround=false; } else if(jumpsLeft>0){ vel.y=jumpVel*0.95; jumpsLeft--; } }
      jumpBtn.onclick = tryJump; window.addEventListener('keydown', e => { if (e.code === 'Space') tryJump(); });
      actionBtn.onclick = () => {};
      function collide(){ onGround=false;
        for(const p of plats){ const top=p.position.y + ((p.geometry.parameters.height || 2)/2); const halfW=p.geometry.parameters.width/2; const halfD=p.geometry.parameters.depth/2;
          const withinX=(player.position.x>p.position.x-halfW-playerRadius)&&(player.position.x<p.position.x+halfW+playerRadius);
          const withinZ=(player.position.z>p.position.z-halfD-playerRadius)&&(player.position.z<p.position.z+halfD+playerRadius);
          const nearTop=Math.abs(player.position.y-(top+playerRadius))<0.6 && vel.y<=0;
          if(withinX && withinZ && nearTop){ player.position.y=top+playerRadius; vel.y=0; onGround=true; jumpsLeft=3; }
        }
        if(player.position.y < 0){ run=false; msgText.textContent=`You fell — Platformer (Lvl ${levelIndex+1})`; msg.style.display='block'; addScore('platformer', shared.name||'Player', Math.max(1, 100 - levelIndex*10)); }
      }
      function restart(){ const fp=plats[0]; const ty=fp.position.y + (fp.geometry.parameters.height || 2)/2; player.position.set(fp.position.x, ty + playerRadius, fp.position.z); vel.set(0,0,0); yaw=0; pitch=0; won=false; run=true; msg.style.display='none'; jumpsLeft=3; }
      return {
        scene: sc, camera: cam, restart, dispose(){},
        getCurrency: () => 0, setCurrency: () => {}, applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          if(!run || won) return;
          const {lx,ly} = getLookDelta(1.8); yaw += lx*dt; pitch = THREE.MathUtils.clamp(pitch + ly*dt, -0.8, 0.8);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 8.0, 2.6);
          const mv = moveStick.get(); const { inputX, inputY } = getMoveInput(keys, mv); const { forward, right } = getCameraBasisXZ(cam, player.position);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY); if (dir.lengthSq()>0) dir.normalize();
          vel.x = THREE.MathUtils.lerp(vel.x, dir.x * moveSpeed, (onGround ? 10 : 6) * dt);
          vel.z = THREE.MathUtils.lerp(vel.z, dir.z * moveSpeed, (onGround ? 10 : 6) * dt);
          vel.y -= gravity * dt;
          player.position.addScaledVector(vel, dt); collide();
          if(player.position.distanceTo(goal.position) < 6){ won=true; addScore('platformer', shared.name||'Player', 1200 - levelIndex*60);
            msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
          hudPrimary.textContent = `Sky Platforms — Level ${levelIndex+1}`;
          hudSecondary.textContent = onGround ? 'On platform (Triple jump ready)' : (jumpsLeft>0 ? `Air (${jumpsLeft} left)` : 'Air');
        }
      };
    }

    // ————— Game 3 — Racer —————
    function setupRacerTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = racerLevels[levelIndex] || racerLevels[0]; const rand=makeRand(lvl.seed);
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0xd0b38a);
      const cam=new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1600);
      const lights=makeLights('day'); sc.add(lights);
      const ground=new THREE.Mesh(new THREE.PlaneGeometry(1400,1400), new THREE.MeshStandardMaterial({ color:0xb5894a, roughness:0.8 })); ground.rotation.x=-Math.PI/2; sc.add(ground);
      const carMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) }); const car=new THREE.Mesh(new THREE.BoxGeometry(2.6,1.2,5), carMat); car.position.set(0,0.6,0); sc.add(car); if(ownerFlag) car.add(makeOwnerLabel());
      const gates=[]; function gate(x,z){ const g=new THREE.Mesh(new THREE.TorusGeometry(4,0.3,12,24), new THREE.MeshStandardMaterial({ color:0xffee88 })); g.position.set(x,2.5,z); sc.add(g); gates.push(g); }
      for(let i=0;i<lvl.gates;i++){ const gx=i*36; const gz=Math.sin(i*lvl.freq)*lvl.amp + Math.sin(i*0.35)*(lvl.amp*0.25)*(rand()-0.5); gate(gx,gz); }
      let speed=0, heading=0, score=0, run=true, yaw=0, pitch=0;
      function applySkin(newSkin){ carMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=car.children.find(ch=>ch.isSprite); if(flag && !s) car.add(makeOwnerLabel()); if(!flag && s) car.remove(s); }
      hudPrimary.textContent=`Desert Racer — Level ${levelIndex+1}`; hudSecondary.textContent=`Gates 0/${lvl.gates}`;
      function restart(){ car.position.set(0,0.6,0); speed=0; heading=0; score=0; run=true; msg.style.display='none'; gates.forEach(g=>sc.remove(g)); gates.length=0; for(let i=0;i<lvl.gates;i++){ const gx=i*36; const gz=Math.sin(i*lvl.freq)*lvl.amp + Math.sin(i*0.35)*(lvl.amp*0.25)*(Math.random()-0.5); gate(gx,gz); } hudSecondary.textContent=`Gates 0/${lvl.gates}`; }
      return {
        scene: sc, camera: cam, restart, dispose(){},
        getCurrency: () => score, setCurrency: v => { score=v; hudSecondary.textContent=`Gates ${score}/${lvl.gates}`; },
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          if(!run) return;
          const {lx,ly}=getLookDelta(0.8); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.5,0.5);
          const mv=moveStick.get(); const steer=mv.x; const throttle=Math.max(0,-mv.y); const brake=Math.max(0,mv.y);
          speed += (throttle*30 - brake*40)*dt; speed *= 0.985; speed = Math.max(0, Math.min(speed, 42)); heading += steer * (racerLevels[levelIndex]?.turn || 2.0) * dt;
          const dir=new THREE.Vector3(Math.sin(heading),0,Math.cos(heading)); car.position.addScaledVector(dir, speed*dt); car.rotation.y=heading;
          updateThirdPersonCamera(cam, car.position, heading, pitch, 11.0, 3.4);
          for(let i=gates.length-1;i>=0;i--){ const g=gates[i]; if(car.position.distanceTo(g.position)<4){ score++; sc.remove(g); gates.splice(i,1); hudSecondary.textContent=`Gates ${score}/${lvl.gates}`; } }
          if(gates.length===0){ run=false; addScore('racer', shared.name||'Player', Math.round(speed*10)); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
          hudPrimary.textContent=`Speed ${speed.toFixed(1)}`;
        }
      };
    }

    // ————— Game 4 — Space Arena —————
    function setupArenaTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = arenaLevels[levelIndex] || arenaLevels[0]; const rand=makeRand(lvl.seed);
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x080a12);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      const lights=makeLights('space'); sc.add(lights);
      const arena=new THREE.Mesh(new THREE.CylinderGeometry(100,100,2,48), new THREE.MeshStandardMaterial({ color:0x1c2233, metalness:0.2, roughness:0.7 })); arena.position.y=-2; sc.add(arena);
      const rigMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) }); const rig=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,0.8,8,12), rigMat); rig.position.set(0,1,0); sc.add(rig); if(ownerFlag) rig.add(makeOwnerLabel());
      const drones=[]; function drone(){ const d=new THREE.Mesh(new THREE.TetrahedronGeometry(1.2), new THREE.MeshStandardMaterial({ color:0xff6666 })); const a=rand()*Math.PI*2, r=60+rand()*10; d.position.set(Math.cos(a)*r,1.2,Math.sin(a)*r); d.userData.vel=new THREE.Vector3((rand()-0.5)*lvl.waveSpeed,0,(rand()-0.5)*lvl.waveSpeed); sc.add(d); drones.push(d); }
      for(let i=0;i<lvl.drones;i++) drone();
      const bullets=[]; const bulletSpeed=42; function shoot(){ const b=new THREE.Mesh(new THREE.SphereGeometry(0.18,10,10), new THREE.MeshStandardMaterial({ color:0xffffaa, emissive:0x444400 })); const dir=new THREE.Vector3().subVectors(rig.position, cam.position); dir.y=0; if(dir.lengthSq()<1e-6) dir.set(0,0,-1); dir.normalize(); b.position.copy(cam.position); b.userData.dir=dir.clone(); sc.add(b); bullets.push(b); }
      actionBtn.onclick = shoot;
      let run=true, score=0, yaw=0, pitch=0;
      hudPrimary.textContent=`Space Arena — Level ${levelIndex+1}`; hudSecondary.textContent='Score 0 | ACTION to shoot';
      function applySkin(newSkin){ rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=rig.children.find(ch=>ch.isSprite); if(flag && !s) rig.add(makeOwnerLabel()); if(!flag && s) rig.remove(s); }
      function restart(){ drones.forEach(d=>sc.remove(d)); drones.length=0; bullets.forEach(b=>sc.remove(b)); bullets.length=0; for(let i=0;i<lvl.drones;i++) drone(); score=0; hudSecondary.textContent='Score 0 | ACTION to shoot'; rig.position.set(0,1,0); yaw=0; pitch=0; run=true; msg.style.display='none'; }
      return {
        scene: sc, camera: cam, restart, dispose(){},
        getCurrency: () => score, setCurrency: v => { score=v; hudSecondary.textContent=`Score ${score} | ACTION to shoot`; },
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          if(!run) return;
          const {lx,ly}=getLookDelta(1.8); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.8,0.8);
          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 9.0, 3.0);
          const mv=moveStick.get(); const {inputX,inputY}=getMoveInput(keys, mv); const {forward,right}=getCameraBasisXZ(cam, rig.position);
          const dir=new THREE.Vector3().addScaledVector(right,inputX).addScaledVector(forward,inputY); if(dir.lengthSq()>0) dir.normalize(); rig.position.addScaledVector(dir, 11*dt);
          for(const d of drones){ d.position.addScaledVector(d.userData.vel, dt); if(d.position.length()>95) d.userData.vel.multiplyScalar(-1); }
          for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.position.addScaledVector(b.userData.dir, bulletSpeed*dt); if(b.position.length()>160){ sc.remove(b); bullets.splice(i,1); continue; }
            for(let j=drones.length-1;j>=0;j--){ const d=drones[j]; if(b.position.distanceTo(d.position)<1.4){ sc.remove(d); drones.splice(j,1); sc.remove(b); bullets.splice(i,1); score++; hudSecondary.textContent=`Score ${score} | ACTION to shoot`; break; } } }
          if(drones.length===0){ run=false; addScore('arena', shared.name||'Player', score); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
        }
      };
    }

    // ————— Game 5 — Runner —————
    function setupRunnerTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = runnerLevels[levelIndex] || runnerLevels[0]; const rand=makeRand(lvl.seed);
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x87ceeb);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      const lights=makeLights('day'); sc.add(lights);
      const ground=new THREE.Mesh(new THREE.PlaneGeometry(lvl.length, 60), new THREE.MeshStandardMaterial({ color:0x228B22 })); ground.rotation.x=-Math.PI/2; ground.position.z=-lvl.length/6; sc.add(ground);
      const rigMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) }); const rig=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,0.8,8,12), rigMat); rig.position.set(0,1,0); sc.add(rig); if(ownerFlag) rig.add(makeOwnerLabel());
      const obstacles=[]; function makeObs(z){ const o=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), new THREE.MeshStandardMaterial({ color:0x884444 })); const lane=rand()<0.33?-2:(rand()<0.5?0:2); o.position.set(lane+(rand()-0.5)*1.0,0.6,-z); sc.add(o); obstacles.push(o); }
      for(let i=0;i<lvl.obstacles;i++) makeObs(6 + i*(lvl.length/lvl.obstacles));
      let laneX=0, speed=8, time=0, run=true, rings=0, yaw=0, pitch=0;
      function applySkin(newSkin){ rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=rig.children.find(ch=>ch.isSprite); if(flag && !s) rig.add(makeOwnerLabel()); if(!flag && s) rig.remove(s); }
      hudPrimary.textContent=`Endless Runner — Level ${levelIndex+1}`; hudSecondary.textContent='Rings 0';
      return {
        scene: sc, camera: cam,
        restart(){ obstacles.forEach(o=>sc.remove(o)); obstacles.length=0; for(let i=0;i<lvl.obstacles;i++) makeObs(6 + i*(lvl.length/lvl.obstacles)); laneX=0; speed=8; time=0; rings=0; run=true; msg.style.display='none'; rig.position.set(0,1,0); hudSecondary.textContent='Rings 0'; },
        dispose(){}, getCurrency:()=>rings, setCurrency:v=>{ rings=v; hudSecondary.textContent=`Rings ${rings}`; },
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          if(!run) return;
          time += dt; speed = 8 + time * (runnerLevels[levelIndex]?.accel || 1.15);
          const {lx,ly} = getLookDelta(1.5); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.4,0.4);
          const mv=moveStick.get(); if(mv.x < -0.3) laneX=-2; else if(mv.x > 0.3) laneX=2; else laneX=0;
          rig.position.x = THREE.MathUtils.lerp(rig.position.x, laneX, 6*dt);
          for(const o of obstacles){
            o.position.z += speed * dt;
            if(o.position.z > 4){ o.position.z = -lvl.length - Math.random()*60; const lane=Math.random()<0.5?-2:2; o.position.x = lane + (Math.random()-0.5)*1.0; rings++; hudSecondary.textContent=`Rings ${rings}`; }
            const dist = new THREE.Vector3(o.position.x - rig.position.x, 0, o.position.z).length(); if(dist < 1.0){ run=false; msgText.textContent=`Hit obstacle — Runner (Lvl ${levelIndex+1})`; msg.style.display='block'; addScore('runner', shared.name||'Player', rings); }
          }
          if(rings >= Math.round(lvl.obstacles * 0.6)){ run=false; addScore('runner', shared.name||'Player', rings); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0); hudPrimary.textContent=`Speed ${speed.toFixed(1)}`;
        }
      };
    }

    // ————— Game 6 — Maze —————
    function setupMazeTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = mazeLevels[levelIndex] || mazeLevels[0]; const rand=makeRand(lvl.seed);
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x101424);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      const lights=makeLights('maze'); sc.add(lights);
      const cellSize=10, cells=lvl.cells; const half=(cells*cellSize)/2;
      const floor=new THREE.Mesh(new THREE.PlaneGeometry(cells*cellSize+20, cells*cellSize+20), new THREE.MeshStandardMaterial({ color:0x222a44, roughness:0.9 })); floor.rotation.x=-Math.PI/2; sc.add(floor);
      const walls=[]; function wall(x,y,z,sx,sy,sz){ const w=new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), new THREE.MeshStandardMaterial({ color:0x3a64a6, emissive:0x0a1530, emissiveIntensity:0.2 })); w.position.set(x,y,z); sc.add(w); walls.push(w); }
      for(let i=0;i<cells;i++){ for(let j=0;j<cells;j++){ if(rand()<0.35) wall(-half+i*cellSize, 1.5, -half+j*cellSize, cellSize-2, 3, 2); if(rand()<0.35) wall(-half+i*cellSize, 1.5, -half+j*cellSize, 2, 3, cellSize-2); } }
      const exit=new THREE.Mesh(new THREE.TorusGeometry(3,0.3,12,32), new THREE.MeshStandardMaterial({ color:0x88ffcc })); exit.position.set(half-10, 2.5, half-10); sc.add(exit);
      const rigMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) }); const rig=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,0.8,8,12), rigMat); rig.position.set(-half+10,0.9,-half+10); sc.add(rig); if(ownerFlag) rig.add(makeOwnerLabel());
      let yaw=0, pitch=0, run=true;
      hudPrimary.textContent=`Crystal Maze — Level ${levelIndex+1}`; hudSecondary.textContent='Find the exit ring';
      function applySkin(newSkin){ rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=rig.children.find(ch=>ch.isSprite); if(flag && !s) rig.add(makeOwnerLabel()); if(!flag && s) rig.remove(s); }
      function restart(){ rig.position.set(-half+10,0.9,-half+10); yaw=0; pitch=0; run=true; msg.style.display='none'; }
      return {
        scene: sc, camera: cam, restart, dispose(){}, getCurrency:()=>0, setCurrency:()=>{},
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          if(!run) return;
          const {lx,ly} = getLookDelta(1.8); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.4,0.4);
          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);
          const mv=moveStick.get(); const {inputX,inputY}=getMoveInput(keys, mv); const {forward,right}=getCameraBasisXZ(cam, rig.position);
          const next=rig.position.clone().addScaledVector(right, inputX*8*dt).addScaledVector(forward, inputY*8*dt);
          let blocked=false; for(const w of walls){ const dx=Math.abs(next.x - w.position.x) - w.geometry.parameters.width/2 - 0.5; const dz=Math.abs(next.z - w.position.z) - w.geometry.parameters.depth/2 - 0.5; if(dx<0 && dz<0){ blocked=true; break; } }
          if(!blocked) rig.position.copy(next);
          if(rig.position.distanceTo(exit.position) < 5){ run=false; addScore('maze', shared.name||'Player', 1200 - levelIndex*60); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
        }
      };
    }

    // ————— Game 7 — Range —————
    function setupRangeTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = rangeLevels[levelIndex] || rangeLevels[0]; const rand=makeRand(lvl.seed);
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x223344);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1200);
      const lights=makeLights('day'); sc.add(lights);
      const floor=new THREE.Mesh(new THREE.PlaneGeometry(lvl.spread*2, lvl.spread*2), new THREE.MeshStandardMaterial({ color:0x335577 })); floor.rotation.x=-Math.PI/2; sc.add(floor);
      const rigMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) }); const rig=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,0.8,8,12), rigMat); rig.position.set(0,1,40); sc.add(rig); if(ownerFlag) rig.add(makeOwnerLabel());
      const targets=[]; function spawnTarget(){ const t=new THREE.Mesh(new THREE.TorusGeometry(1.2,0.25,10,20), new THREE.MeshStandardMaterial({ color:0xffcc55, emissive:0x553300, emissiveIntensity:0.2 })); t.position.set((rand()-0.5)*lvl.spread, 2+rand()*6, -20-rand()*lvl.spread); sc.add(t); targets.push(t); }
      for(let i=0;i<lvl.targets;i++) spawnTarget();
      const bullets=[]; const bulletSpeed=42; function shoot(){ const b=new THREE.Mesh(new THREE.SphereGeometry(0.18,10,10), new THREE.MeshStandardMaterial({ color:0xffffaa, emissive:0x444400 })); const dir=new THREE.Vector3().subVectors(rig.position, cam.position); dir.y=0; if(dir.lengthSq()<1e-6) dir.set(0,0,-1); dir.normalize(); b.position.copy(cam.position); b.userData.dir=dir.clone(); sc.add(b); bullets.push(b); }
      actionBtn.onclick = shoot;
      let yaw=0,pitch=0,run=true,score=0;
      hudPrimary.textContent=`Target Range — Level ${levelIndex+1}`; hudSecondary.textContent='Score 0 | ACTION to shoot';
      function applySkin(newSkin){ rigMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=rig.children.find(ch=>ch.isSprite); if(flag && !s) rig.add(makeOwnerLabel()); if(!flag && s) rig.remove(s); }
      function restart(){ bullets.forEach(b=>sc.remove(b)); bullets.length=0; targets.forEach(t=>sc.remove(t)); targets.length=0; for(let i=0;i<lvl.targets;i++) spawnTarget(); rig.position.set(0,1,40); yaw=0; pitch=0; score=0; hudSecondary.textContent='Score 0 | ACTION to shoot'; run=true; msg.style.display='none'; }
      return {
        scene: sc, camera: cam, restart, dispose(){}, getCurrency:()=>score, setCurrency:v=>{ score=v; hudSecondary.textContent=`Score ${score} | ACTION to shoot`; },
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          if(!run) return;
          const {lx,ly}=getLookDelta(1.8); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.8,0.8); updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);
          const mv=moveStick.get(); rig.position.x += mv.x * 6 * dt; rig.position.z += -mv.y * 6 * dt;
          for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.position.addScaledVector(b.userData.dir, bulletSpeed*dt); if(b.position.length()>200){ sc.remove(b); bullets.splice(i,1); continue; }
            for(let j=targets.length-1;j>=0;j--){ const t=targets[j]; if(b.position.distanceTo(t.position)<1.2){ sc.remove(t); targets.splice(j,1); sc.remove(b); bullets.splice(i,1); score++; hudSecondary.textContent=`Score ${score} | ACTION to shoot`; setTimeout(spawnTarget, (rangeLevels[levelIndex]?.respawn || 0.8)*1000); break; } } }
          if(score >= Math.round(lvl.targets * 0.7)){ run=false; addScore('range', shared.name||'Player', score); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
        }
      };
    }

    // ————— Game 8 — Voxel —————
    function setupVoxelTP(quality, skin, levelIndex, ownerFlag) {
      const lvl = voxelLevels[levelIndex] || voxelLevels[0]; const rand=makeRand(lvl.seed);
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x87ceeb);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1600);
      const lights=makeLights('day'); sc.add(lights);
      const size=lvl.size; const blockSize=1;
      const ground=new THREE.Mesh(new THREE.PlaneGeometry(size*blockSize, size*blockSize), new THREE.MeshStandardMaterial({ color:0x88b36a })); ground.rotation.x=-Math.PI/2; sc.add(ground);
      const playerMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) }); const player=new THREE.Mesh(new THREE.BoxGeometry(1,1.8,1), playerMat); player.position.set(0,1,0); sc.add(player); if(ownerFlag) player.add(makeOwnerLabel());
      const palettes=[0x8B4513,0xaaaaaa,0x228B22,0x3366ff,0xffd84d]; let paletteIndex=0;
      const blocks=new Map(); function key(x,y,z){return `${x},${y},${z}`;}
      function addBlock(x,y,z,color=null){ const mesh=new THREE.Mesh(new THREE.BoxGeometry(blockSize,blockSize,blockSize), new THREE.MeshStandardMaterial({ color: color ?? palettes[paletteIndex] })); mesh.position.set(x,y,z); sc.add(mesh); blocks.set(key(x,y,z), mesh); }
      for(let i=0;i<lvl.startBlocks;i++){ const x=Math.floor((rand()-0.5)*size), z=Math.floor((rand()-0.5)*size), y=0.5; addBlock(x,y,z,0x88b36a); }
      function rayFromCamera(){ const dir=new THREE.Vector3().subVectors(player.position, cam.position).normalize(); const origin=cam.position.clone(); return { origin, dir }; }
      function findNearestGridHit(maxDist=8){ const {origin,dir}=rayFromCamera(); let best=null, bestDist=Infinity; for(const [,mesh] of blocks){ const to=new THREE.Vector3().subVectors(mesh.position, origin); const proj=to.dot(dir); if(proj>0 && proj<maxDist){ const closest=origin.clone().addScaledVector(dir, proj); const d=closest.distanceTo(mesh.position); if(d<0.9 && proj<bestDist){ best=mesh; bestDist=proj; } } } return best; }
      actionBtn.onclick = () => { const hit=findNearestGridHit(8); const pos=hit?hit.position.clone().add(new THREE.Vector3(0,blockSize,0)):player.position.clone().add(new THREE.Vector3(0,0,-2)).round(); const snap=new THREE.Vector3(Math.round(pos.x), Math.round(pos.y), Math.round(pos.z)); const k=key(snap.x,snap.y,snap.z); if(!blocks.has(k)) addBlock(snap.x,snap.y,snap.z); };
      jumpBtn.onclick = () => { const hit=findNearestGridHit(8); if(hit){ blocks.delete(key(hit.position.x, hit.position.y, hit.position.z)); sc.remove(hit); } };
      window.addEventListener('keydown', e => { if(e.code==='KeyQ'){ paletteIndex=(paletteIndex+1)%palettes.length; } if(e.code==='KeyE'){ paletteIndex=(paletteIndex+palettes.length-1)%palettes.length; } });
      let yaw=0,pitch=0; let speed=6.5;
      hudPrimary.textContent=`Voxel Builder — Level ${levelIndex+1}`; hudSecondary.textContent=`Blocks ${blocks.size} | Palette #${paletteIndex+1} (Q/E cycle)`;
      function applySkin(newSkin){ playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=player.children.find(ch=>ch.isSprite); if(flag && !s) player.add(makeOwnerLabel()); if(!flag && s) player.remove(s); }
      function restart(){ for(const [,mesh] of blocks) sc.remove(mesh); blocks.clear(); for(let i=0;i<lvl.startBlocks;i++){ const x=Math.floor((rand()-0.5)*size), z=Math.floor((rand()-0.5)*size), y=0.5; addBlock(x,y,z,0x88b36a); } player.position.set(0,1,0); yaw=0; pitch=0; msg.style.display='none'; }
      return {
        scene: sc, camera: cam, restart, dispose(){}, getCurrency:()=>blocks.size, setCurrency:()=>{},
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade: () => {},
        update(dt){
          const {lx,ly}=getLookDelta(1.6); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.7,0.7);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 8.5, 3.0);
          const mv=moveStick.get(); const {inputX,inputY}=getMoveInput(keys, mv); const {forward,right}=getCameraBasisXZ(cam, player.position);
          const dir=new THREE.Vector3().addScaledVector(right,inputX).addScaledVector(forward,inputY); if(dir.lengthSq()>0) dir.normalize(); player.position.addScaledVector(dir, speed*dt);
          hudSecondary.textContent=`Blocks ${blocks.size} | Palette #${paletteIndex+1} (Q/E cycle)`;
          if(blocks.size >= lvl.startBlocks + lvl.goalDelta){ addScore('voxel', shared.name||'Player', blocks.size); msgText.textContent=`Level ${levelIndex+1} complete — advancing...`; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
        }
      };
    }

    // ————— Game 9 — Ice Cavern (solid floor) —————
    function makePlayerCapsule(color=0x4da3ff, owner=false){
      const mat = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), mat);
      mesh.position.set(0, 1, 0);
      if (owner) mesh.add(makeOwnerLabel());
      return { mesh, mat };
    }

    function setupIceCavernTP(quality, skin, levelIndex, ownerFlag) {
      const levels = simpleLevels(701); const lvl = levels[levelIndex] || levels[0]; const rand = makeRand(lvl.seed);
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x102033);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1500);
      sc.add(makeLights('ice'));
      // Solid floor under cavern
      const floorBase = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({ color: 0x224466 }));
      floorBase.rotation.x = -Math.PI/2; floorBase.position.y = -2; sc.add(floorBase);
      const platMat = new THREE.MeshStandardMaterial({ color: 0xaad7ff, roughness: 0.2, metalness: 0.4 });
      const plats = []; let x=0,y=4,z=0; for(let i=0;i<lvl.count;i++){ const w=20+rand()*16, d=10+rand()*8; const p=new THREE.Mesh(new THREE.BoxGeometry(w,2,d), platMat); p.position.set(x,y,z); sc.add(p); plats.push(p); x+=w*1.2; y+=(rand()<0.5?1:-1)*(8+rand()*6); z+=(rand()-0.5)*14; }
      const goal = new THREE.Mesh(new THREE.TorusKnotGeometry(2.5,0.8,120,16), new THREE.MeshStandardMaterial({ color: 0x88ffee })); goal.position.set(x+40,y+10,z); sc.add(goal);
      const { mesh: player, mat: playerMat } = makePlayerCapsule(skinToColor(skin), ownerFlag); sc.add(player);
      let vel = new THREE.Vector3(0,0,0), yaw=0, pitch=0, onGround=false, run=true, jumpsLeft=2;
      hudPrimary.textContent=`Ice Cavern — Level ${levelIndex+1}`; hudSecondary.textContent='Slippery floor, double jump';
      function applySkin(newSkin){ playerMat.color.setHex(skinToColor(newSkin)); }
      function applyOwner(flag){ const s=player.children.find(ch=>ch.isSprite); if(flag && !s) player.add(makeOwnerLabel()); if(!flag && s) player.remove(s); }
      function tryJump(){ if(!run) return; if(onGround){ vel.y=18; jumpsLeft=1; onGround=false; } else if(jumpsLeft>0){ vel.y=17; jumpsLeft--; } }
      jumpBtn.onclick=tryJump; window.addEventListener('keydown', e=>{ if(e.code==='Space') tryJump(); });
      function collide(){ onGround=false;
        for(const p of plats){ const top=p.position.y+1; const halfW=p.geometry.parameters.width/2; const halfD=p.geometry.parameters.depth/2;
          const withinX=(player.position.x>p.position.x-halfW-0.5)&&(player.position.x<p.position.x+halfW+0.5);
          const withinZ=(player.position.z>p.position.z-halfD-0.5)&&(player.position.z<p.position.z+halfD+0.5);
          const nearTop=Math.abs(player.position.y-(top+0.5))<0.6 && vel.y<=0;
          if(withinX && withinZ && nearTop){ player.position.y=top+0.5; vel.y=0; onGround=true; jumpsLeft=2; }
        }
        if(player.position.y<-60){ run=false; msgText.textContent=`You fell — Ice Cavern`; msg.style.display='block'; addScore('icecavern', shared.name||'Player', 1); }
      }
      return {
        scene: sc, camera: cam, restart(){ player.position.set(0,1,0); vel.set(0,0,0); yaw=0; pitch=0; onGround=false; run=true; msg.style.display='none'; },
        dispose(){}, getCurrency:()=>0, setCurrency:()=>{},
        applyMapVariant:()=>{}, applySkin, applyOwner, applyWeaponUpgrade:()=>{},
        update(dt){
          if(!run) return;
          const {lx,ly}=getLookDelta(1.6); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.6,0.6); updateThirdPersonCamera(cam, player.position, yaw, pitch, 8, 2.6);
          const mv=moveStick.get(); const {inputX,inputY}=getMoveInput(keys,mv); const {forward,right}=getCameraBasisXZ(cam, player.position);
          const dir=new THREE.Vector3().addScaledVector(right,inputX).addScaledVector(forward,inputY); if(dir.lengthSq()>0) dir.normalize();
          vel.x = THREE.MathUtils.lerp(vel.x, dir.x * 13, (onGround?3:2)*dt);
          vel.z = THREE.MathUtils.lerp(vel.z, dir.z * 13, (onGround?3:2)*dt);
          vel.y -= 18 * dt; player.position.addScaledVector(vel, dt); collide();
          if(player.position.distanceTo(goal.position)<5){ run=false; addScore('icecavern', shared.name||'Player', 10); msgText.textContent='Level complete — advancing...'; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); }, 1200); }
          hudSecondary.textContent = onGround ? 'On ice (double jump ready)' : (jumpsLeft>0 ? 'Air (double jump)' : 'Air');
        }
      };
    }

    // Register games 1–9 (remaining in chunk 2)
    Object.assign(gameSetups, {
      jungle: setupJungleTP,
      platformer: setupPlatformerTP,
      racer: setupRacerTP,
      arena: setupArenaTP,
      runner: setupRunnerTP,
      maze: setupMazeTP,
      range: setupRangeTP,
      voxel: setupVoxelTP,
      icecavern: setupIceCavernTP
    });

    // Bind menu buttons (startGame comes in chunk 2)
    document.querySelectorAll('.menuBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const game = btn.dataset.game;
        if (typeof startGame === 'function') startGame(gameSetups[game], game, selectedLevel);
      });
    });

    // Prevent iOS pinch/zoom
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());
  </script>
  <script type="module">
    // ————— Game 10 — Volcano Dash (solid floor) —————
    function setupVolcanoTP(quality, skin, levelIndex, ownerFlag) {
      const levels = simpleLevels(801);
      const lvl = levels[levelIndex] || levels[0];
      const rand = makeRand(lvl.seed);
      const sc = new THREE.Scene();
      sc.background = new THREE.Color(0x330000);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1500);
      sc.add(makeLights('volcano'));
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({ color: 0x552222 }));
      floor.rotation.x = -Math.PI/2; floor.position.y = -2; sc.add(floor);
      const platMat = new THREE.MeshStandardMaterial({ color: 0x883333 });
      const plats = [];
      for(let i=0;i<lvl.count;i++){
        const p=new THREE.Mesh(new THREE.BoxGeometry(20,2,20), platMat);
        p.position.set((rand()-0.5)*200, 2+rand()*20, (rand()-0.5)*200);
        sc.add(p); plats.push(p);
      }
      const goal=new THREE.Mesh(new THREE.TorusGeometry(3,0.5,16,32), new THREE.MeshStandardMaterial({ color:0xffff00 }));
      goal.position.set(0,20,0); sc.add(goal);
      const playerMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,0.8,8,12), playerMat);
      player.position.set(0,1,0); sc.add(player);
      if(ownerFlag) player.add(makeOwnerLabel());
      let vel=new THREE.Vector3(), yaw=0, pitch=0, run=true;
      hudPrimary.textContent=`Volcano Dash — Level ${levelIndex+1}`;
      hudSecondary.textContent='Reach the glowing ring';
      return {
        scene: sc, camera: cam,
        restart(){ player.position.set(0,1,0); vel.set(0,0,0); yaw=0; pitch=0; run=true; msg.style.display='none'; },
        dispose(){}, getCurrency:()=>0, setCurrency:()=>{},
        applyMapVariant:()=>{}, applySkin:(s)=>playerMat.color.setHex(skinToColor(s)),
        applyOwner:(f)=>{ const spr=player.children.find(ch=>ch.isSprite); if(f&&!spr) player.add(makeOwnerLabel()); if(!f&&spr) player.remove(spr); },
        applyWeaponUpgrade:()=>{},
        update(dt){
          if(!run) return;
          const {lx,ly}=getLookDelta(1.6); yaw+=lx*dt; pitch=THREE.MathUtils.clamp(pitch+ly*dt,-0.6,0.6);
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 8, 2.6);
          const mv=moveStick.get(); const {inputX,inputY}=getMoveInput(keys,mv);
          const {forward,right}=getCameraBasisXZ(cam, player.position);
          const dir=new THREE.Vector3().addScaledVector(right,inputX).addScaledVector(forward,inputY);
          if(dir.lengthSq()>0) dir.normalize();
          vel.x=THREE.MathUtils.lerp(vel.x, dir.x*10, 8*dt);
          vel.z=THREE.MathUtils.lerp(vel.z, dir.z*10, 8*dt);
          vel.y-=18*dt;
          player.position.addScaledVector(vel, dt);
          if(player.position.y<-10){ run=false; msgText.textContent=`You fell — Volcano Dash`; msg.style.display='block'; addScore('volcano', shared.name||'Player', 1); }
          if(player.position.distanceTo(goal.position)<5){ run=false; addScore('volcano', shared.name||'Player', 10); msgText.textContent='Level complete — advancing...'; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); },1200); }
        }
      };
    }

    // ————— Game 11 — Asteroids —————
    function setupAsteroidsTP(quality, skin, levelIndex, ownerFlag) {
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x000000);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
      sc.add(makeLights('space'));
      const shipMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const ship=new THREE.Mesh(new THREE.ConeGeometry(1,2,16), shipMat);
      ship.rotation.x=Math.PI/2; ship.position.set(0,0,0); sc.add(ship);
      if(ownerFlag) ship.add(makeOwnerLabel());
      const asteroids=[]; for(let i=0;i<20;i++){ const a=new THREE.Mesh(new THREE.IcosahedronGeometry(2+Math.random()*2), new THREE.MeshStandardMaterial({ color:0x888888 })); a.position.set((Math.random()-0.5)*200,(Math.random()-0.5)*200,(Math.random()-0.5)*200); sc.add(a); asteroids.push(a); }
      let yaw=0,pitch=0,score=0,run=true;
      hudPrimary.textContent=`Asteroid Field — Level ${levelIndex+1}`; hudSecondary.textContent='Score 0';
      return {
        scene: sc, camera: cam,
        restart(){ ship.position.set(0,0,0); score=0; run=true; msg.style.display='none'; },
        dispose(){}, getCurrency:()=>score, setCurrency:v=>{score=v; hudSecondary.textContent=`Score ${score}`;},
        applyMapVariant:()=>{}, applySkin:(s)=>shipMat.color.setHex(skinToColor(s)),
        applyOwner:(f)=>{ const spr=ship.children.find(ch=>ch.isSprite); if(f&&!spr) ship.add(makeOwnerLabel()); if(!f&&spr) ship.remove(spr); },
        applyWeaponUpgrade:()=>{},
        update(dt){
          if(!run) return;
          const {lx,ly}=getLookDelta(1.6); yaw+=lx*dt; pitch+=ly*dt;
          updateThirdPersonCamera(cam, ship.position, yaw, pitch, 12, 4);
          const mv=moveStick.get(); ship.position.x+=mv.x*20*dt; ship.position.y+=-mv.y*20*dt;
          for(const a of asteroids){ a.rotation.x+=0.2*dt; a.rotation.y+=0.3*dt; if(ship.position.distanceTo(a.position)<3){ run=false; msgText.textContent=`Crashed — Asteroids`; msg.style.display='block'; addScore('asteroids', shared.name||'Player', score); } }
          score+=dt*10; hudSecondary.textContent=`Score ${Math.floor(score)}`;
          if(score>200){ run=false; addScore('asteroids', shared.name||'Player', Math.floor(score)); msgText.textContent='Level complete — advancing...'; msg.style.display='block'; setTimeout(()=>{ msg.style.display='none'; if(cleanup.nextLevel) cleanup.nextLevel(); },1200); }
        }
      };
    }

    // ————— Game 12 — Underwater —————
    function setupUnderwaterTP(quality, skin, levelIndex, ownerFlag) {
      const sc=new THREE.Scene(); sc.background=new THREE.Color(0x003366);
      const cam=new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1500);
      sc.add(makeLights('underwater'));
      const diverMat=new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const diver=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,0.8,8,12), diverMat);
      diver.position.set(0,1,0); sc.add(diver);
      if(ownerFlag) diver.add(makeOwnerLabel());
      const bubbles=[]; for(let i=0;i<20;i++){ const b=new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8), new THREE.MeshStandardMaterial({ color:0x99ccff, transparent:true, opacity:0.6 })); b.position.set((Math.random()-0.5)*40,Math.random()*20,(Math.random()-0.5)*40); sc.add(b); bubbles.push(b); }
      let yaw=0,pitch=0,score=0,run=true;
      hudPrimary.textContent=`Underwater — Level ${levelIndex+1}`; hudSecondary.textContent='Collect bubbles';
      return {
        scene: sc, camera: cam,
        restart(){ diver.position.set(0,1,0); score=0; run=true; msg.style.display='none'; },
        dispose(){}, getCurrency:()=>score, setCurrency:v
