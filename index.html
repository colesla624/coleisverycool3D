<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Scary Collector 3D – Full Game with Map Toggle (E)</title>
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; font-family:system-ui, sans-serif; }
    canvas { display:block; }

    /* Top UI bar */
    #ui {
      position:fixed; top:0; left:0; right:0; display:flex; gap:10px; align-items:center;
      padding:10px; background:linear-gradient(180deg, rgba(0,0,0,0.75), rgba(0,0,0,0.2));
      color:#f5f5f5; z-index:4;
    }
    #stats { flex:1; display:flex; gap:16px; font-weight:600; }
    #toggle { padding:8px 12px; border:1px solid #555; background:#161616; color:#eee; cursor:pointer; border-radius:6px; }
    #msg { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); color:#bbb; font-size:12px; z-index:4; }

    /* Crosshair + vignette */
    #crosshair {
      position:fixed; left:50%; top:50%; width:14px; height:14px; transform:translate(-50%, -50%);
      border:2px solid #b00; border-radius:50%; box-shadow: 0 0 8px #a00; z-index:4; opacity:.7;
    }
    #vignette {
      position:fixed; inset:0; pointer-events:none; z-index:3;
      background:radial-gradient(ellipse at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.55) 90%);
    }

    /* Mobile controls */
    #mobile-controls { position:fixed; bottom:18px; left:18px; right:18px; display:none; justify-content:space-between; z-index:4; }
    .stick {
      width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.15); position:relative; touch-action:none;
    }
    .knob {
      width:54px; height:54px; border-radius:50%; background:rgba(255,255,255,0.28);
      position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    }

    /* Map overlay */
    #map {
      position:fixed; right:16px; bottom:16px; width:200px; height:200px; background:#0a0a0a;
      border:1px solid #333; border-radius:8px; box-shadow: 0 0 12px rgba(255,0,0,0.15);
      z-index:4; display:none; overflow:hidden;
    }
    #map canvas { width:100%; height:100%; display:block; }
    #map-label {
      position:absolute; top:6px; left:8px; color:#ddd; font-size:12px; text-shadow:0 1px 2px #000;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="stats">
      <div id="level">Level: 1</div>
      <div id="collected">Collected: 0 / 0</div>
      <div id="status">WASD to move. Drag to look. Press E to toggle map.</div>
    </div>
    <button id="toggle" aria-label="Toggle control mode">Mode: PC</button>
  </div>

  <div id="crosshair" aria-hidden="true"></div>
  <div id="vignette" aria-hidden="true"></div>

  <div id="mobile-controls">
    <div id="left-stick" class="stick"><div class="knob"></div></div>
    <div id="look-stick" class="stick"><div class="knob"></div></div>
  </div>

  <div id="msg">PC: WASD to move, drag mouse to look, E for map. Mobile: use sticks, tap E on a keyboard only if connected.</div>

  <!-- Map -->
  <div id="map">
    <div id="map-label">Map (E to toggle)</div>
    <canvas id="map-canvas" width="200" height="200"></canvas>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // Full single-file game with:
    // - PC/Mobile mode toggle
    // - Flashlight always ON (no toggle)
    // - Collect orange dodecahedrons
    // - Monster stalks you and levels get harder
    // - Map overlay toggled with E, showing player and monster positions

    let renderer, scene, camera;
    let clock = new THREE.Clock();
    let mode = 'pc'; // 'pc' or 'mobile'
    let move = { f:0, b:0, l:0, r:0 };
    let velocity = new THREE.Vector3();

    // World
    const WORLD_SIZE = 140;
    const PLAYER_HEIGHT = 1.7;
    const PLAYER_SPEED_BASE = 3.1;

    const LEVELS = [
      { count: 4, monsterSpeed: 2.0, monsterAggro: 0.6 },
      { count: 6, monsterSpeed: 2.6, monsterAggro: 0.8 },
      { count: 8, monsterSpeed: 3.2, monsterAggro: 1.0 },
      { count: 10, monsterSpeed: 3.6, monsterAggro: 1.15 },
    ];
    let levelIndex = 0;
    let collectibles = [];
    let collectedCount = 0;

    // Lighting (flashlight always ON)
    let ambient, flashlight;

    // Monster
    let monster, monsterTarget = new THREE.Vector3(), monsterGrowlTimer = 0;

    // Fog color
    const fogColor = new THREE.Color(0x000000);

    // Mobile sticks state
    const sticks = {
      left: { active:false, ox:0, oy:0, x:0, y:0 },
      look: { active:false, ox:0, oy:0, x:0, y:0 }
    };

    // Map state
    const mapEl = document.getElementById('map');
    const mapCanvas = document.getElementById('map-canvas');
    const mapCtx = mapCanvas.getContext('2d');
    let mapVisible = false;

    init();
    animate();

    function init(){
      renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = fogColor.clone();
      scene.fog = new THREE.FogExp2(fogColor.clone(), 0.02); // not pitch black

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.05, 300);
      camera.position.set(0, PLAYER_HEIGHT, 0);
      camera.rotation.order = 'YXZ';

      // Ground
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 1, 1);
      const groundMat = new THREE.MeshStandardMaterial({ color:0x101010, roughness:1, metalness:0 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);

      addEnvironment();

      // Lighting: ambient + flashlight always on
      ambient = new THREE.AmbientLight(0x1e1e1e);
      scene.add(ambient);

      flashlight = new THREE.SpotLight(0xffffff, 3.8, 18, Math.PI/9, 0.35, 1.5);
      flashlight.castShadow = true;
      flashlight.shadow.mapSize.set(1024, 1024);
      flashlight.shadow.bias = -0.0001;
      flashlight.target = new THREE.Object3D();
      scene.add(flashlight);
      scene.add(flashlight.target);

      setupLevel(levelIndex);
      setupInput();

      window.addEventListener('resize', onResize);
      onResize();

      setMode('pc');
      updateUI();
      drawMap(); // initial map frame
    }

    function addEnvironment(){
      const group = new THREE.Group();
      const boxGeo = new THREE.BoxGeometry(3, 6, 0.4);
      const mat = new THREE.MeshStandardMaterial({ color:0x121212, roughness:0.95 });
      for(let i=0;i<28;i++){
        const b = new THREE.Mesh(boxGeo, mat);
        b.position.set(randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45), 3, randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45));
        b.rotation.y = randRange(0, Math.PI);
        b.castShadow = true;
        b.receiveShadow = true;
        group.add(b);
      }
      scene.add(group);

      // Red mood lights
      const lampGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
      const lampMat = new THREE.MeshStandardMaterial({ color:0x220000 });
      for(let i=0;i<14;i++){
        const m = new THREE.Mesh(lampGeo, lampMat);
        m.position.set(randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45), 2.8, randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45));
        scene.add(m);
        const red = new THREE.PointLight(0x660000, randRange(0.4,0.9), 6, 2);
        red.position.copy(m.position);
        scene.add(red);
      }
    }

    function setupLevel(idx){
      // Clear old collectibles
      collectibles.forEach(c => {
        if (c.userData.glow) scene.remove(c.userData.glow);
        scene.remove(c);
      });
      collectibles = [];
      collectedCount = 0;

      const config = LEVELS[idx] || LEVELS[LEVELS.length-1];

      // Orange dodecahedrons
      const geo = new THREE.DodecahedronGeometry(0.6, 0);
      const mat = new THREE.MeshStandardMaterial({
        color:0xff7a00,
        emissive:0x331800,
        roughness:0.3,
        metalness:0.2
      });

      for(let i=0;i<config.count;i++){
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45), 0.6, randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45));
        mesh.castShadow = true;
        mesh.userData.spin = randRange(0.6,1.2);
        scene.add(mesh);
        collectibles.push(mesh);

        const glow = new THREE.PointLight(0xff6b00, 0.9, 6, 1.2);
        glow.position.copy(mesh.position).add(new THREE.Vector3(0,0.4,0));
        scene.add(glow);
        mesh.userData.glow = glow;
      }

      // Monster
      if (monster) scene.remove(monster);
      monster = createMonster();
      scene.add(monster);

      monster.position.set(randRange(-WORLD_SIZE*0.4, WORLD_SIZE*0.4), 1.4, randRange(-WORLD_SIZE*0.4, WORLD_SIZE*0.4));
      monster.userData.speed = config.monsterSpeed;
      monster.userData.aggro = config.monsterAggro;

      // Reset player
      camera.position.set(0, PLAYER_HEIGHT, 0);
      velocity.set(0,0,0);

      updateUI();
    }

    function createMonster(){
      const g = new THREE.Group();

      const bodyGeo = new THREE.CapsuleGeometry(0.4, 1.6, 12, 24);
      const bodyMat = new THREE.MeshStandardMaterial({ color:0x0f0f0f, roughness:0.95 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = true; body.receiveShadow = true;
      g.add(body);

      const headGeo = new THREE.TetrahedronGeometry(0.5, 1);
      const headMat = new THREE.MeshStandardMaterial({ color:0x0b0b0b, emissive:0x120000, roughness:0.8, metalness:0.1 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.4;
      head.castShadow = true;
      g.add(head);

      const eyeL = new THREE.SpotLight(0xff0000, 1.1, 8, Math.PI/9, 0.6, 1);
      const eyeR = eyeL.clone();
      eyeL.position.set(-0.18, 1.4, 0.3);
      eyeR.position.set(0.18, 1.4, 0.3);
      g.add(eyeL, eyeR);
      const target = new THREE.Object3D();
      g.add(target);
      eyeL.target = target; eyeR.target = target;

      g.userData.pulse = 0;
      return g;
    }

    function setupInput(){
      // Keyboard
      window.addEventListener('keydown', (e)=>{
        if(e.code==='KeyW' || e.code==='ArrowUp') move.f=1;
        if(e.code==='KeyS' || e.code==='ArrowDown') move.b=1;
        if(e.code==='KeyA' || e.code==='ArrowLeft') move.l=1;
        if(e.code==='KeyD' || e.code==='ArrowRight') move.r=1;
        if(e.code==='KeyE') toggleMap();
      });
      window.addEventListener('keyup', (e)=>{
        if(e.code==='KeyW' || e.code==='ArrowUp') move.f=0;
        if(e.code==='KeyS' || e.code==='ArrowDown') move.b=0;
        if(e.code==='KeyA' || e.code==='ArrowLeft') move.l=0;
        if(e.code==='KeyD' || e.code==='ArrowRight') move.r=0;
      });

      // Drag to look (no pointer lock needed)
      let dragging=false, px=0, py=0;
      const dragTarget = renderer.domElement;
      dragTarget.addEventListener('mousedown', (e)=>{ dragging=true; px=e.clientX; py=e.clientY; });
      window.addEventListener('mouseup', ()=> dragging=false);
      window.addEventListener('mousemove', (e)=>{
        if(!dragging || mode!=='pc') return;
        const dx = (e.clientX - px), dy = (e.clientY - py);
        px=e.clientX; py=e.clientY;
        camera.rotation.y -= dx * 0.0022;
        camera.rotation.x -= dy * 0.0022;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      });

      // Mobile sticks
      const left = document.getElementById('left-stick');
      const look = document.getElementById('look-stick');

      setupStick(left, sticks.left, (sx, sy)=>{
        move.f = sy < -0.2 ? 1 : 0;
        move.b = sy > 0.2 ? 1 : 0;
        move.l = sx < -0.2 ? 1 : 0;
        move.r = sx > 0.2 ? 1 : 0;
      });
      setupStick(look, sticks.look, (sx, sy)=>{
        camera.rotation.y -= sx * 0.04;
        camera.rotation.x -= sy * 0.035;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      });

      // Mode toggle
      document.getElementById('toggle').addEventListener('click', ()=>{
        setMode(mode==='pc' ? 'mobile' : 'pc');
      });
    }

    function setupStick(el, state, onMove){
      const knob = el.querySelector('.knob');
      const rect = () => el.getBoundingClientRect();

      function setKnob(x, y){
        knob.style.left = `${x}px`; knob.style.top = `${y}px`;
      }

      const start = (clientX, clientY) => {
        state.active = true;
        const r = rect();
        state.ox = r.width/2; state.oy = r.height/2;
        setKnob(state.ox, state.oy);
        moveEv(clientX, clientY);
      };
      const moveEv = (clientX, clientY) => {
        if(!state.active) return;
        const r = rect();
        const x = clientX - r.left, y = clientY - r.top;
        let dx = x - state.ox, dy = y - state.oy;
        const maxR = 44;
        const len = Math.hypot(dx, dy);
        if(len>maxR){ dx *= maxR/len; dy *= maxR/len; }
        setKnob(state.ox + dx, state.oy + dy);
        state.x = dx/maxR; state.y = dy/maxR;
        onMove(state.x, state.y);
      };
      const end = ()=>{
        state.active=false; state.x=0; state.y=0;
        const r = rect();
        setKnob(r.width/2, r.height/2);
        onMove(0,0);
      };

      el.addEventListener('touchstart', (e)=>{ const t=e.changedTouches[0]; start(t.clientX,t.clientY); }, {passive:true});
      el.addEventListener('touchmove', (e)=>{ const t=e.changedTouches[0]; moveEv(t.clientX,t.clientY); }, {passive:true});
      el.addEventListener('touchend', end);
      el.addEventListener('mousedown', (e)=> start(e.clientX, e.clientY));
      window.addEventListener('mousemove', (e)=> moveEv(e.clientX, e.clientY));
      window.addEventListener('mouseup', end);

      const r = rect();
      setKnob(r.width/2, r.height/2);
    }

    function setMode(m){
      mode = m;
      const mobileUI = document.getElementById('mobile-controls');
      mobileUI.style.display = (mode==='mobile') ? 'flex' : 'none';
      document.getElementById('toggle').textContent = `Mode: ${mode.toUpperCase()}`;
      document.getElementById('status').textContent = (mode==='mobile')
        ? 'Two sticks: left to move, right to look. Press E (keyboard) for map.'
        : 'WASD to move. Drag to look. Press E to toggle map.';
    }

    function toggleMap(){
      mapVisible = !mapVisible;
      mapEl.style.display = mapVisible ? 'block' : 'none';
      document.getElementById('status').textContent = mapVisible ? 'Map open.' : 'Map closed.';
    }

    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());

      // Flashlight follows camera (always on)
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const camPos = camera.position.clone();
      const torchPos = camPos.clone().add(dir.clone().multiplyScalar(0.2)).add(new THREE.Vector3(0, -0.1, 0));
      flashlight.position.copy(torchPos);
      flashlight.target.position.copy(camPos.clone().add(dir.clone().multiplyScalar(4)));

      // Spin collectibles + glow pulse
      collectibles.forEach(c=>{
        c.rotation.y += dt * c.userData.spin;
        const glow = c.userData.glow;
        glow.intensity = 0.7 + 0.3*Math.sin(perfNow()*0.002 + c.userData.spin);
      });

      // Movement
      const speed = PLAYER_SPEED_BASE;
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize().negate();

      let accel = new THREE.Vector3();
      if(move.f) accel.add(forward);
      if(move.b) accel.add(forward.clone().multiplyScalar(-1));
      if(move.l) accel.add(right.clone().multiplyScalar(-1));
      if(move.r) accel.add(right);

      if (accel.lengthSq() > 0) accel.normalize();
      velocity.lerp(accel.multiplyScalar(speed), 0.15);
      camera.position.add(velocity.clone().multiplyScalar(dt));

      // Clamp to world
      camera.position.x = THREE.MathUtils.clamp(camera.position.x, -WORLD_SIZE*0.49, WORLD_SIZE*0.49);
      camera.position.z = THREE.MathUtils.clamp(camera.position.z, -WORLD_SIZE*0.49, WORLD_SIZE*0.49);

      // Monster AI
      updateMonster(dt);

      // Collect detection
      checkCollect();

      // Level progression
      if (collectedCount === collectibles.length && collectibles.length>0){
        levelIndex++;
        if(levelIndex >= LEVELS.length){
          document.getElementById('status').textContent = 'You escaped the nightmare.';
          collectibles.forEach(c=>{
            if (c.userData.glow) scene.remove(c.userData.glow);
            scene.remove(c);
          });
          collectibles = [];
        } else {
          document.getElementById('status').textContent = 'Deeper you go… it follows.';
          setupLevel(levelIndex);
        }
      }

      // Draw map if visible
      if (mapVisible) drawMap();

      renderer.render(scene, camera);
    }

    function updateMonster(dt){
      if(!monster) return;

      // Pulse and slight twitch
      monster.userData.pulse += dt;
      const s = 1.0 + Math.sin(monster.userData.pulse*2.3)*0.03;
      monster.scale.set(s, s, s);
      monster.rotation.y += Math.sin(perfNow()*0.001)*0.002;

      // Chase with noise
      const desired = camera.position.clone()
        .add(new THREE.Vector3(randRange(-0.2,0.2),0,randRange(-0.2,0.2)).multiplyScalar(monster.userData.aggro))
        .sub(monster.position).setY(0).normalize();

      monster.position.add(desired.multiplyScalar(monster.userData.speed * dt));

      // Face player
      const facing = camera.position.clone();
      facing.y = monster.position.y;
      monster.lookAt(facing);

      // Eye targets
      const target = monster.children.find(o => o instanceof THREE.Object3D && !o.isMesh);
      if(target) target.position.copy(camera.position);

      // Status prompts
      const dist = monster.position.distanceTo(camera.position);
      if (dist < 5 && perfNow() > monsterGrowlTimer){
        monsterGrowlTimer = perfNow() + randRange(1200, 2500);
        document.getElementById('status').textContent = ['It is near.','Don’t run… it will.','Hold your breath.','Keep moving.'][Math.floor(Math.random()*4)];
      }

      // Catch player -> reset level
      if (dist < 1.2){
        document.getElementById('status').textContent = 'It found you.';
        levelIndex = Math.max(0, levelIndex-1);
        setupLevel(levelIndex);
      }
    }

    function checkCollect(){
      const reach = 1.2;
      for(let i=collectibles.length-1;i>=0;i--){
        const c = collectibles[i];
        const d = c.position.distanceTo(camera.position);
        if (d < reach){
          if (c.userData.glow) { c.userData.glow.intensity = 0; scene.remove(c.userData.glow); }
          scene.remove(c);
          collectibles.splice(i,1);
          collectedCount++;
          document.getElementById('status').textContent = 'You grasp the orange shape.';
          updateUI();
        }
      }
    }

    function updateUI(){
      const conf = LEVELS[levelIndex] || LEVELS[LEVELS.length-1];
      document.getElementById('level').textContent = `Level: ${levelIndex+1}`;
      document.getElementById('collected').textContent = `Collected: ${collectedCount} / ${conf.count}`;
    }

    // Map rendering
    function drawMap(){
      const w = mapCanvas.width, h = mapCanvas.height;
      mapCtx.fillStyle = '#0a0a0a';
      mapCtx.fillRect(0,0,w,h);

      // Border glow
      mapCtx.strokeStyle = '#333';
      mapCtx.lineWidth = 2;
      mapCtx.strokeRect(1,1,w-2,h-2);

      // Convert world coords to map coords
      const scale = w / WORLD_SIZE; // world spans ~WORLD_SIZE
      const ox = w/2, oz = h/2;

      function toMap(x, z){
        return { x: ox + x * scale, z: oz + z * scale };
      }

      // Player dot (white)
      const p = toMap(camera.position.x, camera.position.z);
      mapCtx.fillStyle = '#ffffff';
      mapCtx.beginPath();
      mapCtx.arc(p.x, p.z, 4, 0, Math.PI*2);
      mapCtx.fill();

      // Player direction line
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      const dirLen = 12;
      mapCtx.strokeStyle = '#cccccc';
      mapCtx.beginPath();
      mapCtx.moveTo(p.x, p.z);
      mapCtx.lineTo(p.x + forward.x*dirLen, p.z + forward.z*dirLen);
      mapCtx.stroke();

      // Monster dot (red)
      if (monster){
        const m = toMap(monster.position.x, monster.position.z);
        mapCtx.fillStyle = '#ff3333';
        mapCtx.beginPath();
        mapCtx.arc(m.x, m.z, 5, 0, Math.PI*2);
        mapCtx.fill();
      }

      // Collectibles (orange)
      mapCtx.fillStyle = '#ff8a33';
      collectibles.forEach(c=>{
        const pos = toMap(c.position.x, c.position.z);
        mapCtx.fillRect(pos.x-2, pos.z-2, 4, 4);
      });

      // Grid hints
      mapCtx.strokeStyle = 'rgba(255,255,255,0.06)';
      mapCtx.lineWidth = 1;
      for(let i=-2;i<=2;i++){
        mapCtx.beginPath();
        mapCtx.moveTo(ox + i*WORLD_SIZE*0.1*scale, 0);
        mapCtx.lineTo(ox + i*WORLD_SIZE*0.1*scale, h);
        mapCtx.stroke();

        mapCtx.beginPath();
        mapCtx.moveTo(0, oz + i*WORLD_SIZE*0.1*scale);
        mapCtx.lineTo(w, oz + i*WORLD_SIZE*0.1*scale);
        mapCtx.stroke();
      }
    }

    // Utils
    function randRange(a,b){ return a + Math.random()*(b-a); }
    function perfNow(){ return performance.now ? performance.now() : Date.now(); }
  </script>
</body>
</html>
