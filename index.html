<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>3D Mobile Platformer</title>
<style>
  html, body { margin:0; height:100%; background:#101318; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #game { position:fixed; inset:0; }
  #hud { position: fixed; left: 0; right: 0; top: 0; display: flex; gap: 8px; justify-content: space-between; padding: 10px; pointer-events: none; color:#e6e6e6; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
  .panel { background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 12px; }
  #msg { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; color:#fff; background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.15); border-radius: 10px; padding:8px 12px; pointer-events:none; }
  #controls { position: fixed; inset: 0; pointer-events: none; }
  .stick-wrap { position: absolute; width: 140px; height: 140px; pointer-events: auto; touch-action: none; }
  .stick-base, .stick-thumb { position: absolute; border-radius: 50%; }
  .stick-base { width: 140px; height: 140px; background: rgba(255,255,255,0.08); }
  .stick-thumb { width: 70px; height: 70px; left: 35px; top: 35px; background: rgba(255,255,255,0.2); }
  .btn { position: absolute; right: 20px; bottom: 120px; width: 90px; height: 90px; border-radius: 50%; pointer-events: auto; background: radial-gradient(circle at 30% 30%, #fff 0%, #f6b73c 35%, #e36c1b 60%, #ad3a0a 100%); box-shadow: 0 10px 25px rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.5); }
  .btn:active { transform: scale(0.96); }
  #menu { position: fixed; left: 50%; transform: translateX(-50%); bottom: 70px; display: flex; gap: 8px; pointer-events: auto; }
  #menu select, #menu button { padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.35); color:#e6e6e6; }
  #pauseOverlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); color:#fff; font-size: 20px; font-weight:700; text-align:center; }
  #pauseOverlay .inner { background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.2); padding: 14px 18px; border-radius: 10px; }
  * { -webkit-tap-highlight-color: transparent; user-select: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="panel" id="score">Stars: 0 / 0</div>
  <div class="panel" id="level">Level 1</div>
  <div class="panel" id="mode">Mode: Classic</div>
  <div class="panel" id="timer" style="display:none;">Time: 60.0s</div>
  <div class="panel" id="lives" style="display:none;">Lives: 3</div>
</div>
<div id="msg">Collect stars and reach the glowing goal!</div>

<div id="controls">
  <!-- Movement joystick only -->
  <div class="stick-wrap" id="moveStick" style="left:20px; bottom:20px;">
    <div class="stick-base"></div>
    <div class="stick-thumb" id="moveThumb"></div>
  </div>
  <button class="btn" id="jumpBtn" aria-label="Jump"></button>
</div>

<div id="menu">
  <select id="levelSelect"></select>
  <select id="modeSelect">
    <option value="classic">Classic</option>
    <option value="time">Time Attack</option>
    <option value="survival">Survival</option>
  </select>
  <button id="restartBtn">Restart</button>
  <button id="pauseBtn">Pause</button>
  <button id="toggleViewBtn">Toggle View</button>
</div>

<div id="pauseOverlay"><div class="inner">Paused<br/><small>(Tap or press P to resume)</small></div></div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
<script>
(() => {
  // Renderer, scene, camera
  const canvas = document.getElementById('game');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1220);
  scene.fog = new THREE.Fog(0x0f1220, 40, 120);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 10);

  // Lighting
  const hemi = new THREE.HemisphereLight(0x88aaff, 0x111122, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.9);
  sun.position.set(8, 12, 6);
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024, 1024);
  scene.add(sun);

  // Materials
  const matPlatform = new THREE.MeshStandardMaterial({ color: 0x2b5c4b, roughness: 0.8, metalness: 0.1 });
  const matPlatformAlt = new THREE.MeshStandardMaterial({ color: 0x3a2b5c, roughness: 0.85, metalness: 0.1 });
  const matPlayer = new THREE.MeshStandardMaterial({ color: 0xf0f3f8, roughness: 0.3, metalness: 0.2, emissive: 0x111111, emissiveIntensity: 0.25 });
  const matStar = new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0xffc107, emissiveIntensity: 0.9, roughness: 0.2, metalness: 0.6 });
  const matGoal = new THREE.MeshStandardMaterial({ color: 0x5ce1e6, emissive: 0x29d5da, emissiveIntensity: 0.8, roughness: 0.4, metalness: 0.4 });

  // Player capsule
  const playerRadius = 0.5;
  const playerHeight = 1.2;
  const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, playerHeight, 8, 16), matPlayer);
  player.castShadow = true;
  player.receiveShadow = false;
  scene.add(player);

  // Camera rig / mode
  let cameraMode = 'third'; // 'third' | 'first'
  let camYaw = 0;
  let camPitch = 0.25;
  const pitchMin = -0.3, pitchMax = 0.85;
  const orbitRadius = 7.5;

  // Level data
  const LEVELS = [
    {
      name: "Beginnings",
      platforms: [
        {x:0,y:0,z:0,w:20,d:20,alt:false},
        {x:8,y:2,z:-6,w:6,d:6,alt:true},
        {x:16,y:4,z:-12,w:6,d:6,alt:false},
        {x:24,y:6,z:-18,w:6,d:6,alt:true},
        {x:24,y:8,z:-26,w:8,d:6,alt:false}
      ],
      stars: [[4,1.5,-3],[8,3.5,-6],[16,5.5,-12],[24,7.3,-18],[24,9.3,-26]],
      goal: [24,9.5,-26],
      spawn: [0,2.5,5]
    },
    {
      name: "Sky bridge",
      platforms: [
        {x:0,y:0,z:0,w:20,d:20,alt:false},
        {x:0,y:6,z:-10,w:8,d:4,alt:true},
        {x:10,y:10,z:-20,w:6,d:6,alt:false},
        {x:2,y:14,z:-30,w:10,d:4,alt:true},
        {x:-8,y:18,z:-40,w:6,d:6,alt:false}
      ],
      stars: [[0,7,-10],[10,11,-20],[2,15,-30],[-8,19,-40]],
      goal: [-8,19.2,-40],
      spawn: [0,2.5,5]
    },
    {
      name: "Zigzag canyon",
      platforms: [
        {x:0,y:0,z:0,w:20,d:20,alt:false},
        {x:6,y:2,z:-6,w:8,d:4,alt:true},
        {x:-6,y:4,z:-12,w:8,d:4,alt:true},
        {x:6,y:6,z:-18,w:8,d:4,alt:true},
        {x:-6,y:8,z:-24,w:8,d:4,alt:true},
        {x:0,y:10,z:-30,w:6,d:6,alt:false}
      ],
      stars: [[6,3,-6],[-6,5,-12],[6,7,-18],[-6,9,-24],[0,11,-30]],
      goal: [0,11.5,-30],
      spawn: [0,2.5,5]
    }
  ];

  // Gameplay containers
  let platforms = [];
  let stars = [];
  let goal = null;

  // HUD elements
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const modeEl = document.getElementById('mode');
  const timerEl = document.getElementById('timer');
  const livesEl = document.getElementById('lives');
  const msgEl = document.getElementById('msg');
  const pauseOverlay = document.getElementById('pauseOverlay');

  // Menus
  const levelSelect = document.getElementById('levelSelect');
  const modeSelect = document.getElementById('modeSelect');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const toggleViewBtn = document.getElementById('toggleViewBtn');

  // Populate level dropdown
  LEVELS.forEach((l, i) => {
    const opt = document.createElement('option');
    opt.value = i; opt.textContent = `${i+1}. ${l.name}`;
    levelSelect.appendChild(opt);
  });

  // Game mode state
  let gameMode = 'classic'; // 'classic' | 'time' | 'survival'
  let timeLeft = 60.0;
  let lives = 3;

  function updateHUD() {
    scoreEl.textContent = `Stars: ${score} / ${stars.length}`;
    levelEl.textContent = LEVELS[currentLevel].name;
    modeEl.textContent = `Mode: ${gameMode === 'classic' ? 'Classic' : gameMode === 'time' ? 'Time Attack' : 'Survival'}`;
    timerEl.style.display = gameMode === 'time' ? 'block' : 'none';
    livesEl.style.display = gameMode === 'survival' ? 'block' : 'none';
    if (gameMode === 'time') timerEl.textContent = `Time: ${timeLeft.toFixed(1)}s`;
    if (gameMode === 'survival') livesEl.textContent = `Lives: ${lives}`;
  }

  // Physics
  const velocity = new THREE.Vector3(0, 0, 0);
  const acceleration = new THREE.Vector3(0, 0, 0);
  const gravity = new THREE.Vector3(0, -24, 0);
  const friction = 8.5;
  const airControl = 0.6;
  let onGround = false;

  // Input state
  const keys = { left: false, right: false, up: false, down: false, jump: false };
  let moveDx = 0, moveDy = 0;
  let paused = false;
  let score = 0;
  const voidY = -20;

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
    if (e.code === 'Space') keys.jump = true;
    if (e.code === 'KeyP') togglePause();
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
    if (e.code === 'Space') keys.jump = false;
  });

  // Camera look via pointer drag, with deadzone behind movement joystick
  let lastMouse = null;
  window.addEventListener('pointerdown', (e) => { lastMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('pointerup', () => { lastMouse = null; });
  window.addEventListener('pointermove', (e) => {
    if (!lastMouse) return;

    // Deadzone: if pointer is inside the movement joystick area, ignore camera updates
    const moveRect = document.getElementById('moveStick').getBoundingClientRect();
    if (e.clientX >= moveRect.left && e.clientX <= moveRect.right &&
        e.clientY >= moveRect.top && e.clientY <= moveRect.bottom) {
      lastMouse = { x: e.clientX, y: e.clientY };
      return;
    }

    const dx = (e.clientX - lastMouse.x) / window.innerWidth;
    const dy = (e.clientY - lastMouse.y) / window.innerHeight;
    const jitterDeadzone = 0.01; // ignore tiny movements

    if (Math.abs(dx) > jitterDeadzone) camYaw -= dx * 3.0;
    if (Math.abs(dy) > jitterDeadzone) {
      camPitch = THREE.MathUtils.clamp(
        camPitch + (cameraMode === 'third' ? dy * 2.0 : -dy * 2.0),
        pitchMin, pitchMax
      );
    }
    lastMouse = { x: e.clientX, y: e.clientY };
  });

  // Virtual joystick setup
  function setupStick(stickId, thumbId, cb) {
    const stick = document.getElementById(stickId);
    const thumb = document.getElementById(thumbId);
    let active = false;
    const rect = () => stick.getBoundingClientRect();
    function setThumb(x, y) {
      const r = 70;
      const len = Math.hypot(x, y);
      const k = len > r ? r / len : 1;
      const tx = x * k, ty = y * k;
      thumb.style.transform = `translate(${tx}px,${ty}px)`;
      cb(tx / r, ty / r);
    }
    function reset() { thumb.style.transform = `translate(0px,0px)`; cb(0, 0); }
    stick.addEventListener('pointerdown', (e) => {
      active = true; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
      stick.setPointerCapture(e.pointerId);
    });
    stick.addEventListener('pointermove', (e) => {
      if (!active) return; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
    });
    stick.addEventListener('pointerup', () => { active = false; reset(); });
    stick.addEventListener('pointercancel', () => { active = false; reset(); });
  }

  // Movement joystick (invert directions)
  setupStick('moveStick', 'moveThumb', (dx, dy) => { moveDx = -dx; moveDy = -dy; });

  // Jump button
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.addEventListener('pointerdown', () => keys.jump = true);
  jumpBtn.addEventListener('pointerup', () => keys.jump = false);

  // Pause/resume
  function togglePause() {
    paused = !paused;
    pauseOverlay.style.display = paused ? 'flex' : 'none';
  }
  pauseOverlay.addEventListener('click', togglePause);
  pauseBtn.addEventListener('click', togglePause);

  // Prevent touch scrolling on mobile during joystick use
  document.body.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive:false });

  // Toggle first/third person
  toggleViewBtn.addEventListener('click', () => {
    cameraMode = cameraMode === 'third' ? 'first' : 'third';
    player.visible = cameraMode !== 'first'; // hide capsule in first person
  });

  // Geometry helpers
  function makePlatform(x, y, z, w, d, alt = false) {
    const geo = new THREE.BoxGeometry(w, 0.5, d);
    const mesh = new THREE.Mesh(geo, alt ? matPlatformAlt : matPlatform);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    platforms.push(mesh);
    return mesh;
  }

  function makeStar(x, y, z) {
    const s = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 0), matStar);
    s.position.set(x, y, z);
    s.castShadow = true;
    scene.add(s);
    stars.push(s);
    return s;
  }

  function aabbSphereCollision(box, spherePos, sphereR) {
    const bPos = box.position;
    box.geometry.computeBoundingBox();
    const bb = box.geometry.boundingBox;
    const halfX = (bb.max.x - bb.min.x)/2, halfY = (bb.max.y - bb.min.y)/2, halfZ = (bb.max.z - bb.min.z)/2;
    const minX = bPos.x - halfX, minY = bPos.y - halfY, minZ = bPos.z - halfZ;
    const maxX = bPos.x + halfX, maxY = bPos.y + halfY, maxZ = bPos.z + halfZ;
    const cx = Math.max(minX, Math.min(spherePos.x, maxX));
    const cy = Math.max(minY, Math.min(spherePos.y, maxY));
    const cz = Math.max(minZ, Math.min(spherePos.z, maxZ));
    const dx = spherePos.x - cx, dy = spherePos.y - cy, dz = spherePos.z - cz;
    const dist2 = dx*dx + dy*dy + dz*dz;
    if (dist2 <= sphereR*sphereR) return new THREE.Vector3(dx, dy, dz);
    return null;
  }

  // Level management
  let currentLevel = 0;
  levelSelect.value = String(currentLevel);

  function clearLevel() {
    platforms.forEach(m => scene.remove(m));
    stars.forEach(s => scene.remove(s));
    platforms = []; stars = [];
    if (goal) { scene.remove(goal); goal = null; }
  }

  function loadLevel(i) {
    clearLevel();
    currentLevel = i;
    const lvl = LEVELS[i];

    lvl.platforms.forEach(p => makePlatform(p.x, p.y, p.z, p.w, p.d, p.alt));
    lvl.stars.forEach(([x,y,z]) => makeStar(x, y, z));
    goal = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.25, 16, 64), matGoal);
    goal.position.set(lvl.goal[0], lvl.goal[1], lvl.goal[2]);
    goal.castShadow = true;
    scene.add(goal);

    score = 0;
    player.position.set(lvl.spawn[0], lvl.spawn[1], lvl.spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    msgEl.textContent = 'Collect stars and reach the glowing goal!';
    updateHUD();
  }

  function applyMode(mode) {
    gameMode = mode;
    if (gameMode === 'time') timeLeft = 60.0;
    if (gameMode === 'survival') lives = 3;
    updateHUD();
  }

  levelSelect.addEventListener('change', (e) => {
    loadLevel(parseInt(e.target.value, 10));
  });
  modeSelect.addEventListener('change', (e) => {
    applyMode(e.target.value);
  });
  restartBtn.addEventListener('click', () => {
    loadLevel(currentLevel);
  });

  function respawn(penalize = true) {
    const spawn = LEVELS[currentLevel].spawn;
    player.position.set(spawn[0], spawn[1], spawn[2]);
    velocity.set(0,0,0);
    onGround = false;

    if (gameMode === 'survival' && penalize) {
      lives -= 1;
      msgEl.textContent = lives > 0 ? `Oops! Lives left: ${lives}` : 'Game over. Restart or change level.';
      if (lives <= 0) paused = true;
    } else {
      msgEl.textContent = 'Try again! Reach the glowing goal.';
    }
    updateHUD();
  }

  // Decorative dust particles
  const dustGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const dustMat = new THREE.MeshBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.25 });
  const dusts = [];
  for (let i=0;i<80;i++){
    const d = new THREE.Mesh(dustGeo, dustMat);
    d.position.set((Math.random()-0.5)*60, 2+Math.random()*12, (Math.random()-0.5)*100);
    scene.add(d); dusts.push(d);
  }

  // Init
  loadLevel(0);
  applyMode('classic');

  // Main loop
  const clock = new THREE.Clock();
  let tGoal = 0;

  function animate() {
    requestAnimationFrame(animate);
    if (paused) return;

    const dt = Math.min(0.033, clock.getDelta());

    // Time attack
    if (gameMode === 'time') {
      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        msgEl.textContent = 'Time up! Restart or switch mode.';
        paused = true;
      }
    }
    updateHUD();

    // Input vector: keyboard + inverted movement joystick
    const ix = (keys.right ? 1 : 0) - (keys.left ? 1 : 0) + moveDx;
    const iz = (keys.down ? 1 : 0) - (keys.up ? 1 : 0) + moveDy;
    const input = new THREE.Vector3(ix, 0, iz);
    if (input.lengthSq() > 1) input.normalize();

    // Camera forward/right
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

    // Movement relative to camera
    const moveVec = new THREE.Vector3()
      .addScaledVector(forward, input.z)
      .addScaledVector(right, input.x);

    // Movement
    const accelMag = onGround ? 16 : 16 * airControl;
    acceleration.set(moveVec.x * accelMag, 0, moveVec.z * accelMag);
    acceleration.add(gravity);
    velocity.addScaledVector(acceleration, dt);

    // Ground friction when idle
    if (onGround && moveVec.lengthSq() < 1e-4) {
      velocity.x = THREE.MathUtils.damp(velocity.x, 0, friction, dt);
      velocity.z = THREE.MathUtils.damp(velocity.z, 0, friction, dt);
    }

    // Jump (stronger)
    if (keys.jump && onGround) {
      velocity.y = 14.0;
      onGround = false;
      keys.jump = false;
    }

    // Integrate
    player.position.addScaledVector(velocity, dt);

    // Collisions
    onGround = false;
    for (const box of platforms) {
      const hit = aabbSphereCollision(box, player.position, playerRadius);
      if (hit) {
        const len = Math.hypot(hit.x, hit.y, hit.z) || 1;
        const nx = hit.x / len, ny = hit.y / len, nz = hit.z / len;
        const push = (playerRadius - len);
        player.position.x += nx * push;
        player.position.y += ny * push;
        player.position.z += nz * push;

        if (ny > 0.5) {
          onGround = true;
          if (velocity.y < 0) velocity.y = 0;
        } else {
          velocity.x *= 0.82;
          velocity.z *= 0.82;
        }
      }
    }

    // Stars
    for (const s of stars) {
      if (!s.visible) continue;
      const d = s.position.distanceTo(player.position);
      if (d < playerRadius + 0.6) {
        s.visible = false;
        score += 1;
        msgEl.textContent = score === stars.length ? 'All stars collected! Head to the goal.' : 'Star collected!';
        updateHUD();
      } else {
        s.rotation.y += dt * 1.6;
      }
    }

    // Goal
    tGoal += dt;
    if (goal) {
      goal.rotation.x = Math.sin(tGoal * 1.2) * 0.2;
      goal.rotation.y += dt * 0.8;
      if (player.position.distanceTo(goal.position) < 1.6) {
        if (score === stars.length) {
          msgEl.textContent = 'Level complete! Loading next...';
          const next = (currentLevel + 1) % LEVELS.length;
          setTimeout(() => { loadLevel(next); }, 800);
        } else {
          msgEl.textContent = 'Collect all stars first!';
        }
      }
    }

    // Void fall
    if (player.position.y < voidY) {
      respawn(gameMode === 'survival');
    }

    // Camera placement (snap, no lag)
    if (cameraMode === 'third') {
      const y = Math.sin(camPitch) * orbitRadius;
      const h = Math.cos(camPitch) * orbitRadius;
      const camX = player.position.x + Math.sin(camYaw) * h;
      const camZ = player.position.z + Math.cos(camYaw) * h;
      const target = new THREE.Vector3(camX, player.position.y + y + 1.5, camZ);
      camera.position.copy(target);
      camera.lookAt(new THREE.Vector3(player.position.x, player.position.y + 0.8, player.position.z));
    } else {
      const head = new THREE.Vector3(player.position.x, player.position.y + playerHeight * 0.5 + 0.5, player.position.z);
      camera.position.copy(head);
      const dir = new THREE.Vector3(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      );
      camera.lookAt(head.clone().add(dir));
    }

    // Ambient particles drift
    for (const d of dusts) {
      d.position.x += Math.sin(tGoal + d.id) * 0.003;
      d.position.y += Math.cos(tGoal + d.id) * 0.002;
    }

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

})();
</script>
</body>
</html>
