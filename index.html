<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Fortnite-Style 3D Game (Single HTML)</title>
<style>
  body { margin:0; overflow:hidden; font-family:Arial, sans-serif; }
  #info { position:absolute; top:10px; left:10px; color:white; background:rgba(0,0,0,0.5); padding:10px; border-radius:8px; }
  #crosshair { position:absolute; top:50%; left:50%; font-size:30px; color:white; pointer-events:none; transform:translate(-50%,-50%); }
  #startScreen { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); color:white; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:10; }
  #startScreen h1 { font-size:48px; margin:0; }
  #startScreen p { font-size:24px; margin:10px 0; cursor:pointer; }
</style>
</head>
<body>
<div id="startScreen">
  <h1>Mini Fortnite-Style Game</h1>
  <p>Click to Start</p>
</div>
<div id="info">Score: <span id="score">0</span><br>
WASD = Move | SPACE = Jump | L-Click = Shoot | B = Build Mode (click to place)</div>
<div id="crosshair">+</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/PointerLockControls.js"></script>

<script>
// ================ BASIC SETUP ================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// ================ POINTER LOCK CONTROLS ================
const controls = new THREE.PointerLockControls(camera, document.body);

// ================ LIGHTING ================
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(50, 100, 30);
scene.add(dirLight);

// ================ GROUND ================
const groundGeo = new THREE.PlaneGeometry(500, 500);
const groundMat = new THREE.MeshStandardMaterial({color:0x3d9140});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// ================ PLAYER PHYSICS ================
let move = {forward:false, backward:false, left:false, right:false, jump:false};
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let canJump = false;
const gravity = -40;
const playerHeight = 1.8;

camera.position.y = playerHeight;

document.addEventListener('keydown', e => {
  switch(e.code){
    case 'KeyW': move.forward = true; break;
    case 'KeyS': move.backward = true; break;
    case 'KeyA': move.left = true; break;
    case 'KeyD': move.right = true; break;
    case 'Space': if(canJump) move.jump = true; break;
    case 'KeyB': buildMode = !buildMode; updateInfo(); break;
  }
});
document.addEventListener('keyup', e => {
  switch(e.code){
    case 'KeyW': move.forward = false; break;
    case 'KeyS': move.backward = false; break;
    case 'KeyA': move.left = false; break;
    case 'KeyD': move.right = false; break;
  }
});

// ================ SHOOTING ================
const bullets = [];
const bulletSpeed = 100;

function shoot(){
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.15),
    new THREE.MeshBasicMaterial({color:0xffff00})
  );
  bullet.position.copy(camera.position);
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  bullet.velocity = dir.multiplyScalar(bulletSpeed);
  scene.add(bullet);
  bullets.push(bullet);
}

// ================ BUILDING SYSTEM ================
let buildMode = false;
let previewMesh = null;
const buildPieces = [];
const buildTypes = ['wall','ramp','floor'];
let currentBuildType = 0;

function createPreview(){
  if(previewMesh) scene.remove(previewMesh);
  let geo;
  if(buildTypes[currentBuildType]==='wall') geo = new THREE.BoxGeometry(4,4,0.3);
  if(buildTypes[currentBuildType]==='ramp') geo = new THREE.BoxGeometry(4,4,4);
  if(buildTypes[currentBuildType]==='floor') geo = new THREE.BoxGeometry(4,0.3,4);
  
  previewMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0x4488ff, opacity:0.5, transparent:true}));
  scene.add(previewMesh);
}

function placeStructure(){
  const mat = new THREE.MeshStandardMaterial({color:0x8888ff, metalness:0.3, roughness:0.7});
  let mesh;
  if(buildTypes[currentBuildType]==='wall'){
    mesh = new THREE.Mesh(new THREE.BoxGeometry(4,4,0.3), mat);
  }
  if(buildTypes[currentBuildType]==='floor'){
    mesh = new THREE.Mesh(new THREE.BoxGeometry(4,0.3,4), mat);
  }
  if(buildTypes[currentBuildType]==='ramp'){
    mesh = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), mat);
    mesh.rotation.x = -Math.PI/4;
    mesh.position.y += 2;
  }
  const pos = previewMesh.position.clone();
  pos.y = (buildTypes[currentBuildType]==='floor') ? 0.15 : pos.y;
  mesh.position.copy(pos);
  scene.add(mesh);
  buildPieces.push(mesh);
  score += 10;
  updateScore();
}

// ================ TARGET CUBES (Enemies/Props) ================
let score = 0;
const targets = [];
function createTargets(count){
  const geo = new THREE.BoxGeometry(2,2,2);
  for(let i=0;i<count;i++){
    const mat = new THREE.MeshStandardMaterial({color:Math.random()*0xffffff});
    const cube = new THREE.Mesh(geo, mat);
    cube.position.set(
      Math.random()*180-90,
      1,
      Math.random()*180-90
    );
    scene.add(cube);
    targets.push(cube);
  }
}
createTargets(40);

// ================ UI ================
function updateInfo(){
  document.getElementById('info').innerHTML = `
    Score: <b>${score}</b><br>
    WASD Move • SPACE Jump • Click Shoot • B = Build Mode ${buildMode?'<b>ON</b>':''}
  `;
}
function updateScore(){ document.getElementById('score').textContent = score; }
updateInfo();

// ================ MOUSE CLICK ================
document.addEventListener('click', () => {
  if(gameStarted && controls.isLocked){
    if(buildMode){
      placeStructure();
    }else{
      shoot();
    }
  }
});

// Cycle build type with mouse wheel
document.addEventListener('wheel', e => {
  if(!buildMode || !gameStarted) return;
  currentBuildType = (currentBuildType + (e.deltaY>0?1:-1) + 3) % 3;
  createPreview();
});

// ================ START SCREEN ================
let gameStarted = false;
const startScreen = document.getElementById('startScreen');
startScreen.addEventListener('click', () => {
  startScreen.style.display = 'none';
  controls.lock();
  gameStarted = true;
  createPreview(); // Initialize preview after start
});

// ================ MAIN LOOP ================
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  if(!gameStarted) {
    renderer.render(scene, camera); // Still render scene behind start screen
    return;
  }
  const delta = clock.getDelta();

  if(controls.isLocked){
    // --- Movement & Gravity ---
    direction.z = Number(move.forward) - Number(move.backward);
    direction.x = Number(move.right) - Number(move.left);
    direction.normalize();

    if(move.forward || move.backward) velocity.z = direction.z * 12;
    else velocity.z *= 0.9;
    if(move.left || move.right) velocity.x = direction.x * 12;
    else velocity.x *= 0.9;

    velocity.y += gravity * delta;

    if(move.jump){
      if(canJump){
        velocity.y = 12;
        canJump = false;
      }
      move.jump = false;
    }

    controls.moveRight(velocity.x * delta);
    controls.moveForward(velocity.z * delta);
    controls.getObject().position.y += velocity.y * delta;

    // Ground collision
    if(controls.getObject().position.y < playerHeight){
      velocity.y = 0;
      controls.getObject().position.y = playerHeight;
      canJump = true;
    }

    // --- Build preview follows cursor ---
    if(buildMode && previewMesh){
      const ray = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
      const intersect = ray.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0,1,0), 0), new THREE.Vector3());
      if(intersect){
        previewMesh.position.copy(intersect).add(new THREE.Vector3(0,2,0));
        previewMesh.position.x = Math.round(previewMesh.position.x/4)*4;
        previewMesh.position.z = Math.round(previewMesh.position.z/4)*4;
      }
    }
  }

  // --- Bullets ---
  for(let i=bullets.length-1; i>=0; i--){
    const b = bullets[i];
    b.position.add(b.velocity.clone().multiplyScalar(delta));
    if(b.position.length() > 300){
      scene.remove(b);
      bullets.splice(i,1);
      continue;
    }
    // Hit targets
    for(let j=targets.length-1; j>=0; j--){
      if(b.position.distanceTo(targets[j].position)<2){
        scene.remove(targets[j]);
        targets.splice(j,1);
        scene.remove(b);
        bullets.splice(i,1);
        score += 50;
        updateScore();
        break;
      }
    }
  }

  renderer.render(scene, camera);
}
animate();

// Resize handler
window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
