<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>3D Mobile Platformer</title>
<style>
  html, body { margin:0; height:100%; background:#0c1326; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #game { position:fixed; inset:0; }

  #hud { position: fixed; left: 0; right: 0; top: 0; display: flex; gap: 8px; justify-content: space-between; padding: 10px; pointer-events: none; color:#e6e6e6; font-weight: 600; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
  .panel { background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 12px; }
  #msg { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; color:#fff; background: rgba(0,0,0,0.45); border:1px solid rgba(255,255,255,0.15); border-radius: 10px; padding:8px 12px; pointer-events:none; }

  #controls { position: fixed; inset: 0; pointer-events: none; }
  .stick-wrap { position: absolute; width: 160px; height: 160px; pointer-events: auto; touch-action: none; }
  .stick-base, .stick-thumb { position: absolute; border-radius: 50%; }
  .stick-base { width: 160px; height: 160px; background: rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.18); backdrop-filter: blur(4px); }
  .stick-thumb { width: 80px; height: 80px; left: 40px; top: 40px; background: rgba(255,255,255,0.22); border:2px solid rgba(255,255,255,0.3); }
  .btn { position: absolute; right: 24px; bottom: 120px; width: 100px; height: 100px; border-radius: 50%; pointer-events: auto; touch-action: manipulation;
    background: radial-gradient(circle at 30% 30%, #fff 0%, #f6b73c 35%, #e36c1b 60%, #ad3a0a 100%);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 0 10px rgba(255,255,255,0.4); border: 2px solid rgba(255,255,255,0.5); }
  .btn:active { transform: scale(0.96); }

  #menu { position: fixed; left: 50%; transform: translateX(-50%); bottom: 70px; display: flex; flex-wrap: wrap; gap: 8px; pointer-events: auto; }
  #menu select, #menu button, #menu input {
    padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.35); color:#e6e6e6; backdrop-filter: blur(3px);
  }

  #pauseOverlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); color:#fff; font-size: 20px; font-weight:700; text-align:center; }
  #pauseOverlay .inner { background: rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.2); padding: 14px 18px; border-radius: 10px; }

  /* Main menu overlay */
  #mainMenu { position: fixed; inset: 0; display: none; background: rgba(0,0,0,0.7); color: #e6e6e6; }
  #mainMenu .wrap { position: absolute; left:50%; top:50%; transform: translate(-50%,-50%); width: min(720px, 92vw); max-height: 80vh; overflow:auto;
    background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 16px; }
  #mainMenu h2 { margin: 0 0 10px; font-weight: 700; }
  .tabs { display: flex; gap: 8px; margin-bottom: 12px; }
  .tab { padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); cursor: pointer; }
  .tab.active { background: rgba(255,255,255,0.18); }
  .tabpane { display: none; }
  .tabpane.active { display: block; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; }
  .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 10px; }
  .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
  .swatch { width: 26px; height: 26px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.4); cursor: pointer; }
  .closeMenu { position: absolute; right: 12px; top: 12px; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="panel" id="score">Stars: 0 / 0</div>
  <div class="panel" id="level">Level 1</div>
  <div class="panel" id="mode">Mode: Classic</div>
  <div class="panel" id="timer" style="display:none;">Time: 60.0s</div>
  <div class="panel" id="lives" style="display:none;">Lives: 3</div>
</div>
<div id="msg">Collect stars and reach the glowing goal!</div>

<div id="controls">
  <!-- Movement joystick -->
  <div class="stick-wrap" id="moveStick" style="left:24px; bottom:24px;">
    <div class="stick-base"></div>
    <div class="stick-thumb" id="moveThumb"></div>
  </div>
  <!-- Jump button (camera deadzone underneath this area) -->
  <button class="btn" id="jumpBtn" aria-label="Jump"></button>
</div>

<div id="menu">
  <select id="levelSelect"></select>
  <select id="modeSelect">
    <option value="classic">Classic</option>
    <option value="time">Time Attack</option>
    <option value="survival">Survival</option>
  </select>
  <button id="restartBtn">Restart</button>
  <button id="pauseBtn">Pause</button>
  <button id="toggleViewBtn">Toggle View</button>
  <button id="openMenuBtn">Main Menu</button>
  <!-- Code input for owner cosmetic -->
  <input id="codeInput" placeholder="Enter code" />
  <button id="codeApplyBtn">Apply</button>
</div>

<div id="pauseOverlay"><div class="inner">Paused<br/><small>(Tap or press P to resume)</small></div></div>

<!-- Main Menu Overlay -->
<div id="mainMenu">
  <div class="wrap">
    <button class="closeMenu" id="closeMenuBtn">Close</button>
    <h2>Main menu</h2>
    <div class="tabs">
      <div class="tab active" data-tab="levelsTab">Levels</div>
      <div class="tab" data-tab="customTab">Customize</div>
      <div class="tab" data-tab="optionsTab">Options</div>
    </div>
    <div id="levelsTab" class="tabpane active">
      <div class="grid" id="levelsGrid"></div>
    </div>
    <div id="customTab" class="tabpane">
      <div class="card">
        <h3>Character customization</h3>
        <div class="row">
          <div>Color:</div>
          <div class="swatch" data-color="#f0f3f8" style="background:#f0f3f8"></div>
          <div class="swatch" data-color="#ff9aa2" style="background:#ff9aa2"></div>
          <div class="swatch" data-color="#9ad1ff" style="background:#9ad1ff"></div>
          <div class="swatch" data-color="#a3ffb0" style="background:#a3ffb0"></div>
          <div class="swatch" data-color="#ffd54f" style="background:#ffd54f"></div>
        </div>
        <div class="row">
          <label><input type="checkbox" id="hatToggle"/> Hat accessory</label>
          <label><input type="checkbox" id="trailToggle"/> Sparkle trail</label>
        </div>
      </div>
    </div>
    <div id="optionsTab" class="tabpane">
      <div class="card">
        <h3>Gameplay</h3>
        <div class="row">
          <label><input type="checkbox" id="doubleJumpToggle" checked/> Enable double jump</label>
        </div>
        <div class="row">
          <label>Camera sensitivity
            <input type="range" id="camSens" min="1.0" max="6.0" step="0.1" value="3.5"/>
          </label>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
<script>
(() => {
  // Renderer, scene, camera
  const canvas = document.getElementById('game');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0c1326);
  scene.fog = new THREE.Fog(0x0c1326, 50, 140);

  const camera = new THREE.PerspectiveCamera(62, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 10);

  // Lighting (richer scene)
  const hemi = new THREE.HemisphereLight(0x9bd4ff, 0x12131a, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xfff1e4, 1.0);
  sun.position.set(12, 16, 10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.left = -40;
  sun.shadow.camera.right = 40;
  sun.shadow.camera.top = 40;
  sun.shadow.camera.bottom = -40;
  scene.add(sun);

  // Ground plane and distant props for visual richness
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x182235, roughness: 0.95, metalness: 0.0 });
  const ground = new THREE.Mesh(new THREE.CircleGeometry(80, 64), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  const pillarMat = new THREE.MeshStandardMaterial({ color: 0x283b5e, roughness: 0.8 });
  for (let i=0;i<12;i++){
    const h = 2 + Math.random()*4;
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,h,24), pillarMat);
    const r = 45 + Math.random()*20, a = Math.random()*Math.PI*2;
    p.position.set(Math.cos(a)*r, h/2, Math.sin(a)*r);
    p.castShadow = true; p.receiveShadow = true;
    scene.add(p);
  }

  // Materials
  const matPlatform = new THREE.MeshStandardMaterial({ color: 0x2b5c4b, roughness: 0.78, metalness: 0.12 });
  const matPlatformAlt = new THREE.MeshStandardMaterial({ color: 0x3a2b5c, roughness: 0.82, metalness: 0.12 });
  const matStar = new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0xffa000, emissiveIntensity: 1.0, roughness: 0.2, metalness: 0.6 });
  const matGoal = new THREE.MeshStandardMaterial({ color: 0x5ce1e6, emissive: 0x29d5da, emissiveIntensity: 0.9, roughness: 0.4, metalness: 0.4 });

  // Player capsule + customization
  const playerRadius = 0.5;
  const playerHeight = 1.2;
  let playerColor = 0xf0f3f8;
  const matPlayer = new THREE.MeshStandardMaterial({ color: playerColor, roughness: 0.35, metalness: 0.22, emissive: 0x141414, emissiveIntensity: 0.28 });

  const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, playerHeight, 8, 16), matPlayer);
  player.castShadow = true;
  scene.add(player);

  // "OWNER" cosmetic label (sprite above head)
  let ownerSprite = null;
  function makeOwnerSprite() {
    const c = document.createElement('canvas');
    c.width = 256; c.height = 128;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.font = 'bold 64px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff2b2b';
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 6;
    ctx.strokeText('OWNER', c.width/2, c.height/2);
    ctx.fillText('OWNER', c.width/2, c.height/2);
    const tex = new THREE.CanvasTexture(c);
    tex.needsUpdate = true;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(2.8, 1.4, 1);
    scene.add(sprite);
    return sprite;
  }

  let ownerUnlocked = false;

  // Accessories
  const hat = new THREE.Mesh(new THREE.ConeGeometry(0.45, 0.6, 12), new THREE.MeshStandardMaterial({ color: 0xff6f61, roughness: 0.5 }));
  hat.rotation.x = Math.PI;
  hat.visible = false;
  scene.add(hat);

  const trailGeom = new THREE.TorusGeometry(0.25, 0.05, 8, 24);
  const trailMat = new THREE.MeshStandardMaterial({ color: 0x88aaff, emissive: 0x88aaff, emissiveIntensity: 0.7, roughness: 0.2, metalness: 0.2 });
  const trail = new THREE.Mesh(trailGeom, trailMat);
  trail.visible = false;
  scene.add(trail);

  // Camera rig / mode
  let cameraMode = 'third'; // 'third' | 'first'
  let camYaw = 0;
  let camPitch = 0.25;
  const pitchMin = -0.3, pitchMax = 0.85;
  let camSensitivity = 3.5;
  const orbitRadius = 8.5;

  // Level data (expanded with more maps)
  const LEVELS = [
    { name: "Beginnings",
      platforms: [
        {x:0,y:0,z:0,w:20,d:20,alt:false},
        {x:8,y:2,z:-6,w:6,d:6,alt:true},
        {x:16,y:4,z:-12,w:6,d:6,alt:false},
        {x:24,y:6,z:-18,w:6,d:6,alt:true},
        {x:24,y:8,z:-26,w:8,d:6,alt:false}
      ],
      stars: [[4,1.5,-3],[8,3.5,-6],[16,5.5,-12],[24,7.3,-18],[24,9.3,-26]],
      goal: [24,9.5,-26],
      spawn: [0,2.5,5]
    },
    { name: "Sky bridge",
      platforms: [
        {x:0,y:0,z:0,w:20,d:20,alt:false},
        {x:0,y:6,z:-10,w:8,d:4,alt:true},
        {x:10,y:10,z:-20,w:6,d:6,alt:false},
        {x:2,y:14,z:-30,w:10,d:4,alt:true},
        {x:-8,y:18,z:-40,w:6,d:6,alt:false}
      ],
      stars: [[0,7,-10],[10,11,-20],[2,15,-30],[-8,19,-40]],
      goal: [-8,19.2,-40],
      spawn: [0,2.5,5]
    },
    { name: "Zigzag canyon",
      platforms: [
        {x:0,y:0,z:0,w:20,d:20,alt:false},
        {x:6,y:2,z:-6,w:8,d:4,alt:true},
        {x:-6,y:4,z:-12,w:8,d:4,alt:true},
        {x:6,y:6,z:-18,w:8,d:4,alt:true},
        {x:-6,y:8,z:-24,w:8,d:4,alt:true},
        {x:0,y:10,z:-30,w:6,d:6,alt:false}
      ],
      stars: [[6,3,-6],[-6,5,-12],[6,7,-18],[-6,9,-24],[0,11,-30]],
      goal: [0,11.5,-30],
      spawn: [0,2.5,5]
    },
    { name: "Crystal steps",
      platforms: [
        {x:0,y:0,z:0,w:22,d:22,alt:false},
        {x:4,y:2,z:-6,w:4,d:4,alt:true},
        {x:8,y:4,z:-12,w:4,d:4,alt:true},
        {x:12,y:6,z:-18,w:4,d:4,alt:true},
        {x:16,y:8,z:-24,w:4,d:4,alt:true}
      ],
      stars: [[4,3,-6],[8,5,-12],[12,7,-18],[16,9,-24]],
      goal: [18,9.5,-26],
      spawn: [0,2.5,6]
    },
    { name: "Rolling plains",
      platforms: [
        {x:0,y:0,z:0,w:26,d:26,alt:false},
        {x:-10,y:2,z:-10,w:8,d:6,alt:true},
        {x:10,y:2,z:-10,w:8,d:6,alt:true},
        {x:0,y:4,z:-22,w:10,d:6,alt:false}
      ],
      stars: [[-10,3,-10],[10,3,-10],[0,5,-22],[0,1,0]],
      goal: [0,5.5,-26],
      spawn: [0,2.5,8]
    },
    { name: "Twin towers",
      platforms: [
        {x:0,y:0,z:0,w:22,d:22,alt:false},
        {x:-4,y:4,z:-8,w:4,d:4,alt:true},
        {x:-4,y:8,z:-12,w:4,d:4,alt:true},
        {x:6,y:4,z:-10,w:4,d:4,alt:false},
        {x:6,y:8,z:-14,w:4,d:4,alt:false},
        {x:1,y:12,z:-20,w:6,d:6,alt:true}
      ],
      stars: [[-4,5,-8],[6,5,-10],[-4,9,-12],[6,9,-14],[1,13,-20]],
      goal: [1,13.2,-20],
      spawn: [0,2.5,6]
    },
    { name: "Nebula run",
      platforms: [
        {x:0,y:0,z:0,w:24,d:24,alt:false},
        {x:6,y:3,z:-8,w:6,d:4,alt:true},
        {x:12,y:6,z:-16,w:6,d:4,alt:false},
        {x:18,y:9,z:-24,w:6,d:4,alt:true},
        {x:26,y:12,z:-30,w:10,d:6,alt:false}
      ],
      stars: [[6,4,-8],[12,7,-16],[18,10,-24],[24,12.5,-28],[26,13,-30]],
      goal: [28,13.5,-32],
      spawn: [0,2.5,6]
    },
    { name: "Aurora ridge",
      platforms: [
        {x:0,y:0,z:0,w:24,d:24,alt:false},
        {x:-6,y:3,z:-8,w:6,d:4,alt:true},
        {x:-12,y:6,z:-16,w:6,d:4,alt:false},
        {x:-18,y:9,z:-24,w:6,d:4,alt:true},
        {x:-26,y:12,z:-30,w:10,d:6,alt:false}
      ],
      stars: [[-6,4,-8],[-12,7,-16],[-18,10,-24],[-24,12.5,-28],[-26,13,-30]],
      goal: [-28,13.5,-32],
      spawn: [0,2.5,6]
    }
  ];

  // Gameplay containers
  let platforms = [];
  let stars = [];
  let goal = null;

  // HUD elements
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const modeEl = document.getElementById('mode');
  const timerEl = document.getElementById('timer');
  const livesEl = document.getElementById('lives');
  const msgEl = document.getElementById('msg');
  const pauseOverlay = document.getElementById('pauseOverlay');

  // Menus
  const levelSelect = document.getElementById('levelSelect');
  const modeSelect = document.getElementById('modeSelect');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const toggleViewBtn = document.getElementById('toggleViewBtn');
  const openMenuBtn = document.getElementById('openMenuBtn');
  const codeInput = document.getElementById('codeInput');
  const codeApplyBtn = document.getElementById('codeApplyBtn');

  // Main menu overlay
  const mainMenu = document.getElementById('mainMenu');
  const closeMenuBtn = document.getElementById('closeMenuBtn');
  const tabs = Array.from(document.querySelectorAll('.tab'));
  const panes = {
    levelsTab: document.getElementById('levelsTab'),
    customTab: document.getElementById('customTab'),
    optionsTab: document.getElementById('optionsTab')
  };
  const levelsGrid = document.getElementById('levelsGrid');
  const hatToggle = document.getElementById('hatToggle');
  const trailToggle = document.getElementById('trailToggle');
  const doubleJumpToggle = document.getElementById('doubleJumpToggle');
  const camSensInput = document.getElementById('camSens');

  // Populate level dropdown and menu grid
  LEVELS.forEach((l, i) => {
    const opt = document.createElement('option');
    opt.value = i; opt.textContent = `${i+1}. ${l.name}`;
    levelSelect.appendChild(opt);

    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<strong>${i+1}. ${l.name}</strong><br/><button data-level="${i}">Play</button>`;
    levelsGrid.appendChild(card);
  });
  levelsGrid.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-level]');
    if (!btn) return;
    const idx = parseInt(btn.getAttribute('data-level'), 10);
    loadLevel(idx);
    mainMenu.style.display = 'none';
  });

  // Tab behavior
  tabs.forEach(t => t.addEventListener('click', () => {
    tabs.forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    Object.values(panes).forEach(p => p.classList.remove('active'));
    panes[t.getAttribute('data-tab')].classList.add('active');
  }));

  // Customization swatches
  Array.from(document.querySelectorAll('.swatch')).forEach(sw => {
    sw.addEventListener('click', () => {
      const hex = sw.getAttribute('data-color');
      playerColor = parseInt(hex.replace('#', ''), 16);
      matPlayer.color.setHex(playerColor);
    });
  });

  hatToggle.addEventListener('change', () => { hat.visible = hatToggle.checked; });
  trailToggle.addEventListener('change', () => { trail.visible = trailToggle.checked; });
  camSensInput.addEventListener('input', () => { camSensitivity = parseFloat(camSensInput.value); });

  // Owner code
  codeApplyBtn.addEventListener('click', () => {
    if (codeInput.value.trim().toLowerCase() === 'owner222') {
      ownerUnlocked = true;
      if (!ownerSprite) ownerSprite = makeOwnerSprite();
      msgEl.textContent = 'Owner cosmetic unlocked!';
    } else {
      msgEl.textContent = 'Invalid code.';
    }
    codeInput.value = '';
  });

  // Game mode state
  let gameMode = 'classic'; // 'classic' | 'time' | 'survival'
  let timeLeft = 60.0;
  let lives = 3;

  function updateHUD() {
    scoreEl.textContent = `Stars: ${score} / ${stars.length}`;
    levelEl.textContent = LEVELS[currentLevel].name;
    modeEl.textContent = `Mode: ${gameMode === 'classic' ? 'Classic' : gameMode === 'time' ? 'Time Attack' : 'Survival'}`;
    timerEl.style.display = gameMode === 'time' ? 'block' : 'none';
    livesEl.style.display = gameMode === 'survival' ? 'block' : 'none';
    if (gameMode === 'time') timerEl.textContent = `Time: ${timeLeft.toFixed(1)}s`;
    if (gameMode === 'survival') livesEl.textContent = `Lives: ${lives}`;
  }

  // Physics
  const velocity = new THREE.Vector3(0, 0, 0);
  const acceleration = new THREE.Vector3(0, 0, 0);
  const gravity = new THREE.Vector3(0, -24, 0);
  const friction = 8.5;
  const airControl = 0.6;
  let onGround = false;

  // Double jump state
  let canDoubleJump = true;
  let doubleJumpEnabled = true;

  // Input state
  const keys = { left: false, right: false, up: false, down: false, jump: false };
  let moveDx = 0, moveDy = 0;
  let paused = false;
  let score = 0;
  const voidY = -20;

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
    if (e.code === 'Space') keys.jump = true;
    if (e.code === 'KeyP') togglePause();
    if (e.code === 'Escape') mainMenu.style.display = 'none';
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
    if (e.code === 'Space') keys.jump = false;
  });

  // Camera look via pointer drag, with larger deadzones near controls
  const moveStickEl = document.getElementById('moveStick');
  const jumpBtnEl = document.getElementById('jumpBtn');

  function inExpandedRect(e, rect, pad=50) {
    return e.clientX >= rect.left - pad && e.clientX <= rect.right + pad &&
           e.clientY >= rect.top - pad && e.clientY <= rect.bottom + pad;
  }

  let lastMouse = null;
  window.addEventListener('pointerdown', (e) => { lastMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('pointerup', () => { lastMouse = null; });
  window.addEventListener('pointermove', (e) => {
    if (!lastMouse) return;

    const moveRect = moveStickEl.getBoundingClientRect();
    const jumpRect = jumpBtnEl.getBoundingClientRect();
    const overMove = inExpandedRect(e, moveRect, 60); // bigger deadzone
    const overJump = inExpandedRect(e, jumpRect, 60); // bigger deadzone

    if (overMove || overJump) {
      lastMouse = { x: e.clientX, y: e.clientY };
      return; // camera deadzone when interacting near controls
    }

    const dx = (e.clientX - lastMouse.x) / window.innerWidth;
    const dy = (e.clientY - lastMouse.y) / window.innerHeight;
    const jitterDeadzone = 0.02; // slightly larger jitter filter

    if (Math.abs(dx) > jitterDeadzone) camYaw -= dx * camSensitivity;
    if (Math.abs(dy) > jitterDeadzone) {
      camPitch = THREE.MathUtils.clamp(
        camPitch + (cameraMode === 'third' ? dy * (camSensitivity * 0.66) : -dy * (camSensitivity * 0.66)),
        pitchMin, pitchMax
      );
    }
    lastMouse = { x: e.clientX, y: e.clientY };
  });

  // Virtual joystick setup (movement only, larger radius)
  function setupStick(stickId, thumbId, cb) {
    const stick = document.getElementById(stickId);
    const thumb = document.getElementById(thumbId);
    let active = false;
    const rect = () => stick.getBoundingClientRect();
    function setThumb(x, y) {
      const r = 80; // larger stick radius
      const len = Math.hypot(x, y);
      const k = len > r ? r / len : 1;
      const tx = x * k, ty = y * k;
      thumb.style.transform = `translate(${tx}px,${ty}px)`;
      cb(tx / r, ty / r);
    }
    function reset() { thumb.style.transform = `translate(0px,0px)`; cb(0, 0); }
    stick.addEventListener('pointerdown', (e) => {
      active = true; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
      stick.setPointerCapture(e.pointerId);
    });
    stick.addEventListener('pointermove', (e) => {
      if (!active) return; const rc = rect();
      setThumb(e.clientX - (rc.left + rc.width/2), e.clientY - (rc.top + rc.height/2));
    });
    stick.addEventListener('pointerup', () => { active = false; reset(); });
    stick.addEventListener('pointercancel', () => { active = false; reset(); });
  }

  setupStick('moveStick', 'moveThumb', (dx, dy) => { moveDx = -dx; moveDy = -dy; });

  // Jump button
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.addEventListener('pointerdown', () => keys.jump = true);
  jumpBtn.addEventListener('pointerup', () => keys.jump = false);

  // Pause/resume
  function togglePause() {
    paused = !paused;
    pauseOverlay.style.display = paused ? 'flex' : 'none';
  }
  pauseOverlay.addEventListener('click', togglePause);
  pauseBtn.addEventListener('click', togglePause);

  // Prevent touch scrolling on mobile during joystick use
  document.body.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive:false });

  // Toggle first/third person
  toggleViewBtn.addEventListener('click', () => {
    cameraMode = cameraMode === 'third' ? 'first' : 'third';
    player.visible = cameraMode !== 'first'; // hide capsule in first person
  });

  // Open/close main menu
  openMenuBtn.addEventListener('click', () => { mainMenu.style.display = 'block'; });
  closeMenuBtn.addEventListener('click', () => { mainMenu.style.display = 'none'; });
  doubleJumpToggle.addEventListener('change', (e) => { doubleJumpEnabled = e.target.checked; });

  // Owner code via Enter key in input
  codeInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') codeApplyBtn.click();
  });

  // Geometry helpers
  function makePlatform(x, y, z, w, d, alt = false) {
    const geo = new THREE.BoxGeometry(w, 0.6, d);
    const mesh = new THREE.Mesh(geo, alt ? matPlatformAlt : matPlatform);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    // subtle bevel look by scaling edges visually (decor rim)
    const rim = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, 0.05, d+0.2), new THREE.MeshStandardMaterial({ color: 0x1b2a45, roughness: 0.9 }));
    rim.position.set(0, 0.325, 0);
    mesh.add(rim);
    scene.add(mesh);
    platforms.push(mesh);
    return mesh;
  }

  function makeStar(x, y, z) {
    const s = new THREE.Mesh(new THREE.IcosahedronGeometry(0.38, 0), matStar);
    s.position.set(x, y, z);
    s.castShadow = true;
    scene.add(s);
    // glow-ish point light near star
    const pl = new THREE.PointLight(0xffa000, 0.5, 6);
    pl.position.copy(s.position).add(new THREE.Vector3(0,0.2,0));
    scene.add(pl);
    s.userData.light = pl;
    stars.push(s);
    return s;
  }

  function aabbSphereCollision(box, spherePos, sphereR) {
    const bPos = box.position;
    box.geometry.computeBoundingBox();
    const bb = box.geometry.boundingBox;
    const halfX = (bb.max.x - bb.min.x)/2, halfY = (bb.max.y - bb.min.y)/2, halfZ = (bb.max.z - bb.min.z)/2;
    const minX = bPos.x - halfX, minY = bPos.y - halfY, minZ = bPos.z - halfZ;
    const maxX = bPos.x + halfX, maxY = bPos.y + halfY, maxZ = bPos.z + halfZ;
    const cx = Math.max(minX, Math.min(spherePos.x, maxX));
    const cy = Math.max(minY, Math.min(spherePos.y, maxY));
    const cz = Math.max(minZ, Math.min(spherePos.z, maxZ));
    const dx = spherePos.x - cx, dy = spherePos.y - cy, dz = spherePos.z - cz;
    const dist2 = dx*dx + dy*dy + dz*dz;
    if (dist2 <= sphereR*sphereR) return new THREE.Vector3(dx, dy, dz);
    return null;
  }

  // Level management
  let currentLevel = 0;
  levelSelect.value = String(currentLevel);

  function clearLevel() {
    platforms.forEach(m => scene.remove(m));
    stars.forEach(s => { scene.remove(s); if (s.userData.light) scene.remove(s.userData.light); });
    platforms = []; stars = [];
    if (goal) { scene.remove(goal); goal = null; }
  }

  function loadLevel(i) {
    clearLevel();
    currentLevel = i;
    const lvl = LEVELS[i];

    lvl.platforms.forEach(p => makePlatform(p.x, p.y, p.z, p.w, p.d, p.alt));
    lvl.stars.forEach(([x,y,z]) => makeStar(x, y, z));
    goal = new THREE.Mesh(new THREE.TorusGeometry(1.4, 0.28, 16, 64), matGoal);
    goal.position.set(lvl.goal[0], lvl.goal[1], lvl.goal[2]);
    goal.castShadow = true;
    scene.add(goal);

    score = 0;
    player.position.set(lvl.spawn[0], lvl.spawn[1], lvl.spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    canDoubleJump = true;
    msgEl.textContent = 'Collect stars and reach the glowing goal!';
    updateHUD();
  }

  function applyMode(mode) {
    gameMode = mode;
    if (gameMode === 'time') timeLeft = 70.0; // slightly longer for bigger maps
    if (gameMode === 'survival') lives = 3;
    updateHUD();
  }

  levelSelect.addEventListener('change', (e) => loadLevel(parseInt(e.target.value, 10)));
  modeSelect.addEventListener('change', (e) => applyMode(e.target.value));
  restartBtn.addEventListener('click', () => loadLevel(currentLevel));

  // Respawn
  function respawn(penalize = true) {
    const spawn = LEVELS[currentLevel].spawn;
    player.position.set(spawn[0], spawn[1], spawn[2]);
    velocity.set(0,0,0);
    onGround = false;
    canDoubleJump = true;

    if (gameMode === 'survival' && penalize) {
      lives -= 1;
      msgEl.textContent = lives > 0 ? `Oops! Lives left: ${lives}` : 'Game over. Restart or change level.';
      if (lives <= 0) paused = true;
    } else {
      msgEl.textContent = 'Try again! Reach the glowing goal.';
    }
    updateHUD();
  }

  // Ambient particles
  const dustGeo = new THREE.SphereGeometry(0.03, 8, 8);
  const dustMat = new THREE.MeshBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.25 });
  const dusts = [];
  for (let i=0;i<120;i++){
    const d = new THREE.Mesh(dustGeo, dustMat);
    d.position.set((Math.random()-0.5)*90, 2+Math.random()*14, (Math.random()-0.5)*140);
    scene.add(d); dusts.push(d);
  }

  // Init
  loadLevel(0);
  applyMode('classic');

  // Main loop
  const clock = new THREE.Clock();
  let tGoal = 0;

  function animate() {
    requestAnimationFrame(animate);
    if (paused) return;

    const dt = Math.min(0.033, clock.getDelta());

    // Accessories & owner label follow player
    hat.position.set(player.position.x, player.position.y + playerHeight * 0.5 + 0.4, player.position.z);
    trail.position.set(player.position.x, player.position.y + 0.2, player.position.z);
    trail.rotation.y += dt * 2.0;

    if (ownerUnlocked && ownerSprite) {
      ownerSprite.position.set(player.position.x, player.position.y + playerHeight * 0.5 + 1.8, player.position.z);
    }

    // Time attack
    if (gameMode === 'time') {
      timeLeft -= dt;
      if (timeLeft <= 0) {
        timeLeft = 0;
        msgEl.textContent = 'Time up! Restart or switch mode.';
        paused = true;
      }
    }
    updateHUD();

    // Input vector: keyboard + inverted movement joystick
    const ix = (keys.right ? 1 : 0) - (keys.left ? 1 : 0) + moveDx;
    const iz = (keys.down ? 1 : 0) - (keys.up ? 1 : 0) + moveDy;
    const input = new THREE.Vector3(ix, 0, iz);
    if (input.lengthSq() > 1) input.normalize();

    // Camera forward/right
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize();

    // Movement relative to camera
    const moveVec = new THREE.Vector3()
      .addScaledVector(forward, input.z)
      .addScaledVector(right, input.x);

    // Movement params
    const accelMag = onGround ? 17 : 17 * airControl;
    acceleration.set(moveVec.x * accelMag, 0, moveVec.z * accelMag);
    acceleration.add(gravity);
    velocity.addScaledVector(acceleration, dt);

    // Ground friction when idle
    if (onGround && moveVec.lengthSq() < 1e-4) {
      velocity.x = THREE.MathUtils.damp(velocity.x, 0, friction, dt);
      velocity.z = THREE.MathUtils.damp(velocity.z, 0, friction, dt);
    }

    // Jump handling: stronger jump + double jump
    if (keys.jump) {
      if (onGround) {
        velocity.y = 14.5;            // stronger first jump
        onGround = false;
        canDoubleJump = true;         // allow a double jump after leaving ground
        keys.jump = false;
      } else if (doubleJumpEnabled && canDoubleJump) {
        velocity.y = 11.8;            // second jump slightly weaker
        canDoubleJump = false;        // consume double jump
        msgEl.textContent = 'Double jump!';
        keys.jump = false;
      }
    }

    // Integrate
    player.position.addScaledVector(velocity, dt);

    // Collisions
    const wasGrounded = onGround;
    onGround = false;
    for (const box of platforms) {
      const hit = aabbSphereCollision(box, player.position, playerRadius);
      if (hit) {
        const len = Math.hypot(hit.x, hit.y, hit.z) || 1;
        const nx = hit.x / len, ny = hit.y / len, nz = hit.z / len;
        const push = (playerRadius - len);
        player.position.x += nx * push;
        player.position.y += ny * push;
        player.position.z += nz * push;

        if (ny > 0.5) {
          onGround = true;
          if (velocity.y < 0) velocity.y = 0;
        } else {
          velocity.x *= 0.82;
          velocity.z *= 0.82;
        }
      }
    }
    // Reset double jump when we land
    if (!wasGrounded && onGround) {
      canDoubleJump = true;
    }

    // Stars
    for (const s of stars) {
      if (!s.visible) continue;
      const d = s.position.distanceTo(player.position);
      if (d < playerRadius + 0.6) {
        s.visible = false;
        if (s.userData.light) s.userData.light.visible = false;
        score += 1;
        msgEl.textContent = score === stars.length ? 'All stars collected! Head to the goal.' : 'Star collected!';
        updateHUD();
      } else {
        s.rotation.y += dt * 1.6;
      }
    }

    // Goal
    tGoal += dt;
    if (goal) {
      goal.rotation.x = Math.sin(tGoal * 1.2) * 0.2;
      goal.rotation.y += dt * 0.8;
      if (player.position.distanceTo(goal.position) < 1.6) {
        if (score === stars.length) {
          msgEl.textContent = 'Level complete! Loading next...';
          const next = (currentLevel + 1) % LEVELS.length;
          setTimeout(() => { loadLevel(next); }, 900);
        } else {
          msgEl.textContent = 'Collect all stars first!';
        }
      }
    }

    // Void fall
    if (player.position.y < voidY) {
      respawn(gameMode === 'survival');
    }

    // Camera placement (snap, no lag)
    if (cameraMode === 'third') {
      const y = Math.sin(camPitch) * orbitRadius;
      const h = Math.cos(camPitch) * orbitRadius;
      const camX = player.position.x + Math.sin(camYaw) * h;
      const camZ = player.position.z + Math.cos(camYaw) * h;
      const target = new THREE.Vector3(camX, player.position.y + y + 1.6, camZ);
      camera.position.copy(target);
      camera.lookAt(new THREE.Vector3(player.position.x, player.position.y + 0.9, player.position.z));
    } else {
      const head = new THREE.Vector3(player.position.x, player.position.y + playerHeight * 0.5 + 0.5, player.position.z);
      camera.position.copy(head);
      const dir = new THREE.Vector3(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      );
      camera.lookAt(head.clone().add(dir));
    }

    // Ambient particles drift
    for (const d of dusts) {
      d.position.x += Math.sin(tGoal + d.id) * 0.003;
      d.position.y += Math.cos(tGoal + d.id) * 0.002;
    }

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

})();
</script>
</body>
</html>
