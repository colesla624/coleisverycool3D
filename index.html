<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Game Hub — Online, visible player models, skins menu (third person)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; }
    canvas { display:block; }

    /* Top bar, HUD, menu */
    #topbar { position:absolute; top:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; user-select:none; }
    #topbar .small { font-size:12px; opacity:0.85; font-weight:500; }
    #hud { position:absolute; bottom:10px; left:10px; z-index:12; color:#fff; font-weight:700; text-shadow:0 1px 2px #000; display:none; }
    #hud .line { margin-top:6px; font-weight:600; }

    #menu { position:absolute; inset:0; display:grid; place-items:center; z-index:11; }
    #menuPanel { width:920px; max-width:95vw; background:#111a; backdrop-filter: blur(8px); border:1px solid #fff2; border-radius:16px; padding:20px; color:#fff; }
    #menuPanel h1 { margin:0 0 8px; font-size:28px; }
    #menuGrid { display:grid; grid-template-columns:repeat(2, minmax(320px, 1fr)); gap:12px; margin-top:10px; }
    .menuBtn { padding:14px; background:#222a; border:1px solid #fff2; color:#fff; border-radius:12px; cursor:pointer; text-align:left; }
    .menuBtn:hover { background:#2a2f; }
    .row { display:flex; gap:8px; align-items:center; margin-top:12px; }
    .pill { padding:8px 12px; border-radius:999px; background:#fff1; border:1px solid #fff2; cursor:pointer; }

    /* Back button and message */
    #backBtn { position:absolute; top:10px; right:10px; z-index:12; padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; display:none; cursor:pointer; }
    #msg { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:#fff; z-index:12; text-align:center; font-weight:800; font-size:22px; display:none; }
    #msg button { margin-top:12px; background:#ff6a00; border:none; color:#fff; font-weight:800; padding:10px 16px; border-radius:10px; cursor:pointer; }

    /* Settings bar */
    #settingsBar { position:absolute; top:56px; right:10px; z-index:12; display:none; display:flex; gap:8px; }
    .settingsBtn { padding:10px 14px; border-radius:12px; border:1px solid #fff2; background:#111a; color:#fff; cursor:pointer; }

    /* Skins modal */
    #skins { position:absolute; top:18%; left:50%; transform:translateX(-50%); background:#1e1e1e; color:#fff; padding:20px; border-radius:12px; display:none; z-index:13; width:420px; border:1px solid #fff2; }
    #skins h2 { margin:0 0 10px; }
    #skins .grid { display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; }
    .swatch { height:40px; border-radius:10px; border:1px solid #fff3; cursor:pointer; }
    #skins .row { display:flex; gap:8px; align-items:center; margin-top:12px; }
    #closeSkins { margin-top:12px; width:100%; padding:8px; border:none; border-radius:8px; background:#6a6a6a; color:#fff; cursor:pointer; }

    /* Mobile joysticks and buttons */
    #controls { position:absolute; bottom:16px; left:16px; right:16px; z-index:12; display:flex; justify-content:space-between; align-items:flex-end; pointer-events:none; }
    .stick { width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); position:relative; pointer-events:auto; touch-action:none; }
    .knob { position:absolute; width:64px; height:64px; border-radius:50%; background:rgba(255,255,255,0.25); left:calc(50% - 32px); top:calc(50% - 32px); }
    #rightPanel { display:flex; flex-direction:column; align-items:center; gap:12px; pointer-events:auto; }
    .btn { pointer-events:auto; touch-action:none; width:84px; height:84px; border-radius:16px; background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.2); color:#fff; display:grid; place-items:center; font-weight:800; }

    /* Name and server bar */
    #netbar { position:absolute; top:10px; left:50%; transform:translateX(-50%); background:#111a; color:#fff; padding:8px 12px; border-radius:10px; border:1px solid #fff2; z-index:12; display:none; }
    #netbar input { background:#222; border:1px solid #444; color:#fff; border-radius:8px; padding:6px 8px; margin-left:6px; width:160px; }
    #netbar .server { width:240px; }
  </style>
</head>
<body>
  <div id="topbar">
    <div id="title">3D Game Hub — Online, visible players, skins menu</div>
    <div class="small" id="hint">Left stick: move. Right stick: look. Jump/Action buttons. Esc/Back to menu.</div>
  </div>

  <div id="netbar">
    <label>Player name:<input id="playerName" placeholder="Guest" /></label>
    <label>Server:<input id="serverUrl" class="server" placeholder="ws://localhost:8080" /></label>
    <button id="connectBtn">Connect</button>
    <span id="connStatus" style="margin-left:8px; opacity:0.8"></span>
  </div>

  <button id="backBtn">Back to menu</button>

  <div id="menu">
    <div id="menuPanel">
      <h1>Pick a game</h1>
      <div id="menuGrid">
        <button class="menuBtn" data-game="jungle">
          <div style="font-weight:800">Lava Monkey Jungle</div>
          <div class="small">Survive monkeys and rising lava. Coins & medkits. Online ghosts.</div>
        </button>
        <button class="menuBtn" data-game="platformer">
          <div style="font-weight:800">Sky Platforms (Double Jump)</div>
          <div class="small">Jump across floating platforms. Player visible. Online ghosts.</div>
        </button>
        <button class="menuBtn" data-game="racer">
          <div style="font-weight:800">Desert Ridge Racer</div>
          <div class="small">Drive through gates. Online ghosts.</div>
        </button>
        <button class="menuBtn" data-game="arena">
          <div style="font-weight:800">Space Drone Arena</div>
          <div class="small">Shoot drones. Online ghosts.</div>
        </button>
        <button class="menuBtn" data-game="runner">
          <div style="font-weight:800">Forest Endless Runner</div>
          <div class="small">Lane dodging. Online ghosts.</div>
        </button>
        <button class="menuBtn" data-game="maze">
          <div style="font-weight:800">Crystal Maze</div>
          <div class="small">Find the ring. Online ghosts.</div>
        </button>
        <button class="menuBtn" data-game="range">
          <div style="font-weight:800">Target Range</div>
          <div class="small">Pop‑up targets. Online ghosts.</div>
        </button>
      </div>
      <div class="row">
        <div class="pill" id="graphicsLow">Graphics: Low</div>
        <div class="pill" id="graphicsHigh">Graphics: High</div>
        <div class="pill" id="skinsBtn">Player skins</div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div id="hudPrimary">—</div>
    <div class="line" id="hudSecondary"></div>
  </div>

  <!-- Settings controls -->
  <div id="settingsBar" style="display:none">
    <button id="shopBtn" class="settingsBtn">SHOP</button>
  </div>

  <!-- Skins modal -->
  <div id="skins">
    <h2>Choose your player skin</h2>
    <div class="grid">
      <div class="swatch" data-skin="blue" style="background:#4da3ff"></div>
      <div class="swatch" data-skin="red" style="background:#ff4d4d"></div>
      <div class="swatch" data-skin="green" style="background:#43c86b"></div>
      <div class="swatch" data-skin="purple" style="background:#aa66ff"></div>
      <div class="swatch" data-skin="orange" style="background:#ff9a3c"></div>
      <div class="swatch" data-skin="white" style="background:#f0f0f0"></div>
      <div class="swatch" data-skin="black" style="background:#222"></div>
      <div class="swatch" data-skin="yellow" style="background:#ffd84d"></div>
    </div>
    <div class="row">
      <span style="opacity:0.8">Applies to all games and your online presence.</span>
    </div>
    <button id="closeSkins">Close</button>
  </div>

  <!-- Shop (kept minimal; currency varies per game) -->
  <div id="shop" style="display:none">
    <h2 style="margin:0 0 10px">Shop</h2>
    <div class="row"><span>Weapon upgrade</span><button data-cost="10" data-type="weapon">Buy (10)</button></div>
    <div class="row"><span>Map: Night</span><button data-cost="20" data-type="mapNight">Buy (20)</button></div>
    <div class="row"><span>Map: Day</span><button data-cost="0" data-type="mapDay">Use</button></div>
    <button id="closeShop" style="margin-top:12px; width:100%; padding:8px; border:none; border-radius:8px; background:#6a6a6a; color:#fff; cursor:pointer;">Close</button>
  </div>

  <div id="msg">
    <div id="msgText">—</div>
    <button id="restart">Restart</button>
  </div>

  <!-- Mobile controls -->
  <div id="controls" style="display:none">
    <div id="leftStick" class="stick"><div class="knob" id="leftKnob"></div></div>
    <div id="rightPanel">
      <div id="rightStick" class="stick"><div class="knob" id="rightKnob"></div></div>
      <div style="display:flex; gap:12px;">
        <div id="jumpBtn" class="btn">JUMP</div>
        <div id="actionBtn" class="btn">ACTION</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // UI refs
    const menu = document.getElementById('menu');
    const backBtn = document.getElementById('backBtn');
    const hud = document.getElementById('hud');
    const hudPrimary = document.getElementById('hudPrimary');
    const hudSecondary = document.getElementById('hudSecondary');
    const msg = document.getElementById('msg');
    const msgText = document.getElementById('msgText');
    const restartBtn = document.getElementById('restart');
    const graphicsLow = document.getElementById('graphicsLow');
    const graphicsHigh = document.getElementById('graphicsHigh');
    const controls = document.getElementById('controls');
    const jumpBtn = document.getElementById('jumpBtn');
    const actionBtn = document.getElementById('actionBtn');
    const settingsBar = document.getElementById('settingsBar');
    const shopBtn = document.getElementById('shopBtn');
    const shopEl = document.getElementById('shop');
    const closeShopBtn = document.getElementById('closeShop');
    const skinsBtn = document.getElementById('skinsBtn');
    const skinsEl = document.getElementById('skins');
    const closeSkinsBtn = document.getElementById('closeSkins');

    const netbar = document.getElementById('netbar');
    const playerNameInput = document.getElementById('playerName');
    const serverUrlInput = document.getElementById('serverUrl');
    const connectBtn = document.getElementById('connectBtn');
    const connStatus = document.getElementById('connStatus');

    // Joystick setup
    function setupStick(stickId, knobId) {
      const stick = document.getElementById(stickId), knob = document.getElementById(knobId);
      let vec = { x: 0, y: 0 }, active = false;
      function setKnob(x, y) { const r = stick.getBoundingClientRect(); knob.style.left = `${x - r.left - 32}px`; knob.style.top = `${y - r.top - 32}px`; }
      function handle(e, a) {
        const r = stick.getBoundingClientRect(), cx = r.left + r.width / 2, cy = r.top + r.height / 2;
        let x = e.clientX, y = e.clientY; if (e.touches && e.touches[0]) { x = e.touches[0].clientX; y = e.touches[0].clientY; }
        const dx = x - cx, dy = y - cy, len = Math.min(Math.hypot(dx, dy), r.width * 0.45);
        const nx = len ? dx / len : 0, ny = len ? dy / len : 0;
        active = a;
        if (a) { setKnob(cx + nx * len, cy + ny * len); vec = { x: nx * (len / (r.width * 0.45)), y: ny * (len / (r.width * 0.45)) }; }
        else { setKnob(cx, cy); vec = { x: 0, y: 0 }; }
      }
      stick.addEventListener('pointerdown', e => { stick.setPointerCapture(e.pointerId); handle(e, true); });
      stick.addEventListener('pointermove', e => { if (active) handle(e, true); });
      stick.addEventListener('pointerup', e => { stick.releasePointerCapture(e.pointerId); handle(e, false); });
      stick.addEventListener('touchstart', e => handle(e, true), { passive: false });
      stick.addEventListener('touchmove', e => handle(e, true), { passive: false });
      stick.addEventListener('touchend', e => handle(e, false), { passive: false });
      return { get: () => vec };
    }
    const moveStick = setupStick('leftStick', 'leftKnob');
    const lookStick = setupStick('rightStick', 'rightKnob');

    // Prevent iOS pinch/zoom gesture
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    document.addEventListener('gestureend', e => e.preventDefault());

    // Graphics quality toggle
    let quality = 'high';
    graphicsLow.onclick = () => { quality = 'low'; graphicsLow.style.background = '#44aa44'; graphicsHigh.style.background = '#fff1'; };
    graphicsHigh.onclick = () => { quality = 'high'; graphicsHigh.style.background = '#44aa44'; graphicsLow.style.background = '#fff1'; };
    graphicsHigh.click();

    // Hub state
    let scene = null, camera = null, cleanup = null, running = false;
    let keys = {};
    window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Escape') showMenu(); });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // Shared state
    const shared = {
      skin: localStorage.getItem('skin') || 'blue',
      name: localStorage.getItem('name') || '',
      server: localStorage.getItem('server') || 'ws://localhost:8080',
      ws: null,
      id: Math.random().toString(36).slice(2),
      peers: new Map(), // id -> {mesh, lastSeen, data}
      currentGame: null
    };

    playerNameInput.value = shared.name;
    serverUrlInput.value = shared.server;
    netbar.style.display = 'block';

    function skinToColor(skin) {
      switch (skin) {
        case 'red': return 0xff4d4d;
        case 'green': return 0x43c86b;
        case 'purple': return 0xaa66ff;
        case 'orange': return 0xff9a3c;
        case 'white': return 0xf0f0f0;
        case 'black': return 0x222222;
        case 'yellow': return 0xffd84d;
        default: return 0x4da3ff; // blue
      }
    }

    // Skins modal
    skinsBtn.onclick = () => { skinsEl.style.display = 'block'; };
    closeSkinsBtn.onclick = () => { skinsEl.style.display = 'none'; };
    skinsEl.addEventListener('click', (e) => {
      if (e.target.classList.contains('swatch')) {
        shared.skin = e.target.dataset.skin;
        localStorage.setItem('skin', shared.skin);
        if (cleanup && cleanup.applySkin) cleanup.applySkin(shared.skin);
        broadcastState(); // update peers with new skin
      }
    });

    // Networking (simple WebSocket presence and position sync)
    connectBtn.onclick = () => {
      const name = playerNameInput.value.trim();
      const server = serverUrlInput.value.trim();
      shared.name = name || 'Guest';
      shared.server = server || 'ws://localhost:8080';
      localStorage.setItem('name', shared.name);
      localStorage.setItem('server', shared.server);
      connectWS();
    };

    function connectWS() {
      try {
        if (shared.ws) { shared.ws.close(); shared.ws = null; }
        const ws = new WebSocket(shared.server);
        shared.ws = ws;
        connStatus.textContent = 'Connecting...';
        ws.onopen = () => { connStatus.textContent = 'Connected'; broadcastState(true); };
        ws.onmessage = (evt) => {
          try {
            const msg = JSON.parse(evt.data);
            handleNetMessage(msg);
          } catch {}
        };
        ws.onclose = () => { connStatus.textContent = 'Disconnected'; };
        ws.onerror = () => { connStatus.textContent = 'Error'; };
      } catch {
        connStatus.textContent = 'Error';
      }
    }

    function handleNetMessage(msg) {
      // Expect messages: {type:'state', id, name, skin, game, x,y,z, yaw, t}
      if (msg.type === 'state' && msg.id && msg.id !== shared.id) {
        // Only display peers in the same game
        if (msg.game !== shared.currentGame) return;
        let peer = shared.peers.get(msg.id);
        if (!peer) {
          const mesh = createPeerMesh(msg.game, msg.skin);
          scene && scene.add(mesh);
          peer = { mesh, lastSeen: performance.now(), data: msg };
          shared.peers.set(msg.id, peer);
        }
        peer.lastSeen = performance.now();
        peer.data = msg;
        peer.mesh.position.set(msg.x, msg.y, msg.z);
        setPeerYaw(peer.mesh, msg.yaw);
        setPeerSkin(peer.mesh, msg.skin);
      }
    }

    function createPeerMesh(game, skin) {
      const color = skinToColor(skin);
      let mesh;
      if (game === 'racer') {
        mesh = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 5), new THREE.MeshStandardMaterial({ color }));
      } else {
        mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), new THREE.MeshStandardMaterial({ color }));
      }
      mesh.userData.isPeer = true;
      return mesh;
    }
    function setPeerYaw(mesh, yaw) {
      mesh.rotation.y = yaw || 0;
    }
    function setPeerSkin(mesh, skin) {
      const color = skinToColor(skin);
      if (mesh.material && mesh.material.color) mesh.material.color.setHex(color);
    }
    function broadcastState(initial=false) {
      if (!shared.ws || shared.ws.readyState !== 1 || !cleanup) return;
      const p = cleanup.getLocalState ? cleanup.getLocalState() : null;
      if (!p) return;
      const msg = {
        type: 'state',
        id: shared.id,
        name: shared.name || 'Guest',
        skin: shared.skin,
        game: shared.currentGame || '',
        x: p.pos.x, y: p.pos.y, z: p.pos.z,
        yaw: p.yaw || 0,
        t: Date.now(),
        initial
      };
      try { shared.ws.send(JSON.stringify(msg)); } catch {}
    }

    // Clean old peers periodically
    setInterval(() => {
      const now = performance.now();
      for (const [id, peer] of shared.peers) {
        if (now - peer.lastSeen > 8000) {
          if (scene) scene.remove(peer.mesh);
          shared.peers.delete(id);
        }
      }
    }, 4000);

    // Shop minimal behavior
    shopBtn.onclick = () => { shopEl.style.display = 'block'; };
    closeShopBtn.onclick = () => { shopEl.style.display = 'none'; };
    shopEl.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON' || e.target.id === 'closeShop') return;
      const cost = parseInt(e.target.dataset.cost || '0', 10);
      if (cleanup && cleanup.getCurrency && cleanup.setCurrency) {
        const coins = cleanup.getCurrency();
        if (cost > coins) { alert('Not enough currency'); return; }
        if (cost > 0) cleanup.setCurrency(coins - cost);
      }
      const type = e.target.dataset.type;
      if (type === 'weapon' && cleanup.applyWeaponUpgrade) cleanup.applyWeaponUpgrade();
      if (type === 'mapNight' && cleanup.applyMapVariant) cleanup.applyMapVariant('night');
      if (type === 'mapDay' && cleanup.applyMapVariant) cleanup.applyMapVariant('day');
    });

    // Show/hide
    function showMenu() {
      running = false;
      hud.style.display = 'none';
      settingsBar.style.display = 'none';
      controls.style.display = 'none';
      msg.style.display = 'none';
      shopEl.style.display = 'none';
      skinsEl.style.display = 'none';
      menu.style.display = 'grid';
      if (cleanup && cleanup.dispose) cleanup.dispose();
      // Remove peer meshes from scene
      if (scene) {
        for (const [, peer] of shared.peers) scene.remove(peer.mesh);
      }
      shared.peers.clear();
      cleanup = null; scene = null; camera = null;
      netbar.style.display = 'block';
    }
    function startGame(setup, gameKey) {
      if (cleanup && cleanup.dispose) cleanup.dispose();
      cleanup = setup(quality, shared.skin);
      scene = cleanup.scene; camera = cleanup.camera;
      shared.currentGame = gameKey;
      running = true;
      hud.style.display = 'block';
      backBtn.style.display = 'inline-block';
      controls.style.display = 'flex';
      settingsBar.style.display = 'flex';
      netbar.style.display = 'block';
      menu.style.display = 'none';
      // Apply current skin to local model
      if (cleanup.applySkin) cleanup.applySkin(shared.skin);
      // Inform server of new presence
      broadcastState(true);
    }

    document.querySelectorAll('.menuBtn').forEach(btn => {
      btn.addEventListener('click', () => {
        const game = btn.dataset.game;
        switch (game) {
          case 'jungle': startGame(setupJungleTP, 'jungle'); break;
          case 'platformer': startGame(setupPlatformerTP, 'platformer'); break;
          case 'racer': startGame(setupRacerTP, 'racer'); break;
          case 'arena': startGame(setupArenaTP, 'arena'); break;
          case 'runner': startGame(setupRunnerTP, 'runner'); break;
          case 'maze': startGame(setupMazeTP, 'maze'); break;
          case 'range': startGame(setupRangeTP, 'range'); break;
        }
      });
    });

    // Lights
    function makeLights(env) {
      const group = new THREE.Group();
      if (env === 'day') {
        const hemi = new THREE.HemisphereLight(0xffffff, 0x228822, 1.0);
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(20, 40, 10);
        group.add(hemi, sun);
      } else if (env === 'space') {
        const amb = new THREE.AmbientLight(0x8888aa, 0.9);
        const key = new THREE.DirectionalLight(0xffffff, 0.7);
        key.position.set(15, 25, -10);
        group.add(amb, key);
      } else if (env === 'maze') {
        const amb = new THREE.AmbientLight(0x6666ff, 0.6);
        const key = new THREE.PointLight(0x88aaff, 1.0, 200);
        key.position.set(0, 20, 0);
        group.add(amb, key);
      }
      return group;
    }

    // Camera helpers (third person only; yaw/pitch applied to camera placement)
    function updateThirdPersonCamera(cam, playerPos, yaw, pitch=0, dist=6.0, height=2.5) {
      // Rotate around player on yaw, add slight pitch height bias
      const h = height + Math.sin(pitch) * 0.5;
      const offset = new THREE.Vector3(Math.sin(yaw) * dist, h, -Math.cos(yaw) * dist);
      cam.position.copy(playerPos).add(offset);
      cam.lookAt(playerPos.x, playerPos.y + 1.0, playerPos.z);
    }

    // Camera-forward XZ basis for movement
    function getCameraBasisXZ(cam, center) {
      const forward = new THREE.Vector3().subVectors(center, cam.position);
      forward.y = 0;
      if (forward.lengthSq() < 1e-6) forward.set(0,0,-1);
      forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
      return { forward, right };
    }

    // Shared input helpers
    function getLookDelta(mult=1.8) {
      const ls = lookStick.get();
      return { lx: ls.x * mult, ly: ls.y * mult };
    }
    function getMoveInput(keys, mv) {
      let inputX = mv.x, inputY = -mv.y;
      const kForward = (keys.KeyW || keys.ArrowUp) ? 1 : 0;
      const kBack = (keys.KeyS || keys.ArrowDown) ? 1 : 0;
      const kLeft = (keys.KeyA || keys.ArrowLeft) ? 1 : 0;
      const kRight = (keys.KeyD || keys.ArrowRight) ? 1 : 0;
      inputX += (kRight - kLeft);
      inputY += (kForward - kBack);
      const mag = Math.hypot(inputX, inputY);
      if (mag > 1) { inputX /= mag; inputY /= mag; }
      return { inputX, inputY };
    }

    // GAME 1: Lava Monkey Jungle (visible player)
    function setupJungleTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(140, 140), new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.9 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      function addTree(x, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 2.2, 10), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
        trunk.position.set(x, 1.1, z);
        const foliage = new THREE.Mesh(new THREE.SphereGeometry(1.3, 18, 18), new THREE.MeshStandardMaterial({ color: 0x006400 }));
        foliage.position.set(x, 2.6, z);
        sc.add(trunk, foliage);
      }
      for (let i = 0; i < (quality === 'high' ? 28 : 16); i++) {
        const a = Math.random() * Math.PI * 2, d = 12 + Math.random() * 55;
        addTree(Math.cos(a) * d, Math.sin(a) * d);
      }

      const playerRadius = 0.5;
      const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.6, 8, 16), playerMat);
      player.position.set(0, playerRadius + 0.3, 0); sc.add(player);

      const weaponMat = new THREE.MeshStandardMaterial({ color: 0x885000 });
      const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.12), weaponMat);
      weapon.position.set(0.45, 0.35, 0.0); player.add(weapon);

      const lava = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 0.3, 48, 1, true),
        new THREE.MeshStandardMaterial({ color: 0xff3c00, emissive: 0xff2200, emissiveIntensity: 0.95 }));
      lava.position.y = -2.5; sc.add(lava);

      const enemies = [];
      function createMonkey() {
        const g = new THREE.Group();
        const m = new THREE.MeshStandardMaterial({ color: 0x7a4b2a });
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), m);
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), m); head.position.set(0, 0.52, 0.02);
        const earL = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), m); earL.position.set(-0.22, 0.58, 0.02);
        const earR = earL.clone(); earR.position.x = 0.22;
        g.add(body, head, earL, earR); return g;
      }
      function spawnEnemy() {
        const e = createMonkey();
        const a = Math.random() * Math.PI * 2, d = 16 + Math.random() * 14;
        e.position.set(Math.cos(a) * d, 0.45, Math.sin(a) * d);
        e.userData.speed = 5.9 + Math.random() * 0.8;
        enemies.push(e); sc.add(e);
      }
      let run = true;
      let spawnTimer = setInterval(() => { if (run) spawnEnemy(); }, 1000);

      const coins = [], medkits = []; let coinCount = 0;
      function coin() {
        const c = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 24), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
        c.rotation.x = Math.PI / 2;
        c.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110);
        coins.push(c); sc.add(c);
      }
      function medkit() {
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.5), new THREE.MeshStandardMaterial({ color: 0xFF0000 }));
        m.position.set((Math.random() - 0.5) * 110, 0.15, (Math.random() - 0.5) * 110);
        medkits.push(m); sc.add(m);
      }
      for (let i = 0; i < (quality === 'high' ? 14 : 8); i++) coin();
      for (let i = 0; i < (quality === 'high' ? 6 : 3); i++) medkit();

      let health = 100, start = performance.now();
      const velocity = new THREE.Vector3();
      const accelGround = 16, accelAir = 6, friction = 12, maxSpeed = 7.2, gravity = 18, jumpStrength = 14.5;
      let onGround = true;
      let yaw = 0, pitch = 0;

      hudPrimary.textContent = 'Jungle — Survive';
      hudSecondary.textContent = 'Health 100 | Coins 0';

      let attacking = false, attackStart = 0;
      let attackDuration = 200;
      let attackRange = 1.4;
      const attackArcCos = Math.cos(Math.PI / 3);

      function startAttack() {
        if (attacking || !run) return;
        attacking = true; attackStart = performance.now();
        weapon.rotation.z = -Math.PI * 0.35;
        const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
        const p = player.position.clone();
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const to = new THREE.Vector3().subVectors(e.position, p);
          const dist = to.length(); if (dist > attackRange) continue;
          to.normalize(); const dot = to.dot(forward);
          if (dot >= attackArcCos) { sc.remove(e); enemies.splice(i, 1); }
        }
        setTimeout(() => { attacking = false; weapon.rotation.z = 0; }, attackDuration);
      }
      actionBtn.onclick = startAttack;
      jumpBtn.onclick = () => { if (onGround && run) velocity.y = jumpStrength; };
      window.addEventListener('keydown', e => { if (e.code === 'Space' && onGround && run) velocity.y = jumpStrength; if (e.code === 'KeyF') startAttack(); });

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x0a1020);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x1c3a1c);
        } else {
          sc.background = new THREE.Color(0x87ceeb);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0x228B22);
        }
      }
      applyMapVariant('day');

      function applySkin(newSkin) { playerMat.color.setHex(skinToColor(newSkin)); }

      function restart() {
        health = 100; coinCount = 0; start = performance.now();
        velocity.set(0, 0, 0); player.position.set(0, playerRadius + 0.3, 0);
        yaw = 0; pitch = 0; lava.position.y = -2.5;
        enemies.forEach(e => sc.remove(e)); enemies.length = 0;
        coins.forEach(c => sc.remove(c)); coins.length = 0;
        medkits.forEach(m => sc.remove(m)); medkits.length = 0;
        for (let i = 0; i < (quality === 'high' ? 14 : 8); i++) coin();
        for (let i = 0; i < (quality === 'high' ? 6 : 3); i++) medkit();
        run = true; msg.style.display = 'none';
        hudSecondary.textContent = 'Health 100 | Coins 0';
      }
      function dispose() { clearInterval(spawnTimer); }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose,
        getCurrency: () => coinCount,
        setCurrency: v => { coinCount = v; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => { attackRange = 1.8; weapon.scale.set(1.1, 1.3, 1.1); weaponMat.color.set(0x553300); },
        getLocalState: () => ({ pos: player.position, yaw }),
        update(dt, now) {
          if (!run) return;

          // Look (yaw/pitch for camera)
          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);

          // Camera placement (third person)
          updateThirdPersonCamera(cam, player.position, yaw, pitch, 7.0, 2.6);

          // Movement (camera-forward basis)
          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, player.position);
          const wishdir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (wishdir.lengthSq() > 0) wishdir.normalize();

          const accel = onGround ? accelGround : accelAir;
          velocity.addScaledVector(wishdir, accel * dt);

          // Friction
          if (onGround && Math.hypot(inputX, inputY) < 0.05) {
            const horiz = new THREE.Vector2(velocity.x, velocity.z);
            const speed = horiz.length();
            const drop = friction * dt;
            const newSpeed = Math.max(speed - drop, 0);
            if (speed > 0) {
              horiz.multiplyScalar(newSpeed / speed);
              velocity.x = horiz.x; velocity.z = horiz.y;
            }
          }

          // Cap speed
          {
            const horiz = new THREE.Vector2(velocity.x, velocity.z);
            const speed = horiz.length();
            if (speed > maxSpeed) {
              horiz.multiplyScalar(maxSpeed / speed);
              velocity.x = horiz.x; velocity.z = horiz.y;
            }
          }

          // Gravity/integration
          velocity.y -= gravity * dt;
          player.position.addScaledVector(velocity, dt);

          // Ground
          const groundY = playerRadius + 0.3;
          if (player.position.y < groundY) { player.position.y = groundY; velocity.y = 0; onGround = true; }
          else onGround = false;

          // Weapon anim
          if (!attacking) {
            weapon.rotation.x = Math.sin(now * 0.004) * 0.08;
            weapon.rotation.z = 0;
          } else {
            const t = Math.min((performance.now() - attackStart) / attackDuration, 1);
            weapon.rotation.x = -0.2;
            weapon.rotation.z = -Math.PI * 0.35 + Math.sin(t * Math.PI) * 0.5;
          }

          // Lava rise
          lava.position.y += 0.018 * dt;

          // Enemies behavior
          const bob = Math.sin(now * 0.004) * 0.02;
          for (let i = 0; i < enemies.length; i++) {
            const e = enemies[i];
            e.position.y = 0.45 + bob;
            const toP = new THREE.Vector3().subVectors(player.position, e.position);
            const d = toP.length();
            if (d > 0.0001) toP.normalize();
            e.position.addScaledVector(toP, e.userData.speed * dt);

            for (let j = i + 1; j < enemies.length; j++) {
              const f = enemies[j];
              const sep = new THREE.Vector3().subVectors(e.position, f.position);
              const sl = sep.length();
              if (sl > 0 && sl < 0.9) {
                sep.normalize();
                e.position.addScaledVector(sep, (0.9 - sl) * 0.15);
                f.position.addScaledVector(sep.multiplyScalar(-1), (0.9 - sl) * 0.15);
              }
            }

            if (d < 0.85) { health -= 18 * dt; if (health < 0) health = 0; }
          }

          // Collectibles
          for (let i = coins.length - 1; i >= 0; i--) {
            const c = coins[i];
            if (c.position.distanceTo(player.position) < 0.8) {
              coinCount += 1; hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;
              sc.remove(c); coins.splice(i, 1);
            }
          }
          for (let i = medkits.length - 1; i >= 0; i--) {
            const m = medkits[i];
            if (m.position.distanceTo(player.position) < 0.9) {
              health = Math.min(100, health + 25);
              hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;
              sc.remove(m); medkits.splice(i, 1);
            }
          }

          // Lose
          const feet = player.position.y - groundY;
          const lavaTop = lava.position.y + 0.15;
          if (feet <= lavaTop || health <= 0) {
            run = false; msgText.textContent = 'Game Over — Jungle'; msg.style.display = 'block';
          }

          // HUD
          hudPrimary.textContent = `Jungle — ${((performance.now() - start) / 1000).toFixed(1)}s`;
          hudSecondary.textContent = `Health ${Math.round(health)} | Coins ${coinCount}`;

          // Networking: broadcast local state
          broadcastState();
        }
      };
    }

    // GAME 2: Platformer (double jump, player visible)
    function setupPlatformerTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87b3ff);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const platMat = new THREE.MeshStandardMaterial({ color: 0x6aa86a, roughness: 0.8 });
      const plats = [];
      function platform(w, h, d, x, y, z) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), platMat);
        p.position.set(x, y, z); sc.add(p); plats.push(p);
      }
      const baseY = 0;
      platform(40, 2, 12, 0, baseY, 0);
      platform(12, 2, 12, 28, baseY + 8, -6);
      platform(16, 2, 12, 48, baseY + 16, 8);
      platform(10, 2, 10, 66, baseY + 24, 0);
      platform(14, 2, 12, 86, baseY + 30, -10);
      platform(20, 2, 12, 110, baseY + 34, 6);

      const goal = new THREE.Mesh(new THREE.TorusKnotGeometry(3, 1, 90, 12), new THREE.MeshStandardMaterial({ color: 0xffd54f, emissive: 0x553300, emissiveIntensity: 0.3 }));
      goal.position.set(120, baseY + 40, 6); sc.add(goal);

      const playerRadius = 0.6;
      const playerMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const player = new THREE.Mesh(new THREE.CapsuleGeometry(playerRadius, 0.8, 8, 12), playerMat);
      player.visible = true; player.position.set(-16, baseY + 6, 0); sc.add(player);

      const vel = new THREE.Vector3(0, 0, 0);
      const gravity = 18, moveSpeed = 10, jumpVel = 16.5;
      let onGround = false, run = true, won = false;
      let yaw = 0, pitch = 0;
      let jumpsLeft = 2; // double jump

      hudPrimary.textContent = 'Sky Platforms';
      hudSecondary.textContent = 'Reach the glowing goal (Double jump)';

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x0a2030);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          platMat.color.set(0x355a35);
        } else {
          sc.background = new THREE.Color(0x87b3ff);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          platMat.color.set(0x6aa86a);
        }
      }
      applyMapVariant('day');
      function applySkin(newSkin) { playerMat.color.setHex(skinToColor(newSkin)); }

      function tryJump() {
        if (!run) return;
        if (onGround) { vel.y = jumpVel; jumpsLeft = 1; onGround = false; }
        else if (jumpsLeft > 0) { vel.y = jumpVel * 0.95; jumpsLeft = 0; }
      }
      jumpBtn.onclick = tryJump;
      window.addEventListener('keydown', e => { if (e.code === 'Space') tryJump(); });

      function collide() {
        onGround = false;
        for (const p of plats) {
          const top = p.position.y + p.geometry.parameters.height / 2;
          const halfW = p.geometry.parameters.width / 2;
          const halfD = p.geometry.parameters.depth / 2;
          const withinX = (player.position.x > p.position.x - halfW - playerRadius) && (player.position.x < p.position.x + halfW + playerRadius);
          const withinZ = (player.position.z > p.position.z - halfD - playerRadius) && (player.position.z < p.position.z + halfD + playerRadius);
          const nearTop = Math.abs(player.position.y - (top + playerRadius)) < 0.6 && vel.y <= 0;
          if (withinX && withinZ && nearTop) {
            player.position.y = top + playerRadius;
            vel.y = 0;
            onGround = true;
            jumpsLeft = 2; // reset double jump on land
          }
        }
        if (player.position.y < -30) { run = false; msgText.textContent = 'You fell — Platformer'; msg.style.display = 'block'; }
      }

      function restart() {
        player.position.set(-16, baseY + 6, 0);
        vel.set(0, 0, 0);
        yaw = 0; pitch = 0;
        won = false; run = true; msg.style.display = 'none';
        jumpsLeft = 2;
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => 0,
        setCurrency: () => {},
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: player.position, yaw }),
        update(dt) {
          if (!run || won) return;

          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);

          updateThirdPersonCamera(cam, player.position, yaw, pitch, 7.0, 2.6);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, player.position);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (dir.lengthSq() > 0) dir.normalize();

          vel.x = THREE.MathUtils.lerp(vel.x, dir.x * moveSpeed, 8 * dt);
          vel.z = THREE.MathUtils.lerp(vel.z, dir.z * moveSpeed, 8 * dt);
          vel.y -= gravity * dt;

          player.position.addScaledVector(vel, dt);
          collide();

          if (player.position.distanceTo(goal.position) < 5) {
            won = true; msgText.textContent = 'Goal reached! — Platformer'; msg.style.display = 'block';
          }

          hudPrimary.textContent = 'Sky Platforms';
          hudSecondary.textContent = onGround ? 'On platform (Double jump ready)' : (jumpsLeft > 0 ? 'Air (Double jump available)' : 'Air');

          broadcastState();
        }
      };
    }

    // GAME 3: Racer (car visible)
    function setupRacerTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0xd0b38a);
      const cam = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1200);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshStandardMaterial({ color: 0xb5894a, roughness: 0.8 }));
      ground.rotation.x = -Math.PI / 2; sc.add(ground);

      const carMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const car = new THREE.Mesh(new THREE.BoxGeometry(2.6, 1.2, 5), carMat);
      car.position.set(0, 0.6, 0); sc.add(car);

      const gates = [];
      function gate(x, z) {
        const g = new THREE.Mesh(new THREE.TorusGeometry(4, 0.3, 12, 24), new THREE.MeshStandardMaterial({ color: 0xffee88 }));
        g.position.set(x, 2.5, z);
        sc.add(g); gates.push(g);
      }
      for (let i = 0; i < 12; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);

      let speed = 0, heading = 0, score = 0, run = true;
      let yaw = 0, pitch = 0;

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x302018);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x8b6a3a);
        } else {
          sc.background = new THREE.Color(0xd0b38a);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0xb5894a);
        }
      }
      applyMapVariant('day');
      function applySkin(newSkin) { carMat.color.setHex(skinToColor(newSkin)); }

      function restart() {
        car.position.set(0, 0.6, 0);
        speed = 0; heading = 0; score = 0; run = true; msg.style.display = 'none';
        gates.forEach(g => sc.remove(g)); gates.length = 0;
        for (let i = 0; i < 12; i++) gate(0 + i * 28, -40 + Math.sin(i * 0.8) * 60);
        hudSecondary.textContent = 'Gates 0/12';
      }

      hudPrimary.textContent = 'Desert Racer';
      hudSecondary.textContent = 'Gates 0/12';

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => score,
        setCurrency: v => { score = v; hudSecondary.textContent = `Gates ${score}/12`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: car.position, yaw: heading }),
        update(dt) {
          if (!run) return;

          const { lx, ly } = getLookDelta(0.8);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.5, 0.5);

          const mv = moveStick.get();
          const steer = mv.x;
          const throttle = Math.max(0, -mv.y);
          const brake = Math.max(0, mv.y);

          speed += ((throttle * 22) - (brake * 28) - speed * 0.85) * dt;
          heading += steer * 1.8 * dt;

          const dir = new THREE.Vector3(Math.sin(heading), 0, Math.cos(heading));
          car.position.addScaledVector(dir, speed * dt);
          car.rotation.y = heading;

          updateThirdPersonCamera(cam, car.position, heading, pitch, 9.0, 3.2);

          for (let i = gates.length - 1; i >= 0; i--) {
            const g = gates[i];
            if (car.position.distanceTo(g.position) < 4) {
              score++; sc.remove(g); gates.splice(i, 1);
              hudSecondary.textContent = `Gates ${score}/12`;
            }
          }

          if (gates.length === 0) { run = false; msgText.textContent = 'Finish! — Racer'; msg.style.display = 'block'; }
          hudPrimary.textContent = `Speed ${speed.toFixed(1)}`;

          broadcastState();
        }
      };
    }

    // GAME 4: Space Drone Arena (rig visible)
    function setupArenaTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x080a12);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('space'); sc.add(lights);

      const arena = new THREE.Mesh(new THREE.CylinderGeometry(80, 80, 2, 40), new THREE.MeshStandardMaterial({ color: 0x1c2233, metalness: 0.2, roughness: 0.7 }));
      arena.position.y = -2; sc.add(arena);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(0, 1, 0); sc.add(rig);

      const drones = [];
      function drone() {
        const d = new THREE.Mesh(new THREE.TetrahedronGeometry(1.2), new THREE.MeshStandardMaterial({ color: 0xff6666 }));
        const a = Math.random() * Math.PI * 2, r = 40;
        d.position.set(Math.cos(a) * r, 1.2, Math.sin(a) * r);
        d.userData.vel = new THREE.Vector3((Math.random() - 0.5) * 4, 0, (Math.random() - 0.5) * 4);
        sc.add(d); drones.push(d);
      }
      for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) drone();

      const bullets = [];
      const bulletSpeed = 40;
      function shoot() {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444400 }));
        const dir = new THREE.Vector3().subVectors(new THREE.Vector3().copy(rig.position), cam.position);
        dir.y = 0;
        if (dir.lengthSq() < 1e-6) dir.set(0,0,-1);
        dir.normalize();
        b.position.copy(cam.position);
        b.userData.dir = dir.clone();
        sc.add(b); bullets.push(b);
      }
      actionBtn.onclick = shoot;

      let run = true, score = 0, yaw = 0, pitch = 0;

      hudPrimary.textContent = 'Space Arena';
      hudSecondary.textContent = 'Score 0 | ACTION to shoot';

      function applyMapVariant(variant) { sc.background = (variant === 'night') ? new THREE.Color(0x04060c) : new THREE.Color(0x080a12); }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }

      function restart() {
        drones.forEach(d => sc.remove(d)); drones.length = 0;
        bullets.forEach(b => sc.remove(b)); bullets.length = 0;
        for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) drone();
        score = 0; hudSecondary.textContent = 'Score 0 | ACTION to shoot';
        rig.position.set(0, 1, 0); yaw = 0; pitch = 0; run = true; msg.style.display = 'none';
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => score,
        setCurrency: v => { score = v; hudSecondary.textContent = `Score ${score} | ACTION to shoot`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;

          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);

          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, rig.position);
          const dir = new THREE.Vector3().addScaledVector(right, inputX).addScaledVector(forward, inputY);
          if (dir.lengthSq() > 0) dir.normalize();
          rig.position.addScaledVector(dir, 10 * dt);

          for (const d of drones) {
            d.position.addScaledVector(d.userData.vel, dt);
            if (d.position.length() > 78) d.userData.vel.multiplyScalar(-1);
          }

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.addScaledVector(b.userData.dir, bulletSpeed * dt);
            if (b.position.length() > 120) { sc.remove(b); bullets.splice(i, 1); continue; }
            for (let j = drones.length - 1; j >= 0; j--) {
              const d = drones[j];
              if (b.position.distanceTo(d.position) < 1.4) {
                sc.remove(d); drones.splice(j, 1);
                sc.remove(b); bullets.splice(i, 1);
                score++; hudSecondary.textContent = `Score ${score} | ACTION to shoot`;
                break;
              }
            }
          }

          if (drones.length === 0) { run = false; msgText.textContent = 'All drones cleared! — Arena'; msg.style.display = 'block'; }

          broadcastState();
        }
      };
    }

    // GAME 5: Runner (rig visible)
    function setupRunnerTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x87ceeb);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 60), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
      ground.rotation.x = -Math.PI / 2; ground.position.z = -40; sc.add(ground);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(0, 1, 0); sc.add(rig);

      const obstacles = [];
      function makeObs(z) {
        const o = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x884444 }));
        o.position.set((Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2, 0.6, -z);
        sc.add(o); obstacles.push(o);
      }
      for (let i = 0; i < (quality === 'high' ? 30 : 18); i++) makeObs(6 + i * 6);

      let laneX = 0, speed = 8, time = 0, run = true, rings = 0;
      let yaw = 0, pitch = 0;

      function applyMapVariant(variant) {
        const hemi = lights.children.find(l => l.isHemisphereLight);
        const sun = lights.children.find(l => l.isDirectionalLight);
        if (variant === 'night') {
          sc.background = new THREE.Color(0x102020);
          if (hemi) hemi.color.set(0xaaccff);
          if (sun) { sun.color.set(0x88aaff); sun.intensity = 0.8; }
          ground.material.color.set(0x1c3a1c);
        } else {
          sc.background = new THREE.Color(0x87ceeb);
          if (hemi) hemi.color.set(0xffffff);
          if (sun) { sun.color.set(0xffffff); sun.intensity = 1.5; }
          ground.material.color.set(0x228B22);
        }
      }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }

      hudPrimary.textContent = 'Endless Runner';
      hudSecondary.textContent = 'Rings 0';

      return {
        scene: sc,
        camera: cam,
        restart() {
          obstacles.forEach(o => sc.remove(o)); obstacles.length = 0;
          for (let i = 0; i < (quality === 'high' ? 30 : 18); i++) makeObs(6 + i * 6);
          laneX = 0; speed = 8; time = 0; rings = 0; run = true; msg.style.display = 'none';
          rig.position.set(0, 1, 0);
          hudSecondary.textContent = 'Rings 0';
        },
        dispose() {},
        getCurrency: () => rings,
        setCurrency: v => { rings = v; hudSecondary.textContent = `Rings ${rings}`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;
          time += dt;
          speed = 8 + time * 1.2;

          const { lx, ly } = getLookDelta(1.5);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.4, 0.4);

          const mv = moveStick.get();
          if (mv.x < -0.3) laneX = -2;
          else if (mv.x > 0.3) laneX = 2;
          else laneX = 0;

          rig.position.x = THREE.MathUtils.lerp(rig.position.x, laneX, 6 * dt);

          for (const o of obstacles) {
            o.position.z += speed * dt;
            if (o.position.z > 4) {
              o.position.z = -180 - Math.random() * 40;
              o.position.x = (Math.random() < 0.5 ? -2 : 2) + (Math.random() - 0.5) * 2;
              rings++; hudSecondary.textContent = `Rings ${rings}`;
            }
            const dist = new THREE.Vector3(o.position.x - rig.position.x, 0, o.position.z).length();
            if (dist < 1.0) { run = false; msgText.textContent = 'You hit an obstacle — Runner'; msg.style.display = 'block'; }
          }

          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);
          hudPrimary.textContent = `Speed ${speed.toFixed(1)}`;

          broadcastState();
        }
      };
    }

    // GAME 6: Crystal Maze (rig visible)
    function setupMazeTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x101424);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('maze'); sc.add(lights);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(160, 160), new THREE.MeshStandardMaterial({ color: 0x222a44, roughness: 0.9 }));
      floor.rotation.x = -Math.PI / 2; sc.add(floor);

      const walls = [];
      function wall(x, y, z, sx, sy, sz) {
        const w = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), new THREE.MeshStandardMaterial({ color: 0x3a64a6, emissive: 0x0a1530, emissiveIntensity: 0.2 }));
        w.position.set(x, y, z); sc.add(w); walls.push(w);
      }
      for (let i = -70; i <= 70; i += 20) { wall(i, 1.5, -70, 20, 3, 2); wall(i, 1.5, 70, 20, 3, 2); }
      for (let j = -70; j <= 70; j += 20) { wall(-70, 1.5, j, 2, 3, 20); wall(70, 1.5, j, 2, 3, 20); }
      for (let k = 0; k < 16; k++) {
        const wx = -50 + Math.floor(Math.random() * 6) * 20;
        const wz = -50 + Math.floor(Math.random() * 6) * 20;
        if (Math.random() < 0.5) wall(wx, 1.5, wz, 20, 3, 2);
        else wall(wx, 1.5, wz, 2, 3, 20);
      }

      const exit = new THREE.Mesh(new THREE.TorusGeometry(3, 0.3, 12, 32), new THREE.MeshStandardMaterial({ color: 0x88ffcc }));
      exit.position.set(60, 2.5, 60); sc.add(exit);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(-60, 0.9, -60); sc.add(rig);

      let yaw = 0, pitch = 0, run = true;

      hudPrimary.textContent = 'Crystal Maze';
      hudSecondary.textContent = 'Find the exit ring';

      function applyMapVariant(variant) { sc.background = (variant === 'night') ? new THREE.Color(0x0a0d1a) : new THREE.Color(0x101424); }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }

      function restart() {
        rig.position.set(-60, 0.9, -60);
        yaw = 0; pitch = 0; run = true; msg.style.display = 'none';
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => 0,
        setCurrency: () => {},
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;
          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.4, 0.4);

          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          const { inputX, inputY } = getMoveInput(keys, mv);
          const { forward, right } = getCameraBasisXZ(cam, rig.position);
          const next = rig.position.clone().addScaledVector(right, inputX * 8 * dt).addScaledVector(forward, inputY * 8 * dt);

          let blocked = false;
          for (const w of walls) {
            const dx = Math.abs(next.x - w.position.x) - w.geometry.parameters.width / 2 - 0.5;
            const dz = Math.abs(next.z - w.position.z) - w.geometry.parameters.depth / 2 - 0.5;
            if (dx < 0 && dz < 0) { blocked = true; break; }
          }
          if (!blocked) rig.position.copy(next);

          if (rig.position.distanceTo(exit.position) < 5) { run = false; msgText.textContent = 'Exit found! — Maze'; msg.style.display = 'block'; }

          broadcastState();
        }
      };
    }

    // GAME 7: Target Range (rig visible)
    function setupRangeTP(quality, skin) {
      const sc = new THREE.Scene(); sc.background = new THREE.Color(0x223344);
      const cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 800);
      const lights = makeLights('day'); sc.add(lights);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 120), new THREE.MeshStandardMaterial({ color: 0x335577 }));
      floor.rotation.x = -Math.PI / 2; sc.add(floor);

      const rigMat = new THREE.MeshStandardMaterial({ color: skinToColor(skin) });
      const rig = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 0.8, 8, 12), rigMat);
      rig.position.set(0, 1, 40); sc.add(rig);

      const targets = [];
      function spawnTarget() {
        const t = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.25, 10, 20), new THREE.MeshStandardMaterial({ color: 0xffcc55, emissive: 0x553300, emissiveIntensity: 0.2 }));
        t.position.set((Math.random() - 0.5) * 60, 2 + Math.random() * 6, -20 - Math.random() * 30);
        sc.add(t); targets.push(t);
      }
      for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) spawnTarget();

      const bullets = [];
      const bulletSpeed = 40;
      function shoot() {
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444400 }));
        const dir = new THREE.Vector3().subVectors(new THREE.Vector3().copy(rig.position), cam.position);
        dir.y = 0;
        if (dir.lengthSq() < 1e-6) dir.set(0,0,-1);
        dir.normalize();
        b.position.copy(cam.position);
        b.userData.dir = dir.clone();
        sc.add(b); bullets.push(b);
      }
      actionBtn.onclick = shoot;

      let yaw = 0, pitch = 0, run = true, score = 0;

      hudPrimary.textContent = 'Target Range';
      hudSecondary.textContent = 'Score 0 | ACTION to shoot';

      function applyMapVariant(variant) { sc.background = (variant === 'night') ? new THREE.Color(0x162238) : new THREE.Color(0x223344); }
      applyMapVariant('day');
      function applySkin(newSkin) { rigMat.color.setHex(skinToColor(newSkin)); }

      function restart() {
        bullets.forEach(b => sc.remove(b)); bullets.length = 0;
        targets.forEach(t => sc.remove(t)); targets.length = 0;
        for (let i = 0; i < (quality === 'high' ? 16 : 8); i++) spawnTarget();
        rig.position.set(0, 1, 40);
        yaw = 0; pitch = 0; score = 0; hudSecondary.textContent = 'Score 0 | ACTION to shoot';
        run = true; msg.style.display = 'none';
      }

      return {
        scene: sc,
        camera: cam,
        restart,
        dispose() {},
        getCurrency: () => score,
        setCurrency: v => { score = v; hudSecondary.textContent = `Score ${score} | ACTION to shoot`; },
        applyMapVariant,
        applySkin,
        applyWeaponUpgrade: () => {},
        getLocalState: () => ({ pos: rig.position, yaw }),
        update(dt) {
          if (!run) return;

          const { lx, ly } = getLookDelta(1.8);
          yaw += lx * dt;
          pitch = THREE.MathUtils.clamp(pitch + ly * dt, -0.8, 0.8);

          updateThirdPersonCamera(cam, rig.position, yaw, pitch, 8.0, 3.0);

          const mv = moveStick.get();
          rig.position.x += mv.x * 6 * dt;
          rig.position.z += -mv.y * 6 * dt;

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.addScaledVector(b.userData.dir, bulletSpeed * dt);
            if (b.position.length() > 160) { sc.remove(b); bullets.splice(i, 1); continue; }
            for (let j = targets.length - 1; j >= 0; j--) {
              const t = targets[j];
              if (b.position.distanceTo(t.position) < 1.2) {
                sc.remove(t); targets.splice(j, 1);
                sc.remove(b); bullets.splice(i, 1);
                score++; hudSecondary.textContent = `Score ${score} | ACTION to shoot`;
                spawnTarget();
                break;
              }
            }
          }

          broadcastState();
        }
      };
    }

    // MAIN LOOP
    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 1000, 1 / 30); last = now;
      if (running && cleanup && cleanup.update) cleanup.update(dt, now);
      if (scene && camera) renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Resize
    window.addEventListener('resize', () => {
      if (!camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start on menu
    showMenu();

    // Tip: click Connect after choosing a server to see other players as “ghosts” in the same game.
  </script>
</body>
</html>
