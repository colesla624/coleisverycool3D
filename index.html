<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Scary Collector 3D</title>
  <style>
    html, body { margin:0; padding:0; background:#000; height:100%; overflow:hidden; font-family:system-ui, sans-serif; }
    #ui {
      position:fixed; top:0; left:0; right:0; display:flex; gap:8px; align-items:center;
      padding:10px; background:linear-gradient(180deg, rgba(0,0,0,0.7), rgba(0,0,0,0.1));
      color:#f5f5f5; z-index:2; backdrop-filter: blur(2px);
    }
    #stats { flex:1; display:flex; gap:16px; font-weight:600; }
    #toggle { padding:8px 12px; border:1px solid #555; background:#111; color:#eee; cursor:pointer; border-radius:6px; }
    #msg { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); color:#bbb; font-size:12px; }
    #crosshair {
      position:fixed; left:50%; top:50%; width:14px; height:14px; transform:translate(-50%, -50%);
      border:2px solid #b00; border-radius:50%; box-shadow: 0 0 8px #a00; z-index:2; opacity:.7;
    }
    /* Mobile controls */
    #mobile-controls { position:fixed; bottom:18px; left:18px; right:18px; display:none; justify-content:space-between; z-index:2; }
    .stick {
      width:110px; height:110px; border-radius:50%; background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.15); position:relative; touch-action:none;
    }
    .knob {
      width:52px; height:52px; border-radius:50%; background:rgba(255,255,255,0.25);
      position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    }
    .btn {
      width:110px; height:110px; border-radius:50%; background:rgba(255,0,0,0.15);
      border:1px solid rgba(255,0,0,0.35); color:#fff; display:flex; align-items:center; justify-content:center;
      font-weight:700; letter-spacing:1px; user-select:none;
    }
    canvas { display:block; }
    /* Scary vignette */
    #vignette {
      position:fixed; inset:0; pointer-events:none; z-index:1;
      background:radial-gradient(ellipse at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.6) 85%);
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="stats">
      <div id="level">Level: 1</div>
      <div id="collected">Collected: 0 / 0</div>
      <div id="status">Stay quiet… it hears your breath.</div>
    </div>
    <button id="toggle" aria-label="Toggle control mode">Mode: PC</button>
  </div>
  <div id="crosshair" aria-hidden="true"></div>
  <div id="vignette" aria-hidden="true"></div>
  <div id="mobile-controls">
    <div id="left-stick" class="stick"><div class="knob"></div></div>
    <div style="display:flex; gap:18px; align-items:end;">
      <div id="look-stick" class="stick"><div class="knob"></div></div>
      <div id="flash-btn" class="btn">LIGHT</div>
    </div>
  </div>
  <div id="msg">PC: WASD to move, mouse/drag to look, F to toggle flashlight. Mobile: use sticks, LIGHT button.</div>

  <!-- Three.js (r160) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.min.js"></script>
  <script>
    // Basic setup
    let renderer, scene, camera;
    let controls; // pointer lock camera yaw/pitch
    let mode = 'pc'; // 'pc' or 'mobile'
    let clock = new THREE.Clock();
    let move = { f:0, b:0, l:0, r:0 };
    let velocity = new THREE.Vector3();
    let canMove = true;

    // World params
    const WORLD_SIZE = 140;
    const PLAYER_HEIGHT = 1.7;
    const PLAYER_SPEED_BASE = 3.2; // m/s
    const MONSTER_SPEED_BASE = 2.2;
    const LEVELS = [
      { count: 4, monsterSpeed: 2.2, monsterAggro: 0.6 },
      { count: 6, monsterSpeed: 2.8, monsterAggro: 0.8 },
      { count: 8, monsterSpeed: 3.4, monsterAggro: 1.0 },
      { count: 10, monsterSpeed: 3.9, monsterAggro: 1.2 },
    ];
    let levelIndex = 0;
    let collectibles = [];
    let collectedCount = 0;

    // Lighting
    let ambient, flashlight, flashOn = true;

    // Monster
    let monster, monsterTarget = new THREE.Vector3(), monsterGrowlTimer = 0;

    // Post: simple dark fog
    const fogColor = new THREE.Color(0x000000);

    // Mobile sticks state
    const sticks = {
      left: { active:false, ox:0, oy:0, x:0, y:0 },
      look: { active:false, ox:0, oy:0, x:0, y:0 }
    };

    init();
    animate();

    function init(){
      renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = fogColor.clone();
      scene.fog = new THREE.FogExp2(fogColor.clone(), 0.045);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.05, 300);
      camera.position.set(0, PLAYER_HEIGHT, 0);

      // Ground: matte dark plane
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 64, 64);
      const groundMat = new THREE.MeshStandardMaterial({ color:0x0a0a0a, roughness:1, metalness:0 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Scattered pillars/walls for occlusion
      addEnvironment();

      // Lighting
      ambient = new THREE.AmbientLight(0x111111);
      scene.add(ambient);

      flashlight = new THREE.SpotLight(0xffffff, 4.0, 16, Math.PI/9, 0.35, 1.5);
      flashlight.castShadow = true;
      flashlight.shadow.mapSize.set(1024, 1024);
      flashlight.shadow.bias = -0.0001;
      flashlight.target = new THREE.Object3D();
      scene.add(flashlight);
      scene.add(flashlight.target);

      // Controls
      controls = new THREE.PointerLockControls(camera, renderer.domElement);
      document.addEventListener('click', () => {
        if (mode === 'pc') controls.lock();
      });

      // Spawn collectibles and monster
      setupLevel(levelIndex);

      // Events
      window.addEventListener('resize', onResize);
      onResize();
      setupInput();
      updateUI();
      setMode('pc'); // default
    }

    function addEnvironment(){
      const group = new THREE.Group();
      const boxGeo = new THREE.BoxGeometry(3, 6, 0.4);
      const mat = new THREE.MeshStandardMaterial({ color:0x141414, roughness:0.9 });
      for(let i=0;i<28;i++){
        const b = new THREE.Mesh(boxGeo, mat);
        b.position.set(randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45), 3, randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45));
        b.rotation.y = randRange(0, Math.PI);
        b.castShadow = true;
        b.receiveShadow = true;
        group.add(b);
      }
      scene.add(group);

      // Dim red lamps to build tension
      const lampGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
      const lampMat = new THREE.MeshStandardMaterial({ color:0x220000 });
      for(let i=0;i<14;i++){
        const m = new THREE.Mesh(lampGeo, lampMat);
        m.position.set(randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45), 2.8, randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45));
        scene.add(m);
        const red = new THREE.PointLight(0x660000, randRange(0.4,0.9), 6, 2);
        red.position.copy(m.position);
        scene.add(red);
      }
    }

    function setupLevel(idx){
      // Clear old collectibles
      collectibles.forEach(c => scene.remove(c));
      collectibles = [];
      collectedCount = 0;

      const config = LEVELS[idx] || LEVELS[LEVELS.length-1];
      // Place orange dodecahedrons
      const geo = new THREE.DodecahedronGeometry(0.6, 0);
      const mat = new THREE.MeshStandardMaterial({
        color:0xff7a00,
        emissive:0x331800,
        roughness:0.3,
        metalness:0.2
      });

      for(let i=0;i<config.count;i++){
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45), 0.6, randRange(-WORLD_SIZE*0.45, WORLD_SIZE*0.45));
        mesh.castShadow = true;
        mesh.userData.spin = randRange(0.6,1.2);
        scene.add(mesh);
        collectibles.push(mesh);
        // Small pulsing light to help spotting
        const glow = new THREE.PointLight(0xff6b00, 0.9, 6, 1.2);
        glow.position.copy(mesh.position).add(new THREE.Vector3(0,0.4,0));
        scene.add(glow);
        mesh.userData.glow = glow;
      }

      // Monster
      if (monster) scene.remove(monster);
      monster = createMonster();
      scene.add(monster);

      monster.position.set(randRange(-WORLD_SIZE*0.4, WORLD_SIZE*0.4), 1.4, randRange(-WORLD_SIZE*0.4, WORLD_SIZE*0.4));
      monster.userData.speed = config.monsterSpeed;
      monster.userData.aggro = config.monsterAggro;

      // Reset player
      camera.position.set(0, PLAYER_HEIGHT, 0);
      velocity.set(0,0,0);

      updateUI();
    }

    function createMonster(){
      const g = new THREE.Group();

      // Body: elongated, disturbingly thin
      const bodyGeo = new THREE.CapsuleGeometry(0.4, 1.6, 12, 24);
      const bodyMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.95 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = true; body.receiveShadow = true;
      g.add(body);

      // Head: sharp tetra + pulsating emissive
      const headGeo = new THREE.TetrahedronGeometry(0.5, 1);
      const headMat = new THREE.MeshStandardMaterial({ color:0x0b0b0b, emissive:0x120000, roughness:0.8, metalness:0.1 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.4;
      head.castShadow = true;
      g.add(head);

      // Eyes: eerie spotlights
      const eyeL = new THREE.SpotLight(0xff0000, 1.2, 8, Math.PI/9, 0.6, 1);
      const eyeR = eyeL.clone();
      eyeL.position.set(-0.18, 1.4, 0.3);
      eyeR.position.set(0.18, 1.4, 0.3);
      g.add(eyeL, eyeR);
      const target = new THREE.Object3D();
      g.add(target);
      eyeL.target = target; eyeR.target = target;

      // Claws: spiky cones
      const clawGeo = new THREE.ConeGeometry(0.1, 0.5, 8);
      const clawMat = new THREE.MeshStandardMaterial({ color:0x0d0d0d, metalness:0.2, roughness:0.9 });
      for(let i=0;i<6;i++){
        const c = new THREE.Mesh(clawGeo, clawMat);
        c.position.set((i%2?-0.35:0.35), 0.2, (i<3?-0.2:0.2));
        c.rotation.x = Math.PI;
        c.castShadow = true;
        g.add(c);
      }

      // Audio-less "breathing" via scale
      g.userData.pulse = 0;
      return g;
    }

    function setupInput(){
      // Keyboard
      window.addEventListener('keydown', (e)=>{
        if(e.code==='KeyW' || e.code==='ArrowUp') move.f=1;
        if(e.code==='KeyS' || e.code==='ArrowDown') move.b=1;
        if(e.code==='KeyA' || e.code==='ArrowLeft') move.l=1;
        if(e.code==='KeyD' || e.code==='ArrowRight') move.r=1;
        if(e.code==='KeyF') toggleFlashlight();
      });
      window.addEventListener('keyup', (e)=>{
        if(e.code==='KeyW' || e.code==='ArrowUp') move.f=0;
        if(e.code==='KeyS' || e.code==='ArrowDown') move.b=0;
        if(e.code==='KeyA' || e.code==='ArrowLeft') move.l=0;
        if(e.code==='KeyD' || e.code==='ArrowRight') move.r=0;
      });

      // Mouse drag look (works even without pointer lock)
      let dragging=false, px=0, py=0;
      const dragTarget = renderer.domElement;
      dragTarget.addEventListener('mousedown', (e)=>{ dragging=true; px=e.clientX; py=e.clientY; });
      window.addEventListener('mouseup', ()=> dragging=false);
      window.addEventListener('mousemove', (e)=>{
        if(!dragging || mode!=='pc') return;
        const dx = (e.clientX - px), dy = (e.clientY - py);
        px=e.clientX; py=e.clientY;
        camera.rotation.order='YXZ';
        camera.rotation.y -= dx * 0.0022;
        camera.rotation.x -= dy * 0.0022;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      });

      // Mobile sticks
      const left = document.getElementById('left-stick');
      const look = document.getElementById('look-stick');

      setupStick(left, sticks.left, (sx, sy)=>{
        // translate stick to move vector
        move.f = sy < -0.2 ? 1 : 0;
        move.b = sy > 0.2 ? 1 : 0;
        move.l = sx < -0.2 ? 1 : 0;
        move.r = sx > 0.2 ? 1 : 0;
      });
      setupStick(look, sticks.look, (sx, sy)=>{
        camera.rotation.order='YXZ';
        camera.rotation.y -= sx * 0.04;
        camera.rotation.x -= sy * 0.035;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      });

      // Flashlight mobile button
      document.getElementById('flash-btn').addEventListener('click', toggleFlashlight);

      // Mode toggle
      document.getElementById('toggle').addEventListener('click', ()=>{
        setMode(mode==='pc' ? 'mobile' : 'pc');
      });
    }

    function setupStick(el, state, onMove){
      const knob = el.querySelector('.knob');
      const rect = () => el.getBoundingClientRect();

      function setKnob(x, y){
        knob.style.left = `${x}px`; knob.style.top = `${y}px`;
      }

      const start = (clientX, clientY) => {
        state.active = true;
        const r = rect();
        state.ox = clientX - r.left; state.oy = clientY - r.top;
        setKnob(state.ox, state.oy);
      };
      const moveEv = (clientX, clientY) => {
        if(!state.active) return;
        const r = rect();
        const x = clientX - r.left, y = clientY - r.top;
        let dx = x - state.ox, dy = y - state.oy;
        const maxR = 40;
        const len = Math.hypot(dx, dy);
        if(len>maxR){ dx *= maxR/len; dy *= maxR/len; }
        setKnob(state.ox + dx, state.oy + dy);
        state.x = dx/maxR; state.y = dy/maxR;
        onMove(state.x, state.y);
      };
      const end = ()=>{
        state.active=false; state.x=0; state.y=0;
        const r = rect();
        setKnob(r.width/2, r.height/2);
        onMove(0,0);
      };

      el.addEventListener('touchstart', (e)=>{ const t=e.changedTouches[0]; start(t.clientX,t.clientY); }, {passive:true});
      el.addEventListener('touchmove', (e)=>{ const t=e.changedTouches[0]; moveEv(t.clientX,t.clientY); }, {passive:true});
      el.addEventListener('touchend', end);
      el.addEventListener('mousedown', (e)=> start(e.clientX, e.clientY));
      window.addEventListener('mousemove', (e)=> moveEv(e.clientX, e.clientY));
      window.addEventListener('mouseup', end);

      // Center knobs initially
      const r = rect();
      setKnob(r.width/2, r.height/2);
    }

    function setMode(m){
      mode = m;
      const mobileUI = document.getElementById('mobile-controls');
      mobileUI.style.display = (mode==='mobile') ? 'flex' : 'none';
      document.getElementById('toggle').textContent = `Mode: ${mode.toUpperCase()}`;
      document.getElementById('status').textContent = (mode==='mobile')
        ? 'Two sticks: left to move, right to look.'
        : 'WASD to move, mouse/drag to look.';
    }

    function toggleFlashlight(){
      flashOn = !flashOn;
      flashlight.intensity = flashOn ? 4.0 : 0.0;
      document.getElementById('status').textContent = flashOn ? 'The light flickers… stay alert.' : 'Darkness embraces you.';
    }

    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());

      // Flashlight follows camera
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const camPos = camera.position.clone();
      const torchPos = camPos.clone().add(dir.clone().multiplyScalar(0.2)).add(new THREE.Vector3(0, -0.1, 0));
      flashlight.position.copy(torchPos);
      flashlight.target.position.copy(camPos.clone().add(dir.clone().multiplyScalar(4)));

      // Spin collectibles and pulse glow
      collectibles.forEach(c=>{
        c.rotation.y += dt * c.userData.spin;
        const glow = c.userData.glow;
        glow.intensity = 0.7 + 0.3*Math.sin(perfNow()*0.002 + c.userData.spin);
      });

      // Movement
      const speed = PLAYER_SPEED_BASE;
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize().negate();

      let accel = new THREE.Vector3();
      if(move.f) accel.add(forward);
      if(move.b) accel.add(forward.clone().multiplyScalar(-1));
      if(move.l) accel.add(right.clone().multiplyScalar(-1));
      if(move.r) accel.add(right);

      accel.normalize();
      velocity.lerp(accel.multiplyScalar(speed), 0.15);
      camera.position.add(velocity.clone().multiplyScalar(dt));

      // Clamp to world
      camera.position.x = THREE.MathUtils.clamp(camera.position.x, -WORLD_SIZE*0.48, WORLD_SIZE*0.48);
      camera.position.z = THREE.MathUtils.clamp(camera.position.z, -WORLD_SIZE*0.48, WORLD_SIZE*0.48);

      // Monster AI
      updateMonster(dt);

      // Collect detection
      checkCollect();

      // Win/Level up
      if (collectedCount === collectibles.length && collectibles.length>0){
        levelIndex++;
        if(levelIndex >= LEVELS.length){
          document.getElementById('status').textContent = 'You escaped the nightmare.';
          collectibles.forEach(c=>scene.remove(c));
          collectibles = [];
        } else {
          document.getElementById('status').textContent = 'Deeper you go… it follows.';
          setupLevel(levelIndex);
        }
      }

      renderer.render(scene, camera);
    }

    function updateMonster(dt){
      if(!monster) return;

      // Pulse and slight head twitch
      monster.userData.pulse += dt;
      const s = 1.0 + Math.sin(monster.userData.pulse*2.3)*0.03;
      monster.scale.set(s, s, s);
      monster.rotation.y += Math.sin(perfNow()*0.001)*0.002;

      // Target toward player with slight noise
      const toPlayer = camera.position.clone().sub(monster.position);
      const dist = toPlayer.length();
      toPlayer.normalize();

      const noise = new THREE.Vector3(randRange(-0.2,0.2), 0, randRange(-0.2,0.2)).multiplyScalar(monster.userData.aggro);
      monsterTarget.copy(camera.position).add(noise);
      const desired = monsterTarget.clone().sub(monster.position).setY(0).normalize();

      const speed = monster.userData.speed * (flashOn ? 0.9 : 1.15); // faster in darkness
      monster.position.add(desired.multiplyScalar(speed * dt));

      // Look at player
      const facing = camera.position.clone();
      facing.y = monster.position.y;
      monster.lookAt(facing);

      // Eye targets
      const target = monster.children.find(o => o instanceof THREE.Object3D && !o.isMesh);
      if(target) target.position.copy(camera.position);

      // Breathing on neck: low status update when close
      if (dist < 5 && perfNow() > monsterGrowlTimer){
        monsterGrowlTimer = perfNow() + randRange(1200, 2500);
        document.getElementById('status').textContent = ['It is near.','Don’t run… it will.','Hold your breath.','Keep the light steady.'][Math.floor(Math.random()*4)];
      }

      // Catch player -> reset level with sting
      if (dist < 1.2){
        flashOn = true;
        flashlight.intensity = 4.5;
        camera.position.add(toPlayer.clone().normalize().multiplyScalar( -0.6 )); // jolt
        document.getElementById('status').textContent = 'It found you.';
        levelIndex = Math.max(0, levelIndex-1);
        setupLevel(levelIndex);
      }
    }

    function checkCollect(){
      const reach = 1.2;
      for(let i=collectibles.length-1;i>=0;i--){
        const c = collectibles[i];
        if(!c) continue;
        const d = c.position.distanceTo(camera.position);
        if (d < reach){
          c.userData.glow.intensity = 0;
          scene.remove(c.userData.glow);
          scene.remove(c);
          collectibles.splice(i,1);
          collectedCount++;
          document.getElementById('status').textContent = 'You grasp the orange shape. Warmer…';
          updateUI();
        }
      }
    }

    function updateUI(){
      const conf = LEVELS[levelIndex] || LEVELS[LEVELS.length-1];
      document.getElementById('level').textContent = `Level: ${levelIndex+1}`;
      document.getElementById('collected').textContent = `Collected: ${collectedCount} / ${conf.count}`;
    }

    // Utils
    function randRange(a,b){ return a + Math.random()*(b-a); }
    function perfNow(){ return performance.now ? performance.now() : Date.now(); }
  </script>
</body>
</html>
